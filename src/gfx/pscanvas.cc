///////////////////////////////////////////////////////////////////////
//
// pscanvas.cc
//
// Copyright (c) 1998-2001 Rob Peters rjpeters@klab.caltech.edu
//
// created: Mon Aug 27 17:20:09 2001
// written: Mon Aug 27 20:35:55 2001
// $Id$
//
///////////////////////////////////////////////////////////////////////

#ifndef PSCANVAS_CC_DEFINED
#define PSCANVAS_CC_DEFINED

#include "gfx/pscanvas.h"

#include "gfx/bmapdata.h"
#include "gfx/rect.h"
#include "gfx/rgbacolor.h"
#include "gfx/vec2.h"
#include "gfx/vec3.h"

#include "util/dlink_list.h"
#include "util/error.h"

#include <fstream>

#include "util/trace.h"
#include "util/debug.h"

namespace
{
  enum GfxPrim
  {
    NONE=0,
    POINTS=1,
    LINES,
    LINE_STRIP,
    LINE_LOOP,
    TRIANGLES,
    TRIANGLE_STRIP,
    TRIANGLE_FAN,
    QUADS,
    QUAD_STRIP,
    POLYGON
  };
}

class Gfx::PSCanvas::Impl
{
public:
  Impl(const char* filename) :
    itsFstream(filename),
    itsIndentLevel(0),
    itsScales(),
    itsLineWidth(1.0),
    itsGfxPrim(NONE),
    itsVcount(0)
  {
    if (!itsFstream.is_open())
      throw Util::Error(fstring("couldn't open '", filename, "' for writing"));

    itsScales.push_back(Gfx::Vec2<double>(1.0, 1.0));

    itsFstream << "%!\n";
    itsFstream << "%% generated by Gfx::PSCanvas\n";
    itsFstream << "%% $Revision$ \n";
    translate(Gfx::Vec3<double>(306.0, 360.0, 0.0));
    scale(Gfx::Vec3<double>(72.0, 72.0, 1.0));
  }

  ~Impl()
  {
    itsFstream << "showpage\n";
  }

  void indent()
  {
    for (unsigned int i = 0; i < itsIndentLevel; ++i)
      {
        itsFstream << '\t';
      }
  }

  void gsave()
  {
    indent(); itsFstream << "gsave\n";
    ++itsIndentLevel;
    itsScales.push_back(itsScales.back());
  }

  void grestore()
  {
    itsScales.pop_back();
    --itsIndentLevel;
    indent(); itsFstream << "grestore\n";
  }

  void translate(const Gfx::Vec3<double>& v)
  {
    indent(); pushxy(v); itsFstream << "translate\n";
  }

  void scale(const Gfx::Vec3<double>& v)
  {
    indent(); pushxy(v); itsFstream << "scale\n";

    itsScales.back() *= Gfx::Vec2<double>(v.x(), v.y());

    setlinewidth(itsLineWidth);
  }

  void rotate(double angle)
  {
    indent(); itsFstream << angle << " rotate\n";
  }

  template <class Pt>
  void moveto(const Pt& v)
  {
    indent(); pushxy(v); itsFstream << "moveto\n";
  }

  template <class Pt>
  void lineto(const Pt& v)
  {
    indent(); pushxy(v); itsFstream << "lineto\n";
  }

  void newpath()
  {
    itsFstream << "\n"; indent(); itsFstream << "newpath\n";
  }

  void closepath()
  {
    indent(); itsFstream << "closepath\n";
  }

  void arc(double x, double y, double radius,
           double start_angle, double end_angle)
  {
    indent();
    push1(x); push1(y); push1(radius);
    push1(start_angle); push1(end_angle);
    itsFstream << "arc\n";
//      indent(); itsFstream << "4 { pop } repeat\n";
  }

  void bezier(const Gfx::Vec3<double>& p1,
              const Gfx::Vec3<double>& p2,
              const Gfx::Vec3<double>& p3,
              const Gfx::Vec3<double>& p4)
  {
    newpath();
    moveto(p1);
    indent(); pushxy(p2); pushxy(p3); pushxy(p4);
    itsFstream << "curveto\n";
    stroke();
  }

  void stroke()
  {
    indent(); itsFstream << "stroke\n\n";
  }

  void setlinewidth(double w)
  {
    double factor = (itsScales.back().x() + itsScales.back().y()) / 2.0;

    DebugEvalNL(factor);

    indent(); push1(w/factor); itsFstream << "setlinewidth\n";
  }

  void push1(double v)
  {
    itsFstream << v << " ";
  }

  template <class Pt>
  void pushxy(const Pt& v)
  {
    itsFstream << v.x() << " " << v.y() << " ";
  }

  void raiseError(const char* msg)
  {
    throw Util::Error(fstring("error in PSCanvas: ", msg));
  }

  void beginPrimitive(GfxPrim p)
  {
    if (itsGfxPrim != NONE)
      raiseError("mismatched calls to begin/end primitive");

    itsGfxPrim = p;
  }

  void endPrimitive()
  {
    if (itsGfxPrim == NONE)
      raiseError("mismatched calls to begin/end primitive");

    switch(itsGfxPrim)
      {
      case POINTS:
      case LINES:
        ;// nothing
        break;
      case LINE_STRIP:
        stroke();
        break;
      case LINE_LOOP:
        closepath(); stroke();
        break;
      case TRIANGLES:
        break;
      case TRIANGLE_STRIP:
        break;
      case TRIANGLE_FAN:
        break;
      case QUADS:
        break;
      case QUAD_STRIP:
        break;
      case POLYGON:
        break;
      case NONE:
      default:
        raiseError("not in graphics primitive");
        break;
      }

    itsGfxPrim == NONE;
    itsVcount = 0;
  }

  std::ofstream itsFstream;
  unsigned int itsIndentLevel;
  dlink_list<Gfx::Vec2<double> > itsScales;
  double itsLineWidth;
  GfxPrim itsGfxPrim;
  unsigned int itsVcount;
};

Gfx::PSCanvas::PSCanvas(const char* filename) :
  itsImpl(new Impl(filename))
{
}

Gfx::PSCanvas::~PSCanvas()
{
  delete itsImpl;
}

Gfx::Vec2<int> Gfx::PSCanvas::screenFromWorld(
  const Gfx::Vec2<double>& world_pos
  ) const
{
DOTRACE("Gfx::PSCanvas::screenFromWorld(Gfx::Vec2)");
// FIXME
}

Gfx::Vec2<double> Gfx::PSCanvas::worldFromScreen(
  const Gfx::Vec2<int>& screen_pos
  ) const
{
// FIXME
}


Gfx::Rect<int> Gfx::PSCanvas::screenFromWorld(const Gfx::Rect<double>& world_pos) const
{
DOTRACE("Gfx::PSCanvas::screenFromWorld(Gfx::Rect)");
// FIXME
}

Gfx::Rect<double> Gfx::PSCanvas::worldFromScreen(const Gfx::Rect<int>& screen_pos) const
{
DOTRACE("Gfx::PSCanvas::worldFromScreen(Gfx::Rect)");
// FIXME
}

Gfx::Rect<int> Gfx::PSCanvas::getScreenViewport() const
{
// FIXME
}

Gfx::Rect<double> Gfx::PSCanvas::getWorldViewport() const
{
// FIXME
}


bool Gfx::PSCanvas::isRgba() const
{
DOTRACE("Gfx::PSCanvas::isRgba");
  return true;
}

bool Gfx::PSCanvas::isColorIndex() const
{
DOTRACE("Gfx::PSCanvas::isColorIndex");
  return false;
}

bool Gfx::PSCanvas::isDoubleBuffered() const
{
DOTRACE("Gfx::PSCanvas::isDoubleBuffered");
  return false;
}

unsigned int Gfx::PSCanvas::bitsPerPixel() const
{
DOTRACE("Gfx::PSCanvas::bitsPerPixel");
  return 24;
}

void Gfx::PSCanvas::throwIfError(const char* where) const
{
DOTRACE("Gfx::PSCanvas::throwIfError");
  if (itsImpl->itsFstream.fail())
    throw Util::Error("stream failure in PSCanvas");
}


void Gfx::PSCanvas::pushAttribs()
{
  itsImpl->gsave();
}

void Gfx::PSCanvas::popAttribs()
{
  itsImpl->grestore();
}

void Gfx::PSCanvas::drawOnFrontBuffer()
{
  ;// nothing
}

void Gfx::PSCanvas::drawOnBackBuffer()
{
  ;// nothing
}

void Gfx::PSCanvas::setColor(const Gfx::RgbaColor& rgba)
{
DOTRACE("Gfx::PSCanvas::setColor");
// FIXME
}

void Gfx::PSCanvas::setClearColor(const Gfx::RgbaColor& rgba)
{
DOTRACE("Gfx::PSCanvas::setClearColor");
// FIXME
}

void Gfx::PSCanvas::setColorIndex(unsigned int index)
{
DOTRACE("Gfx::PSCanvas::setColorIndex");
// FIXME
}

void Gfx::PSCanvas::setClearColorIndex(unsigned int index)
{
DOTRACE("Gfx::PSCanvas::setClearColorIndex");
// FIXME
}

void Gfx::PSCanvas::swapForeBack()
{
DOTRACE("Gfx::PSCanvas::swapForeBack");
// FIXME
}

void Gfx::PSCanvas::setLineWidth(double width)
{
DOTRACE("Gfx::PSCanvas::setLineWidth");
  itsImpl->setlinewidth(width);
}

void Gfx::PSCanvas::enableAntialiasing()
{
DOTRACE("Gfx::PSCanvas::enableAntialiasing");
// FIXME
}



void Gfx::PSCanvas::pushMatrix()
{
  itsImpl->gsave();
}

void Gfx::PSCanvas::popMatrix()
{
  itsImpl->grestore();
}

void Gfx::PSCanvas::translate(const Gfx::Vec3<double>& v)
{
DOTRACE("Gfx::PSCanvas::translate");
  itsImpl->translate(v);
}

void Gfx::PSCanvas::scale(const Gfx::Vec3<double>& v)
{
DOTRACE("Gfx::PSCanvas::scale");
  itsImpl->scale(v);
}

void Gfx::PSCanvas::rotate(const Gfx::Vec3<double>&, double angle_in_degrees)
{
DOTRACE("Gfx::PSCanvas::rotate");
  itsImpl->rotate(angle_in_degrees);
}


void Gfx::PSCanvas::drawPixels(const Gfx::BmapData& data,
                          const Gfx::Vec2<double>& world_pos,
                          const Gfx::Vec2<double>& zoom)
{
DOTRACE("Gfx::PSCanvas::drawPixels");
// FIXME
}

void Gfx::PSCanvas::drawBitmap(const Gfx::BmapData& data,
                          const Gfx::Vec2<double>& world_pos)
{
DOTRACE("Gfx::PSCanvas::drawBitmap");
// FIXME
}

void Gfx::PSCanvas::grabPixels(const Gfx::Rect<int>& bounds, Gfx::BmapData& data_out)
{
DOTRACE("Gfx::PSCanvas::grabPixels");
// FIXME
}

void Gfx::PSCanvas::clearColorBuffer()
{
DOTRACE("Gfx::PSCanvas::clearColorBuffer");
// FIXME
}

void Gfx::PSCanvas::clearColorBuffer(const Gfx::Rect<int>& screen_rect)
{
DOTRACE("Gfx::PSCanvas::clearColorBuffer(Gfx::Rect)");
// FIXME
}

void Gfx::PSCanvas::drawRect(const Gfx::Rect<double>& rect)
{
DOTRACE("Gfx::PSCanvas::drawRect");

  itsImpl->newpath();
  itsImpl->moveto(rect.bottomLeft());
  itsImpl->moveto(rect.bottomRight());
  itsImpl->moveto(rect.topRight());
  itsImpl->moveto(rect.topLeft());
  itsImpl->closepath();
  itsImpl->stroke();
}

void Gfx::PSCanvas::drawCircle(double inner_radius, double outer_radius,
                               unsigned int, unsigned int)
{
DOTRACE("Gfx::PSCanvas::drawCircle");

  itsImpl->newpath();
  itsImpl->arc(0.0, 0.0, outer_radius, 0.0, 360.0);
  itsImpl->stroke();
}

void Gfx::PSCanvas::drawBezier4(const Gfx::Vec3<double>& p1,
                                const Gfx::Vec3<double>& p2,
                                const Gfx::Vec3<double>& p3,
                                const Gfx::Vec3<double>& p4,
                                unsigned int /*subdivisions*/)
{
DOTRACE("Gfx::PSCanvas::drawBezier4");
  itsImpl->bezier(p1, p2, p3, p4);
}

void Gfx::PSCanvas::beginPoints()
{
  itsImpl->beginPrimitive(POINTS);
}

void Gfx::PSCanvas::beginLines()
{
  itsImpl->beginPrimitive(LINES);
}

void Gfx::PSCanvas::beginLineStrip()
{
  itsImpl->beginPrimitive(LINE_STRIP);
}

void Gfx::PSCanvas::beginLineLoop()
{
  itsImpl->beginPrimitive(LINE_LOOP);
}

void Gfx::PSCanvas::beginTriangles()
{
  itsImpl->beginPrimitive(TRIANGLES);
}

void Gfx::PSCanvas::beginTriangleStrip()
{
  itsImpl->beginPrimitive(TRIANGLE_STRIP);
}

void Gfx::PSCanvas::beginTriangleFan()
{
  itsImpl->beginPrimitive(TRIANGLE_FAN);
}

void Gfx::PSCanvas::beginQuads()
{
  itsImpl->beginPrimitive(QUADS);
}

void Gfx::PSCanvas::beginQuadStrip()
{
  itsImpl->beginPrimitive(QUAD_STRIP);
}

void Gfx::PSCanvas::beginPolygon()
{
  itsImpl->beginPrimitive(POLYGON);
}

void Gfx::PSCanvas::vertex2(const Gfx::Vec2<double>& v)
{
  switch(itsImpl->itsGfxPrim)
    {
    case POINTS:
      itsImpl->newpath(); itsImpl->moveto(v); itsImpl->stroke();
      break;
    case LINES:
      {
        if (itsImpl->itsVcount % 2)
          {
            itsImpl->lineto(v); itsImpl->stroke();
          }
        else
          {
            itsImpl->newpath(); itsImpl->moveto(v);
          }
      }
      break;
    case LINE_STRIP:
    case LINE_LOOP:
      {
        if (itsImpl->itsVcount == 0)
          {
            itsImpl->newpath(); itsImpl->moveto(v);
          }
        else
          {
            itsImpl->lineto(v);
          }
      }
      break;
    case TRIANGLES:
      break;
    case TRIANGLE_STRIP:
      break;
    case TRIANGLE_FAN:
      break;
    case QUADS:
      break;
    case QUAD_STRIP:
      break;
    case POLYGON:
      break;
    case NONE:
    default:
      itsImpl->raiseError("not in graphics primitive");
      break;
    }

  ++(itsImpl->itsVcount);
}

void Gfx::PSCanvas::vertex3(const Gfx::Vec3<double>& v)
{
  vertex2(Gfx::Vec2<double>(v.x(), v.y()));
}

void Gfx::PSCanvas::end()
{
  itsImpl->endPrimitive();
}

void Gfx::PSCanvas::flushOutput()
{
DOTRACE("Gfx::PSCanvas::flushOutput");
  itsImpl->itsFstream << std::flush;
}

static const char vcid_pscanvas_cc[] = "$Header$";
#endif // !PSCANVAS_CC_DEFINED
