///////////////////////////////////////////////////////////////////////
//
// glutil.cc
//
// Copyright (c) 2002-2002 Rob Peters rjpeters@klab.caltech.edu
//
// created: Sat Aug  3 17:25:48 2002
// written: Sun Nov  3 13:41:11 2002
// $Id$
//
///////////////////////////////////////////////////////////////////////

#ifndef GLUTIL_CC_DEFINED
#define GLUTIL_CC_DEFINED

#include "togl/glutil.h"

#include <GL/gl.h>
#include <GL/glx.h>

#include "util/debug.h"
#include "util/trace.h"

//---------------------------------------------------------------------
//
// Load the named bitmap font as a sequence of bitmaps in a display list.
// fontname may be one of the predefined fonts like TOGL_BITMAP_8_BY_13, or an
// X font name.
//
//---------------------------------------------------------------------

namespace
{
  const unsigned int MAX_FONTS = 1000;
  static GLuint ListBase[MAX_FONTS];
  static GLuint ListCount[MAX_FONTS];

  const char* const DEFAULT_FONTNAME = "fixed";
}

unsigned int GLUtil::loadBitmapFont(Display* dpy, const char* fontname)
{
DOTRACE("GLUtil::loadBitmapFont");

  static int firstTime = 1;

  /* Initialize the ListBase and ListCount arrays */
  if (firstTime)
    {
      for (unsigned int i = 0; i < MAX_FONTS; ++i)
        {
          ListBase[i] = ListCount[i] = 0;
        }
      firstTime = 0;
    }

  if (fontname == 0)
    fontname = DEFAULT_FONTNAME;

  Assert( fontname );

  XFontStruct *fontinfo = XLoadQueryFont( dpy, fontname );
  if (!fontinfo)
    {
      return 0;
    }

  int first = fontinfo->min_char_or_byte2;
  int last = fontinfo->max_char_or_byte2;
  int count = last-first+1;

  GLuint fontbase = glGenLists( (GLuint) (last+1) );
  if (fontbase==0)
    {
      return 0;
    }
  glXUseXFont( fontinfo->fid, first, count, (int) fontbase+first );

  // Record the list base and number of display lists for unloadBitmapFont().
  {
    for (unsigned int i = 0; i < MAX_FONTS; ++i)
      {
        if (ListBase[i]==0)
          {
            ListBase[i] = fontbase;
            ListCount[i] = last+1;
            break;
          }
      }
  }

  return fontbase;
}

unsigned int GLUtil::loadBitmapFont(Display* dpy, NamedFont font)
{
DOTRACE("GLUtil::loadBitmapFont");

  const char* name = DEFAULT_FONTNAME;

  switch (font)
    {
    case BITMAP_FIXED:
      name = "fixed";
      break;
    case BITMAP_8_BY_13:
      name = "8x13";
      break;
    case BITMAP_9_BY_15:
      name = "9x15";
      break;
    case BITMAP_TIMES_ROMAN_10:
      name = "-adobe-times-medium-r-normal--10-100-75-75-p-54-iso8859-1";
      break;
    case BITMAP_TIMES_ROMAN_24:
      name = "-adobe-times-medium-r-normal--24-240-75-75-p-124-iso8859-1";
      break;
    case BITMAP_HELVETICA_10:
      name = "-adobe-helvetica-medium-r-normal--10-100-75-75-p-57-iso8859-1";
      break;
    case BITMAP_HELVETICA_12:
      name = "-adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1";
      break;
    case BITMAP_HELVETICA_18:
      name = "-adobe-helvetica-medium-r-normal--18-180-75-75-p-98-iso8859-1";
      break;
    }

  return GLUtil::loadBitmapFont(dpy, name);
}

// Release the display lists which were generated by loadBitmapFont().
void GLUtil::unloadBitmapFont(unsigned int fontbase)
{
DOTRACE("GLUtil::unloadBitmapFont");

  for (unsigned int i = 0; i < MAX_FONTS; ++i)
    {
      dbgEvalNL(3, i);
      if (ListBase[i]==fontbase)
        {
          dbgEvalNL(3, fontbase);
          dbgEval(3, ListBase[i]); dbgEvalNL(3, ListCount[i]);
          glDeleteLists( ListBase[i], ListCount[i] );
          ListBase[i] = ListCount[i] = 0;
          return;
        }
    }
}

static const char vcid_glutil_cc[] = "$Header$";
#endif // !GLUTIL_CC_DEFINED
