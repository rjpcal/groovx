* -*- outline -*-

* ChangeLog 2003
  $Id$

* Rob Peters <rjpeters at klab dot caltech dot edu>

* (15-May-2003, done 22-May-2003) Premature destruction of VolatileObject's.

  OK: we have
      RefCounted->Object->GWT::Widget->TkWidget->Toglet

  TkWidget calls incrRefCount() in its constructor, to make sure that the
  ref count stays. But then Toglet's constructor does something that
  throws. This causes any fully-constructed subobjects (such as TkWidget)
  to have their destructors run. Eventually this leads to ~RefCounted()
  with refcount != 0. Where is the design flaw here?

  Seems like the problem is with TkWidget calling incrRefCount(). Ideally,
  we'd like the "last" constructor to call incrRefCount() just before it
  finishes. Hmmm... in fact it's not even TkWidget that is the "volatile"
  object -- it's really Toglet since that's where we override
  isNotShareable(). So (1) the solution is that Toglet should handle the
  incrRefCount() call, and (2) it probably makes more sense to put that
  incrRefCount() into Toglet::make() rather than directly into Toglet().

  OK, come to think of it, why do we need to have the true refcount > 0 for
  volatile objects EVER? In principle we should make the refCount()
  function return 1 always for volatile objects. Maybe the problem is that
  we have isNotShareable() as a virtual function... it'd be better if it
  were a boolean flag inside RefCounts... then we could do more with it.

  * rename isNotShareable() to isVolatile()
  * should add a boolean isVolatile flag to RefCounts
  * should never call RefCounted::incr/decrRefCount() for volatile objects
  * RefCounts::getStrong() should just return 1 if isVolatile is true

  OK, all this is done... RefCounts+RefCounted now have really strict
  enforcement on what happens with the refcounts.

* (29-May-2003, done 20-June-2003) issues with icc 8.0 beta

  compiler error on anonymous namespace in gzstreambuf.cc:

    #include <iostream>
    namespace
    {
      struct X : public std::iostream
      {
        X() : std::iostream(0) {}
      };
    }

  this appears to be fixed with the 8.0.032 package (build 20030612Z)

* (29-May-2003, done 20-June-2003) issues with icc 8.0 beta

  dynamic_cast disaster

    #include <stdio.h>

    struct A { virtual ~A() {} };

    struct B : public A {};

    A* noop(A* a) { return a; }

    int main()
    {
      B b;

      A* a = &b;
      A* a2 = noop(a);

      // all of these succeed except the last, which causes a segfault

      B* b1 = dynamic_cast<B*>(a);        printf("1: %x\n", (void*)b1);
      B* b2 = dynamic_cast<B*>(a2);       printf("2: %x\n", (void*)b2);
      B* b3 = dynamic_cast<B*>(noop(a));  printf("3: %x\n", (void*)b3);
      B& b4 = dynamic_cast<B&>(*a);       printf("4: %x\n", (void*)&b4);
      B& b5 = dynamic_cast<B&>(*a2);      printf("5: %x\n", (void*)&b5);
      B& b6 = dynamic_cast<B&>(*noop(a)); printf("6: %x\n", (void*)&b6);
    }

  this appears to be fixed with the 8.0.032 package (build 20030612Z)

* (done 29-May-2003) workarounds for icc 8.0 beta

  * icc defines __GNUC__ in demangle.cc?

    OK, can work around this with a autoconf test for <cxxabi.h> instead.

  * premature failure of std::ofstream object in ~Prof()

    OK, can use C stdio (FILE*) instead.

* (23-Feb-2002, done 18-Jul-2003) OS X issues
  explicit template instantiation does not work (e.g. util/multivalue.cc)
  OK, the workaround hack is not needed with more recent OSX compilers
