$Id$
"Make it run, make it run correctly, make it run fast"

*** FRONT of priority queue ***

(14-Jan-2000) Need to flesh out the Pipe class that has been
introduced in Bitmap::loadPbmGzCmd().

(11-Jan-2000) ObjList::saveObjects should not save base classes, perhaps?

(11-Jan-2000) Need a way to defer loading of pbm files from when
Bitmap's are deserialized until when they are first used. This would
require a way to for the files to be loaded on demand. It would have
the added benefit that in an fMRI script, we would only have to load
the bitmaps that are actually used in the experiment.

(11-Jan-2000) Need to have a way for Bitmap's to store a .pbm.gz
filename as their source, so that we avoid the problems with "can't
find .temp.pbm" on reloading. This means that Bitmap's (and Pbm's)
need to be able gzip-ed files on their own, without the help of Tcl.

(8-Jan-2000) How to read/write CountedPtr's? This is the big barrier
to establishing CountedPtr's as a better way to manage objects between
C++ and Tcl. Probably Reader/Writer need a special method for
CountedPtr's. The question is how to keep track of the pointers to the
reference counts. Or... we could put the reference count right in
IO... Aha! Instead of AsciiStreamReader maintaining a map<unsigned
long, IO*> during deserialization, we could use a map<unsigned long,
CountedPtr<IO> >. However, this introduces a split from the semantics
of readOwnedObject()... this suggests that we need a separate map for
owned objects. As this transition will require a nearly universal
switch to CountedPtr's, we need to provide a feasible migration route,
perhaps by providing the ability to short-circuit CountedPtr's
ref-counting at first.

(16-Dec-1999) Try to fix ToglConfig::loadFonti on irix by switching
fontnumber to a long before casting to char*.

(14-Dec-1999) Need Canvas& arguments on GrObj::getBoundingBox,
GrObj::grGetBoundingBox, and Bitmap::grabScreenRect/grabWorldRect.

(14-Dec-1999) Could have a GrObjProxy that internally stores an
ObjList id, and then forwards all its operations to that object. This
way dumb clients (who don't need to know whether a GrObj* is actually
a GrObjProxy) could just depend on the GrObj interface rather than
dragging in the ObjList. Hmmm... unfortunately these clients also tend
to depend on the objid.

(14-Dec-1999) The implementation of GrObj should be moved into a
separate component since it is fairly heavyweight. Subclasses would
then be required to provide this implementation upon
construction. This method would allow clients, but not subclasses, of
GrObj to avoid dependencies on such components as bitmaprep, etc. But,
how to avoid having to make all GrObj functions virtual? We'd like
some to stay non-virtual. Aha! The new lightweight GrObj shouldn't
even have the grRender(), grUnRender(), or grGetBoundingBox()
functions... these will first be defined in GrObjImpl.

(1-Dec-1999) Unsavory dependencies:
  EventResponseHdlr on ObjTogl -- axed via Widget abstraction!
  EventResponseHdlr on SoundList
  ObjTogl on Tlist -- compilation dep gone, but still link dep
  Trial on ObjList, PosList?
  Block on Tlist?
  BitmapRep on GLCanvas::theCanvas()

... I see that this whole PtrList business introduces some wacky
  dependencies... I don't think C++ clients should be depending on the
  PtrList's directly. Instead, maybe the PtrList's should manage
  CountedPtr's or something similar, so that the integer indices are
  only visible in Tcl.

(14-Dec-1999) ExptDriver should really own the ToglConfig... maybe it
should arrange to create this as part of application startup?

(12-Dec-1999) Could have an abstract class for timer callbacks, one
subclass of which could use a Tcl_Interp* to register timer callbacks.

listitempkg.h:75: cannot dynamic_cast
`*(this->Tcl::CTclIoItemPkg<XBitmap>::_vptr$TclPkg +
32)->__vtbl_ptr_type::__pfn((this +
(this->Tcl::CTclIoItemPkg<XBitmap>::_vptr$TclPkg +
32)->__vtbl_ptr_type::__delta), id)' (of type `class XBitmap') to type
`class Tcl::IO &'

(7-Dec-1999) I guess I need to split tclitempkg into two componenets,
one with TclItemPkg, Getter, Setter, Attrib, and Action, and another
with CTclItemPkg, CTclIoItemPkg, etc.

(6-Dec-1999) Replace GrObj::getScreenFromWorld etc. with
Canvas::... in BitmapRep (how to get the Canvas& arguments where they
need to be?)

(6-Dec-1999) Do we also want Canvas& arguments in the bounding box
call chain?

(21-Nov-1999) Would like to split project into loosely coupled
subprojects that can be used separately in other projects. Each
subproject should generate its own library. OK, I think the way to
manage this large task is to split the steps into 1) logically
partitioning things into namespaces, 2) physically partioning things
into different libraries, 3) physically partitioning the source +
libraries into different directories, and 4) generating separate
makefiles for each directory. I've started this process with doing
1+2) for the Tcl namespace, and the tclworks library.

(3-Dec-1999) I have a potential type-system loophole with TclItemPkg
and TclItemCmd... TclItemPkg blindly casts TclItemCmd::getItemFromId()
from void* to T*, without any guarantee that TclItemPkg is dealing
with the correct type. Suggests we need a template wrapper around
TclItemPkg?

(1-Dec-1999) There's some suspicious memory management going on in
BitmapRep with regard to the BmapRenderer... who owns it? The
BitmapRep or the owner of BitmapRep? BitmapRep could have a
resetRenderer() operation.

(29-Nov-1999) TrialEvent's could internally adjust their requested
delays so that the actual delays converge to the requested
delays. This would require some care to ensure that we don't send the
entire system into an unstable oscillation. We'd maintain two values:
itsIdealDelay, and itsRequestedDelay. The ideal delay remains
constant, but we modify the requested delay based on experience to try
to get the actual delay to meet the ideal delay. There are several
strategies we could use to make these adjustments-- one would be to
try to minimize the total timing error of the TrialEvent, another
would be to minimize the average absolute value of the timing
error. [Later] We could also control the timing more globally... where
a block or experiment knows how long it is supposed to last, then
timer events report to the block how long they requested, and how long
they actually lasted. Then the block could adjust the requested times
for future trial events in order to compensate.

========================================================================
Subsection on refactoring ToglConfig into Widget, Camera, Canvas

(27-Nov-1999) Who uses theToglConfig()?
EventResponseHdlr uses the Widget part in the attend() and ignore() methods
ExptDriver uses the Canvas part it in swapBuffers().
ExptTcl uses the Widget part in BeginCmd, SetStartCommand,
ObjTogl uses the Widget Part in DestroyCmd.
ObjToglPkg uses it in getCItemFromId().
xbitmap.cc uses a special X11Widget subclass in init_class().

Eventually, we'd like to have a list of Widget's, with ExptDriver
maintaining the current one for an experiment, so that experiment
participants can request it from ExptDriver (or it passes the Widget
to them).

(27-Nov-1999) One important reason for refactoring all this stuff is
so that we can have more than one active Togl widget... then we can
improve user interface, e.g. bring up a dialog box to edit a GrObj,
etc.

(27-Nov-1999) It looks like there should be a Window/Widget class,
that contains a Camera and a Canvas. Or does the Camera need to
contain the Canvas? It seems like the Window will pass a redraw
request on to its Camera, which would need to have a Canvas reference
to pass to the graphic objects in order for them to redraw themselves.

(17-Nov-1999) The emerging Camera abstraction: includes some of the
ToglConfig functionality such as perspective or orthographic
projection, viewing distance, viewport, and which will be used by a
Window/Widget to handle redraws and reconfigures. A subclass of Camera
can carry the Tlist functionality such as setVisible(), setCurTrial(),
etc. Actually, it seems there are two different parts to camera: one
is the object/scene that it is viewing, and the other defines the sort
of projection that is used.

(17-Nov-1999) The emerging Canvas abstraction: could be passed to
GrObj's in their grRender() function. How does it relate to a
Window/Widget? Is it owned, referred to, etc.? Has a width+height.
------------------------------------------------------------------------

(22-Nov-1999) Hey, I think I might be able to totally do away with
PtrList's, at least in the public interface. I think that they could
be wrapped into the base class, so that every GrObj created is
automatically placed in the ObjList, and anytime a GrObj is destroyed
it is removed from the PtrList. This would just entail overriding
operator new + delete for that class. The class would have static
operations that mimic the PtrList's operations.

(22-Nov-1999) Need to get rjp_subject working. 1) Need to maintain a
do_expt script in each subject's directory. 2) Need to make sure that
autosave file is writable by rjp_subject, and if not, use a different
filename. (Maybe use temp filename generating facility of OS?).

(10-Nov-1999) Should objectify the debugging facilities. Should try to
allow a way for dynamic tracing + debugging. We can make the debugging
stuff into members of the Trace class. Define a new class,
TraceChannel, that stores an ostream*, and allows tracing to be turned
on or off.

========================================================================
(29-Nov-1999) How to automate the data analysis? Need to bridge the
gap between output of Grsh program running experiment, and necessary
input to Matlab to process data. I think this is a possible route:

		1) expt completes and saves files

		2) a Grsh script runs and processes the data further, generating
         the data files that matlab needs, and also **generating a
         Matlab script file (.m file)** that we can run to process the
         data.
			
		3) Run the .m file to finish the data processing.

What input does this process need? We need to know the location of the
pairs/triads experiment file, and of the classification experiment
files.

Breakdown of classification process:

1) make incidence matrices (see make_inc_mat_mfaces_s50.m as example)
   from resp files.
2) run models (see run_mfaces_models.m as example)

Important data:

- base directory which contains subjects' individual directories
- name of subject (encoded as directory for subject)
- date of pairs experiment (to create pairs directory based on date)
- name for type of objects
- names of response files in probe experiments

Use case:
1) run experiments + collect multiple data files from several subjects
2) run mds analysis on results of similarity tasks
3) compile subjects' overall categorization results across all clones
4) fit various models to the categorization results

------------------------------------------------------------------------

========================================================================
(17-Nov-1999) Need a way to automate the experiment-running process to
do several things... [later] Aha! I see that this is just yet another
level of abstraction on top of block/experiment etc. In fact, there
might be two abstractions: one which defines a series of experiments
to be run together as a session (ExperimentSession?), in which the
next experiment might depend on the results of the previous one, and a
higher level abstraction which defines a series of sessions
(ExperimentSeries) that constitute an entire experiment, lasting
perhaps several weeks. An ExperimentSession probably requires only one
process, whereas an ExperimentSeries requires multiple processes to be
run, over the course of many days/weeks (and therefore requires the
help of some persistent data in the form of files in order to maintain
itself over the entire duration).

1) 'log in' a subject ==> change to the correct directory
2) run an experiment
3) move the experiment data files to appropriate names and chmod appropriately
	--> this requires ExptDriver() to provide the names of its most
	recently saved files
4) possibly repeat steps 2+3
	--> We can store a file that contains a list of experiment commands
	that should be issued. A separate file, called 'next_expt' can be
	updated to always contain the command needed to run the next
	experiment. When one experiment is completed, the driver rewrites
	the 'next_expt' file appropriately.
5) exit
------------------------------------------------------------------------

(17-Nov-1999) Can replace my homegrown eatWhitespace() functions with
the builtin 'ws' istream manipulator. ... This would be
IO::eatWhitespace() and AsciiStreamReader::eatWhitespace().

(17-Nov-1999) Can we automate the use of Matlab for data analysis by
opening a pipe to a Matlab process from within Tcl?

(16-Nov-1999) Should have a Reader/Writer subclass pair that mimicks
the terse format that is used by serialize/deserialize.

(10-Nov-1999) Had an idea for allowing TclCmd's to be more
generic... define abstract classes of extractors, which provide ways
to get C++ types out of Tcl_Obj*'s. The native types would be
straightforward, but more interesting would be to define extractors
for STL containers... actually, would this give me anything more than
I have now with the various getXxxFromArg() methods in TclCmd? Answer:
Yes! -- it would provide a bit more modularity, since the extractors
would be separate from the commands, and new extractors could be
introduced without having to add a method to TclCmd by subclassing it.

(5-Nov-1999) AsciiStreamReader should gracefully report an invalid
attribute name, perhaps by throwing a NoSuchAttributeError.

(2-Nov-1999) Major flaw in serialize/deserialize semantics: when doing
virtual construction with newIO, we first read the typename, and then
deserialize using ~IO::TYPENAME in the flags. However, this turns off
typename reading in base classes as well, which is disastrous. For
now, I guess we can explicitly force typenames to be used when calling
serialize or deserialize on a base class, but this is pretty ugly.

(22-Oct-1999) Can now write generic IO tests, which take a class name
and a list of properties, and then try reading/writing an object to
make sure the values of those properties are correctly retrieved.

(21-Oct-1999) Gabor needs to have serialize/deserialize implemented.

(20-Oct-1999) There is a memory leak (I think) in
AsciiStreamReader::readCstring()... which returns a new char[] to a
client that may not be prepared to assume ownership.

(19-Oct-1999) Just realized how testing should work for base-class
functionality... the base class test package should provide a way to
run all of the base class tests on a particular subclass. In Tcl, this
should just be a matter of providing the subclass name to a proc, for
example 'IO::testSubClass FixPt'. This can eliminate a lot of
duplicated script code, and allows all subclasses to benefit when new
base class tests are written. OK, I just realized also that it
would make sense to put the test procedures for a class inside that
class's Tcl namespace... this can be wholly at the script-level
without having to add any C code.

(19-Oct-1999) I'm suddenly turned off by PtrList's: 1) I just fixed a
bug in insertAt that is equivalent to the 'check for assignment to
self' in assignment operators, and 2) even worse, I just realized that
it would be disastrous if the same pointer were stored at two
locations in a PtrList... double deletion would result. This suggests
to me that we need a more flexible and robust memory-management
scheme, probably using reference-counted smart pointers. This will
also eliminate a lot of "dangling id" problems that necessitated
getCheckedPtr(id). But what sort of Tcl interface should the
ref-counted smart-pointers have?

(18-Oct-1999) How to handle base classes in the Reader/Writer
interface? We can can just call Base::readFrom() or Base::writeTo(),
which will generally work, unless a base class and subclass happen to
share private data members with the same name. Perhaps we could avoid
this by giving a fully scoped attribute name (i.e. 'Face::noseLength')
when storing or retrieving attributes. The disadvantage of this is
that it is only a convention, and as such it could be ignored on
purpose or by oversight.

(15-Oct-1999) There's a unifying force behind two things: 1) Tcl's
idea of dual representation-- native rep/string rep; and 2) idea of
serializing objects to a stream by converting them into a string
format. I don't know exactly what to make of it at this point, but it
seems like it could be useful... This is parallel to the duality of
makeIoList and getProperties()... these should really be
merged. Dual-rep objects (perhaps a new DynamicValue subclass of
Value) could be used in the implementation of AsciiStreamReader.

(14-Oct-1999) Gabor should have a patchWidth/patchHeight attribute,
that controls not the size of the object inside the patch, but the
size of the patch itself (i.e. how big the window onto the Gabor patch
is).

(12-Oct-1999) The SGI-related bugs start rolling in... Had to
conditionally compile out the delete's in ~TclPkg since they were
causing an inexplicable bug.

(11-Oct-1999) Could write a Widget class that encapsulates the details
of Tk widgets. Then we could extend with subclasses... for example one
subclass could be designed to edit Property's of another class.

(8-Oct-1999) GrObj should use Property's, so that GrObj attributes can
be added to the list of a subclass's attributes.

(6-Oct-1999) GrObj needs a saveBitmapCache() function to dump a cached
bitmap to file. Or maybe just a writeBitmap() function, that would
apply even for objects whose mode is not one of the bitmap cache
modes, and that would generate a temporary bitmap if necessary.

(6-Oct-1999) Should Property's be Observable's? Is this worth the
extra space? Perhaps only some properties should be Observable's. How
would this be done?

(5-Oct-1999) Maybe TimingHdlr should have a toggle switch to indicate
what the behavior should be when a response is seen. (Whether to
cancel StartEvents, etc.).

(2-Oct-1999) Property's could store a pointer to something like
ValChecker, which has a virtual function, that could variously do 1)
check whether new value is the same as the current value, 2) check
whether the new value is in bounds/valid. If the ValChecker* is 0,
then no check is done, and not much time is lost worrying about the
check. This would avoid the problem of trying to maintain parallel
hierarchies of Property, BoundedProperty, etc.

(2-Oct-1999) One class could theoretically provide more than one
MetaClass, in order to provide different interfaces.

(2-Oct-1999) Eventually, it should be possible to declare all of the
necessary Tcl functions for a class with something like template<C>
initTcl(), which in turn would call C::getProperties,
C::getMethods... etc.

(2-Oct-1999) Should be able to call up a property info struct from a
class by giving it a string name of a property.

(29-Sep-1999) It would be nice, in the Value/Property scheme, to be
able to avoid triggering sendChangeMsg() when the value doesn't
actually change (e.g if the new value was the same as the current
value, or was out of bounds).

(20-Sep-1999) Fixed a nasty memory corruption bug that was due to
neglecting to set GL_PACK_ALIGNMENT appropriately before reading pixel
data out of the screenbuffer into main memory. Since the value for
GL_PACK_ALIGNMENT defaults to 4, it is not sufficient to allocate
(width*height) bytes if the row size is not divisible by 4. How to
avoid these problems in the future? Include a byteAlignment member in
Bitmap, add a utility function that reallocates appropriate space for
a given width and height.

(16-Sep-1999) BUG: if somehow the current trial becomes invalid, it is
impossible to show a new trial because the program always tries to
undraw the current, invalid trial before drawing a new one. So there
is no way to un-corrupt the program state.

(16-Sep-1999) Could use some functionality in a base class to handle
the pattern of making all/some of a classes members IoWrapper's, then
doing serialize by putting the IoWrapper's into a vector and iterating
over them. Base class could handle serialize/deserialize, and would
forward the list generation to subclasses via the virtual function
makeIoList().

(13-Sep-1999) It is becoming more urgent to set up dynamic loading of
Tcl modules, so that not everything must always be loaded when
starting up grsh.

(13-Sep-1999) Should change ToglConfig to a "Camera"-style interface,
a la Open Inventor. Then different types of camera's, such as
orthographic or perspective projection, could be related by
inheritance from an abstract base class Camera. Parameters include
viewing volume, autoUpdate (determines if scene is automatically
redrawn upon Expose or Resize events)...

(21-Jun-1999) Can get seg-fault by closing Tk-Togl window while tcl
shell is still running, then calling exit. Problem is: who 'owns' the
ToglConfig, and who 'owns' the Togl widget that it contains? I would
like ToglConfig to own its widget, and for ObjTogl to own the
ToglConfig singleton. But the problem is that the ToglConfig doesn't
have total control over the destruction of its widget, since the
widget can be destroyed by dismissing the top-level application window
or by exiting the application. If the ToglConfig handled the widget's
destruction, it could arrange to delete itself when the widget was
destroyed, but then it would have no way of informing ObjTogl that it
had gone away... Right now I've patched the problem by having ObjTogl
own the widget, in the sense of creating and destroying it. There is a
static destroyCallback that is registered through the Togl API as a
destroy callback; this callback will be invoked in one of several ways...

(19-Jul-1999) Eureka! The right way to build various experiments is
now suddenly clear (!) There must be an abstract base class
ExptBuilder that will have pretty much one function, build() (but how
does it get the params that it needs?). This abstract class can have a
Tcl interface associated with it. Subclasses will know how to build
specific types of experiments, such as triads expt's, pairs exp'ts,
facefinder expt's, etc. In particular, one subclass could do all its
work in Tcl by just taking a Tcl script as its constructor argument,
and Tcl_Eval'ing that script in its build() function. This class would
still allow great flexibility in expt-building since Tcl build scripts
could be changed without recompiling; however the framework allows
more stablebuild scripts to be migrated to their own subclasses on the
C++-side. But wait... what advantage is there to having all this stuff
in virtual functions? i.e., where is the client that will benefit by
not having to know the concrete class of some ExptBuilder?

(25-Jun-1999) Need a coherent way of handling colors............
[Earlier] Who should own foreground/background information? Seems like
it could belong to either or both of GrObj and Position. Maybe best
idea is to use ColoredObj and ColoredPosition as derived classes, if
necessary. Default behavior of non-colored classes would be to use
whatever color was active, while colored classes would set their own
color when they do their action. Useful scenarios would be
ColoredPosition with regular GrObj, or ColoredObj with regular
Position. [Later] Maybe new subclasses aren't needed, since this would
create a dual hierarchy for all other subclasses (i.e. there would
have to be a regular FixPt and a ColoredFixPt). Part of the state of
both GrObj and Position could be whether they have a color preference;
if so, they use it, and if not, they use the current color when they
are drawn. [15-Jul] Aha! I think I've got it... there should be a
class GLAttributes that can specify things like foreground/background
color, line width, etc. and one subclass could be a null subclass that
just does nothing; a virtual method setAttribs() would arrange to set
all of the attribs controlled by the class (but how to unset them?
would be nice to use constructor/destructor via lexical scope). Then
both GrObj and Position could contain a GLAttributes member which
would control the appropriate attributes, if any. [3-Aug] What is
needed is a good abstraction to model what happens when a trial is
rendered. In particular, how to represent, say, that we should go to a
Position, then draw a GrObj, then un-go from that Position, then go to
a new Position... We need some kind of a GraphicParticipant class,
that has begin() and end() functions, that is able to capture at once
the current Position and GrObj classes, as well as the forthcoming
GlAttributes class. I guess this is the composite pattern-- which we
can use to build an arbitrarily nested list, or tree. 

(8-Jul-1999) Idea: have TclCmd's be able to return doc strings; then
TclCmd or TclPkg would store a list of all registered commands, so
that a special help command (like '?') followed by a command name
could return its help string. This would be nice since the various
intermediate command classes could provide default
doc-strings. Subclasses could either append, or override, their
superclass's doc-string.

(5-Jul-1999) To trash or not to trash GfxAttribs? It's functionality
is superfluous at the moment, since all the information it provides is
available in ToglConfig, but switching dependencies from GfxAttribs to
ToglConfig will tend to introduce coupling as well as recompiling,
since ToglConfig is probably more volatile than GfxAttribs... 
Something to think about.

(5-Jul-1999) I could improve the efficiency of id-list manipulations
in Tcl by adding a new Tcl object type that stored an STL vector or
list as its internal rep. Then there would be no translations between
Tcl lists and STL vectors/sequences required... Also I could make a
Tcl_ObjType for the ids themselves, where the internal rep is a
PtrList::iterator, and the Obj is able to provide an Item* from the
list when asked. But... how to avoid having to put functions for this
stuff all in the TclCmd base class? Maybe TclCmd subclasses could add
the necessary functionality through getVectorFromArg, getGrObjFromArg,
etc. Probably I would want to wrap up Tcl_Obj in a C++ class TclObj
before doing any of this... this would actually be a great chance to
use reference-counted proxy semantics... the C++ class would be a
proxy for the Tcl_Obj, so the TclObj objects could be passed around by
value if their constructors called Tcl_IncrRefCount and the
destructors called Tcl_DecrRefCount (but how likely is aCC to ensure
that all the destructors are called in the face of
exceptions?). ... Hold on, maybe this is all too much-- it's pretty
complicated, since Tcl_ObjType is like a metaclass (the class of a
class), and Tcl_Obj is like a polymorphic class.

(3-Jul-1999) Tlist makeSingles, etc. could now take a sequence/list of
objids as an optional argument utilizing TclCmd::getSequenceFromArg.

(3-Jul-1999) Maybe PtrList<T>::iterator should return a pair<int, T*>?
This makes PtrList look suspiciously like a map... which I guess is
really how I am using it. The ids are just used as tags... I'm just
wary of using an STL map for implementation since they tend to be
quite sluggish... wish I had a hash_map. At least PtrList's interface
is reasonably well encapsulated so I could try new implementations. I
guess I could even try an implementation using Tcl's hash map
API... Trying the Tcl_HashMap implementation now. Maybe need to
provide two kinds of iterators: one for fast but non-sequential access
using Tcl_HashSearch, and one for slower but sequential (sorted)
access through the keys. ... OK, I see now that the idea of the
elements being ordered sequentially *was* an important part of the
interface provided by the old implementation (I think), so for now
I'll stick with the old implementation.

(3-Jul-1999) Need to correctly handle widget destruction within the
ObjTogl package. The problem is that if a new Togl widget is created
and then destroyed, the "offical" Togl widget (the singleton) is no
longer the current glX rendering context... perhaps there should be a
line in both the create and destroy callbacks that resets the
"official" widget as the glX-current context.

(1-Jul-1999) Time to get back to testing...........................
OK, I have a bit more flexible framework for testing now; each Tcl
package gets its own XXX_test.tcl file, and all of these files are
sourced in the main grshtest.tcl file. The idea, though, is that any
of the individual test files should be able to stand on its own-- it
should acquire and release any resources that it might need
locally. Now that I have generic TclCmd's etc. working, it would be
nice to make the testing process a little generic as well, such that
tests that are repeatedly testing the same C++ code (such as the arg
check for a TVecAttribCmd, for example) can be a bit more automated.

[Earlier] I squashed a bug that was basically a result of having
written less-than-accurate function names. ExptDriver::stopTime was
used to cancel all timer callbacks, but it also aborted the current
trial, which is not necessarily implied by its name. Aborting the
trial in the middle of ExptDriver::handleResponse then had a
disastrous effect. Better rename these functions quick. Also, there
should have been a test in place to identify this bug... better write
those ExptDriver tests quick.

-- Add tests to grshtest.tcl for CloneFace. Need mainly to check
various permutations of loadFaces.

(30-Jun-1999) How to late-bind error strings and other string
literals? Put them in a separate compilation unit, register them
through id's... it's no fun to have to recompile everything just to
change one lousy string literal.

(25-Jun-1999) Just realized how dynamic loading should work for grsh:
all of the lists, plus all of the base classes that are held by the
lists, need to be statically (or at least permanently dynamically-)
linked into the grsh executable. These would be the so-called 'core'
modules. Any of the separate Tcl packages should contain the subclass
(such as Face) and the TclPkg to work with that subclass (such as
FaceTcl)... these units can then be loaded with the Tcl "load"
command, and would be called 'extensions'. Dependencies between any of
the extensions should be avoided. This hierarchy urges strongly for
all the base classes handled on the lists to be abstract. The problem
right now is the issue with bus ergrors due to OpenGL calls from
dynamically-linked modules--most of the 'extensions' will use OpenGL,
so this probably makes them unable to be dynamically loaded.

(30-Jun-1999) Still might want to split IoMgr into separate
categories?

(30-Jun-1999) Really need to get an iterator working for
PtrList's... and get rid of these pseudo-working Id's. OK, now have an
iterator class implemented, but how to construct them? Specifically,
I'll need to be able to construct iterators from int id's, but then
what to do if the int is an invalid index? Throw an exception? Leave
the iterator in a corrupted state? Also, basically all of the PtrList
operations should use iterators... addPtr() should return an iterator,
remove() should take an iterator.

(27-Jun-1999) Maybe Response's want to be first class objects rather
than lowly int's? This would allow the class to have a static member
InvalidResponse... would allow subclassing of responses... would allow
different ResponseHandler's to work with different Response
subclasses... Interestingly, the creation of a Response requires input
from both ResponseHandler (for the semantic value) and from the
TimingHandler (for the response time) --> trying to implement Response
would probably raise some important design issues. Actually, I think I
do have a simple Response struct that is just local to Trial's right
now.

(28-Jun-1999) Idea: callbacks can be set up from Tcl by storing a Tcl
script as a string in C++ than can be set through the Tcl
interface. This basically allows run-time modification of code...

(28-Jun-1999) Need way for TclCmd's to "own" TclEvalCmd's, so that the
Tcl_Interp* management can be hidden from the client.

(28-Jun-1999) Need Stopwatch class to handle all this timing stuff
that needs to go on.

(27-Jun-1999) could perhaps use TclCmd again in KbdResponseHandler to
wrap up the event binding... this would allow for exceptions during
the event handling.

(24-Jun-1999) Would be nice to define some sort of appropriate
inheritance semantics for CTclPkg's... so that CTclPkg<B> can inherit
from CTclPkg<A> iff B inherits from A, and furthermore that this
inheritance does "all the right things".

(22-Jun-1999) Ugh. Spent all day tracking down idiotic pointer
problems. Should really use vector<unsigned char> rather than C-style
arrays to hold the info in Bitmap's and Pbm's, and use checked access
through at() especially when algorithms are untested.

(21-Jun-1999) Would be nice to arrange things so that GL coordinates
correspond to degrees of visual angle... really nice.

(26-Jun-1999) OpenGL crash problems raise issue of who should really
be allowed to call OpenGL? Best to keep all graphics calls as
localized as possible... this still needs some work.

(19-Jun-1999) Big Bug #2. There seems to be a problem with exceptions:
in TclCmd::getDoubleFromArg, when an exception is thrown, the Trace
object is not properly destructed... maybe this is underneath the
problems that have popped up with exceptions elsewhere?

(17-Jun-1999) Looks like TlistTcl could also use some de-bloating via
conversion to TclCmd/TclPkg. --> This is under way: TlistPkg now
implements the TcllListPkg interface, so stringify, destringify,
reset, and count are now handled automagically. Actually most of the
bloat in TlistTcl is due to the creational functions makeSingles, etc
that really belong elsewhere (where?) Should all this creational code
go toether in one area, or does Tlist need a separate creational
packaged from Expt, for example?

(15-Jun-1999) Clean up some old Tcl package files by converting them
to TclCmd/TclPkg format. ... in progress ... I'll skip misctcl,
tcldlist. But still need to do subjecttcl.

(15-Jun-1999) Bitmaps need to have attribs for glPixelZoom() and other
operations that can affect pixel rendering... should these be placed
in a separate Position subclass?

(24-Jun-1999) Now that we have a standard location for catching
run-time errors in TclCmd, I should be able to remove many catch
blocks from within current TclCmd's, particularly those doing
I/O. Also, IoError probably no longer needs the semantics of adding
its own type to the beginning of the error message; this could be done
instead in the TclCmd's catch block.

() Need to make major modifications to prepare for fMRI work.
--need to make different types of trials, mainly varying according to
how they collect responses, if at all, and how they give
feedback. Most of this stuff could be wrapped in ResponseHandler and
TimingHandler objects; it's just a matter of moving those from
ExptDriver into Trial's. How to do a FeedbackPolicy within C++ rather
than from Tcl?
--Order dependency should be removed from serialize/deserialize
methods: members should be requested by name. Need capability for
versioning in serialize/deserialize.
--need to look seriously at some industrial-strength creational
patterns: I've got a lot of functionality implemented, but it the
various objects need to be able to be assembled in the right
ways. E.g., set the TimingHandler for a whole bunch of Trial's, vary
one parameter along a set of Trial's, etc. Most of this will probably
be helped by having some good iterators for PtrList's.

() :) :) :) Would be _really_ nice to have a file translator in Matlab
that could read the Expt files...

() What should the requirements be on reading in to a Trial by ObjId's
only? Should we require that the proper ObjId's already exist, or do
we assume they will be created later? Right now we assume they will be
created later, and do not check for their validity as they are read in.

() There are dependencies in tlisttcl.cc on GrObj and Position that
are due to the Creational functions that are present in that file, such
as MakeSummaryTrial, MakeSingles, etc... These are the things that
should be solved with a Creational design pattern such as Abstract
Factory or Builder.

() Want a nice way to manage creation of ExptDrivers, but which
pattern to use? Abstract Factory or Builder?  The final ExptDriver
needs to be composed of many different parts, each of which can be
created in several possible ways, and there are some order
dependencies in the creation of these sub-objects.

() ObjId's and PosId's need a way to iterate over their list's while
skipping NULL's.

() Would like to change event binding from eval'ing Tk's "bind"
command to using the API function Tk_CreateEventHandler. But there is
a problem with multiple possible matches to a single event -- whereas
"bind" calls the most specific binding, who knows what happens with
event handlers???

() Buggy behavior: if Expt::begin is called on an empty experiment,
the message "expt is complete" comes up but the Expt keeps on running
empty trials, then aborting them.

() Damn. another bug -- if a GrObj is changed while it is onscreen, it
cannot be properly undrawn since its old state is not remembered...

() An idea for a more generic way to describe Trial's: rather than
explicitly storing objid/posid pairs, Trial's could store sequences of
events (this overlaps my previous idea about using events to describe
trial timing). One particular *type* of event then could be
DisplayObjectAtPosition (or something less wordy). This event would
store the objid and posid (or maybe GrObj* and Position*) and would
know how to display itself. The events would have in common an
action() function or something similar. Problem: who stores the
references to ObjList and PosList that make posid's and objid's work?
Currently it is Trial's, but with this new scheme there would have to
be one for each DisplayObjectAtPosition event, and with several of
these per Trial, and perhaps thousands of Trials in an Expt, this
means many thousands of references, all of which are pointing at just
one or two ObjList's/PosList's. This seems somewhat excessive. What to
do ...? [Later] This latter problem has been solved by making ObjList
and PosList singletons.

() Observer/Notifier -- need to change private variable access
to accessor function. This provides an easy hook for notify. Further
it hides the distinction between a variable and a computation.

figure way for ObjList and PosList to notify Trials or Tlist when
GrObj or Position is deleted. Then Trial should remove that (objid,
posid) pair from its list. Possibility: have GrObj and Position
implement a Notifier interface, where clients subscribe to the object,
then the object has a notify() procedure that sends a message to each
of its clients. Contents of message might be "I've changed" or "I'm
destructed". Or... have ObjList control the notification since Trials
only know about objids and posids. PtrList could maintain an array of
info that is parallel to the stored pointers. This array could contain
sets of clients for each id. Have to think carefully about how this
structure could be maintained through serialization.

Or... do pseudo-smart pointer stuff within PtrList. Whenever some
client is going to hold on to an id within the PtrList, it must "check
out" the id. This would increment a reference count within the
PtrList. Ptr's with a non-zero ref count are not allowed to be
delete'd or overwritten. This is I guess just a simpler version of
maintaining a list of clients--it doesn't allow for any messages to be
sent back to the clients.

On third thought, this is a deep design issue. The question is, who
owns the GrObj's and Position's? Who can delete them?


() Add functionality to Tlist to extract statistics from the
experiment. Add functionality to Trial's to extract statistics from
themselves. Question: how to deal with the issue of whether to lump
two Trial's together? Such as mirror-image pairs? Also, how to
implement the statistical algorithms in a generic way? Would be nice
to have iterators over Trial's (where each val is a response, or a
response_time) and over Tlist's (where each val is a Trial). Then
could use functors to be applied to each object and extract some info
from each.

() add "login" for subjects to make sure directory is correct

() Implement GLenums with something other than STL maps. Probably
best to use Tcl_Index API's, to search for matching string in array,
and retrieve its index.

() Trial's should hold more info-- in particular, they should know
their own correct response, or at least have a virtual function to
determine if a particular response is correct/valid or not. The
derived classes could be "BinaryTrial", "AnalogTrial", etc. This would
avoid having to implement the feedback/correctness check at a high
level. Also, Trial's might know their own timing info, although they
may not necessarily implement the timing themselves.

() Maybe Position should be migrated to an abstract base class, with
the current Position class becoming StaticPosition or
FixedPosition. What would a Position subclass for moving objects look
like?

() make startup procedures figure out if X server is available

*** BACK ***

*********************************
***                           ***
*** BOTTOM of completed stack ***
***                           ***
*********************************

need to have a way to initialize the appropriate data structures for
an experiment (probably ObjList, Glist, and RealExpt) from Tcl, based
on a simple file description of the experiment

would like to avoid having to manipulate/store Tcl data structures,
preferring C++ STL structures instead

who should own the ObjList, Glist, Expt data structures? when do they
come into existence?

problem: don't want to have to have default constructors for ObjList +
Glist, yet they are necessary for ToglConfig and togl widgets
shouldn't be dependent on having a valid glist constructed already

solution? hold references to pointers in the relevant locations, so
that the actual objects can come in and out of existence as necessary

--> problem with this is that this requires constant testing for null
pointers to see if the objects actually exist



problem: it should be easy to do something simple, like create one
face and display it

solution? some derived class of Expt or Glist could manage these
special situations


what are necessary steps to start experiment?
1) create GrObj's (Faces) and ObjList, knowing the size of the groups
in Glist (how?)-- this requires some temporary data structure to store
the ids of the objects in the different locations

... createObjs function returns a vector of objids giving the objids
for the list of objects that were specified

... would like to be able to have a way to create a set of GrObj's
that it is independent of their exact type, yet that involves a
straightforward file format (maybe give each type a constructor that
takes a string, which in turn contains the obj-specific parameters?)

... how is the number of objects in each group determined? more
fundamental problem: how are the groups stored-- in terms of face
class id (as in STIMDG(groups)) or in terms of actual objid's, where
the objid depends on the position in the group. Is there a way to
avoid having to store both forms of information?

2) create Glist (list of stimulus groups) from input file, or from
(???) that describes special ways to initialize (all pairs, or all
triads...)

3) create an Expt object based on Glist and on the number of repeats


radical idea??? have multiple ObjList's, one for each position in
which a GrObj will be displayed?


solution to big problem??? have Glist own an/the ObjList, so that they
are constructed at the same time, from two files; maybe the Glist is
also owned by the Expt object



**********
Friday, 5 Mar 1999

started moving the stimdg implementation out of Tcl

first goal: remove direct access to Tcl array fields by providing
interface in class Stimdg. Stimdg's are currently initialized with a
Tcl_Interp and a Tcl_Obj holding the name of a Tcl array that has the
relevant fields. But, no one should directly access those
fields. Eventually, a global Stimdg object will be used, whose
implementation can then be something other than a Tcl array.

next steps:
1) must port remaining Tcl files to C++
init_stimdg.tcl : this will eventually become the Stimdg constructor

load_face_data.tcl : straightforward, must read file data into the NL,
MH, etc. fields of the Tcl array

trial.tcl (mostly done) : just need to write recordResponse

parse_stimdg.tcl : actually doesn't need to be ported, since it
doesn't require a Stimdg structure in particular

2) develop some token other than an array name to be passed to C++
from a Tcl script -- this is the final modification necessary for the
encapsulation into C++

***********
Saturday, 6 Mar 1999

1) ported replace_response to C++. This requires using
Tcl_ListObjReplace to exchange the curstim'th element in the remaining
and responses fields. However, the function prototype in the man page
is a little misleading, since the prototype itself shows the range of
indices into the list specified by 'first, count', but the argument
declaration list shows the indices as 'first, last'. Turns out 'first,
count' is correct, but this seems redundant with the objc... aha! you
don't necessarily have to replace a range with the same number of
elements that were there before; thus both 'count' and 'objc'.

2) ported init_stimdg to C++, splitting into a Tcl Cmd proc
init_stimg, which in turn calls the Stimdg member function init (which
should later be moved into a constructor). But ugh; still have to port
the init_triad_stimdg and init_pair_stimdg procedures.

3) had an awful time porting load_face_data to C++. Problem was the
procedure that tried to append an element to one of Stimdg's fields,
by way of Tcl_ListAppendElement. If the field didn't exist before,
there wasn't a problem creating it when it was asked for; however, it
didn't behave very nicely as a list, generating some error about not
converting a string to type. (?) So, had to create an 'initFaceFields'
procedure for Stimdg to first create all of the related fields before
calling the append procedures.

4) ugh. trying to port write_array and read_array to C++. Getting that
same error message:

UpdateStringProc should not be invoked for type 
IOT trap

This time my problem was I was trying to call Tcl_GetsObj to read into
an object from the file, but I was trying to read into a null pointer,
rather than an object that had been initialized with
Tcl_NewObj(). Dumb mistake, but still, the error message could
certainly have been more helpful. 

Also, I can't make read_array work the way I want using C++ strings,
file streams, and string streams, since this lame implementation on
the HP's can't do a getline into a C++ string.

5) There is now one global Stimdg in the StimdgTcl namespace that is
created at startup in Stimdg_Init. This means that the dg_name
arguments being passed to stimdg Tcl functions are just dummy
arguments at the present time; the global Stimdg is always used. 

Should the Tcl array that implements the Stimdg be isolated by putting
it in its own Tcl_Interp? Would this prevent access to the other Tcl
commands that are necessary in the implementation? Duh--no, it
wouldn't since the CmdProc's can be called from C just like any other
function--it's only in Tcl that they must be registered with the
running Tcl_Interp. 

6) There. I made Stimdg use its own Tcl_Interp separate from the one
running the interactive Tcl application.


************
7-8 Mar 1999

Ugh. Very late last night, and today, I implemented a *much* improved
version of the functionality necessary to control an experiment,
through the interface class Expt, and the concrete class
RealExpt. Unfortunately, I also tossed out completely the ~1000 line
of code I had written for Stimdg and StimdgTcl. But, I think things
are much better off now. I realized that there was too much
duplication of data between Stimdg and the other data structures such
as Glist and ObjList and the various GrObj's. Instead of duplicating
data, the Expt class merely provides an interface to the other data
structures, and allows everything to be written to and read from a
single file. As another bonus, this implementation is even more
efficient-- now takes only ~0.84u to start up a triad experiment.

A few loose ends:

1) need to make the object specification truly polymorphic. Who should
control when and where the type strings get written to files? Want to
be able to read files both ways:
		  a) assuming a fixed type all the way through
		  b) polymorphic--determine the type one line/obj at a time

2) need another c'tor or two to be able to generate the different
types of experiments such as pairs and singles--just have to pass
these options to the Glist constructor

NOTE: must change makePairs, makeTriads, so that the objid's take into
account their position in the group

3) need to use symbolic constant to determine how StimClass is set


*************
10 Mar 1999

Things are mostly nice now, but, as always, I have many possible
revisions in mind.

1) There are too many 'little fixes' that I have to keep on
remembering to apply in new code. For example:
	
	- Glist stores objid's-- indexes into ObjList, which do not 
	necessarily reflect the object 'type', since the same 'type'
	of Face, say, may be created at multiple locations, giving
	multiple objid's. In order to check if two objects are the
	'same', I have to adjust for this factor. This is sure to lead
	to trouble at some point

	- within RealExpt, there is a discrepancy between trial type (an
	index into Glist) and trial number (which reflects how many times a
	type is repeated). This also requires many conversions back and
	forth, sure to cause eventual problems.


2) Perhaps I am missing some underlying datatypes that are really
needed, such as Trial, Position, etc. Then 

3) Ugh. Too much of this design has been designed for the sake of
Tcl. I'm starting not to like that language much.

4) Gee, now I have a really nice design for Trials that I should have
switched to months ago. I guess this is what they mean by "be prepared
to throw your first draft (or four) away". 

Wait--Trials should hold id's, not pointers to, GrObjs and
Scaleables. This will make things much easier when we have to
serialize-- in fact, an Expt is starting to look quite nice:

class Expt {
	vec<Trial *> itsTrials; // each is unique
	vec<int> itsTrialList; // randomly ordered list of indexes into itsTrials
	                       // (may contain repeats)

	int itsCurstim;        // index into itsTrialList
	void beginNextTrial();
	void recordResponse(int resp);
	int lastResponse() { 
	  return itsTrials[itsTrialList[itsCurstim-1]]->lastResponse();
	}
}

To achieve better backward compatibility with Glist functionality
(which must interact with ToglConfig), perhaps define Tlist class,
which can exist outside an Expt, but which is controlled by the Expt
while the Expt is in progress.

The only duplication of data here would be Curstim (and
Tlist::itsCurTrial). During an expt these would normally line up, but
Tlist::itsCurTrial could be controlled independently from Tcl.


5) Back to the concrete (i.e. currently existing) software. Grsh
crashed in the 'train' experiment, using repeat of 1, after all 10
trials were completed, and I entered a response anyway. This points
out that we need a good way to know when the experiment is over.

************
11 Mar 1999

1) started using RCS via Emacs' vc utilities. I hope this will reduce
some of the confusion surrounding versions.

****************
13 Mar 1999

1) had very good progress implementing Position, PosList, Trial,
TrialExpt. Spent a lot of time on the serialization/deserialization
functions. This new design is far superior to the old plan--it's
really nice to have the GrObj separated from the Position objects, to
be able to be controlled independently. This fact greatly simplifies
the process of reading and writing expt files.

2) What is left?

* implement functions to read into a TrialExpt from simpler file
formats (such as nos_faces_sel and tr_nossel)

* reimplement the expttcl package for TrialExpt instead of
* RealExpt. Fortunately, except for the constructors this won't be too
* much work since both classes implement the Expt interface. (A real
* instance of OO design at work!)

* figure out a more elegant way to do STL input and output. I can use
* ostream_iterators and istream_iterators, but I'm not too familiar
* with them at this point, and most importantly I'd like to be able to
* control the spacing of the container elements in the output file.

* implement derived classes from Trial to get the right trialType()
* for singles, pairs, triads, etc.

* think about a really robust way to do the file formatting. Perhaps
* some file format descriptor classes?

* some rigorous testing/debugging. Need to add in Assert() statements
* throughout old code, and design Tcl packages to allow for easy testing.

**************
14 Mar 1999

1) need a good way to enforce proper order of initialization of Tcl
packages, such as ObjlistTcl, PoslistTcl, TlistTcl, and
ExptTcl. Actually, the problem is the use of the pointers. Maybe I
don't even need the pointers anymore, since most of the objects don't
ever need to be deleted--they can be adjusted at will using member
functions. In fact, I think the only object that might need to be
reallocated is TrialExpt, and this is at the highest level so
everything is peachy. Still it would be nice to know why
Tcl_PkgRequire isn't working.

2) Don't need to have derived classes of Trial. Instead, should
provide some (non-member) utility functions to go through and set the
types appropriately. Such as findside(const Trial&).


***************
15 Mar 1999

my stack:

-> make ObjlistTcl::theObjList a static object, not a pointer, since
no one ever needs to delete it. same for Poslist.
move the makeTriads, makePairs etc. to Tlist instead of TlistTcl

(done) add test_objects to Makefile that includes test versions of each of
the object modules. These should be compiled with appropriate macros
defined, such as LOCAL_PROF, INVARIANT, LOCAL_ASSERT, etc. Need to
macroize Makefile so that debugging object dependencies are generated
automatically.

(done) Need better way to clear screen in between Trials. glClear is
responsible most of the graphics time. Could either clear a bounding
region, or redraw the Trial with foreground/background swapped. The
latter is easy, except Jitter's don't currently know how to re-do
their previous operation.

(nix) Try implementing GrObj's with stored pixmaps rather than direct
rendering to see if display speed is improved. --> This would probably
interact poorly with Position's. e.g. rotating...

(done) Implement reaction time measurements directly in Expt class rather
than through Tcl.

(done) Add auto save to expt.tcl--save the experiment in a temp file every
100 trials or so.

(done) Add ioTag() method to classes to return whatever name they want to
use as their official typename in serialize/deserialize. This is
better than using typeid(class).name() since this may not be portable
across systems. Also, using ioTag() avoids having to rewrite
typeid... all the time, and minimizes the chance of mucking things up.

(done) Bug: with "pause"--if pause is hit immediately after a
previous pause is released, there is a problem with overlapping faces
being displayed. Fix --> hold an id for the resume timer, so that the
resume can be cancelled if the experiment is re-paused again before
the timer would go into effect. OK, that was a problem, but the real
problem was: Tlist's visibility was not being set to false when trials
were undrawn; thus when the pause window was destroyed, part of the
Togl widget was revealed, invoking a redraw callback, invoking
drawCurTrial(), which redrew the trial that had been undrawn before
the pause. Fix --> Tlist's visibility is now set to false whenever a
trial is undrawn.

(done) move Tcl scripts for Expt:: proc's to C++. ... Everything is
ported to C++ now, but there are still a fair number of Tcl_Eval
call's, so there is still a bit more work to be done.

(note) The problem with the current design(?)/implementation is that
most of the Hard Work is still going on inside the expttcl.cc
implementation (of course it didn't appear that way when it was
implemented in Tcl-- this is why I'm afraid that Tcl can be conducive
to poor designs -- it promotes the use of C++ classes as just
data-holders that expose everything publicly to Tcl). The goal now is
to distribute that work amongst the other objects in the system. I
don't really need to create any new major types; it's just a matter of
getting each of the existing types to take on a little more
work. ...this also means that I'll have to be using some Tcl API's in
the implementation (but not the interface, hopefully) of the
components that were previously isolated from Tcl. But I think this is
not a problem, since the use of Tcl in the implementation is not done
in a way that provides access from Tcl scripts. Actually, Tcl should
only have to be used to implement Expt, which it is practically doing
now anyway in the guise of the ExptTcl package.

(done) Need to store *all* exp't variables somewhere, probably in Expt
class, so that they can be serialized. Get rid of the -global- data in
ExptTcl such as inter_trial_interval, autosave file, etc. Change to
functions in Expt class, and accessor/manipulator functions in
Tcl. OK, moved most things into experiment class-- some will still
need to be moved down further to the Trial level eventually. Much old
ExptTcl functionality is now encapsulated in ExptDriver class -- a
temporary solution (?) until things are rolled back into Expt...

(done) Add virtual method to IO for classes to say how many chars they
need to write themselves. --> Done. Need to test it as part of
generalizing the IO system.

(done 27-May-1999) I'm seeing that PtrList is really used more as an
object database than as an ordinary collection. This seems to cement
the idea that ObjList and PosList should be bonafide singletons,
rather than the pseudo-singletons that are provided now via ObjlistTcl
and PoslistTcl namespaces. Good.  ==> Done. ObjList and PosList are
singletons.

(note) I see... the real advantage of changing ObjList and PosList to
singleton classes is that I no longer need to store references to them
all over the place; instead, classes can just include the headers and
then access the singleton instance.

(done) The ObjId class should contain 1) an int index, and 2) a
reference to its ObjList.  !! Scratch #2-- ObjList is now a singleton,
so we don't need to worry about it! Thus there is no space overhead in
making ObjId a dedicated class. Goal: clients should not have to know
about ObjList + PosList; instead they only know about ObjId and
PosId. Should ObjId's be flyweight objects? This would make keeping
reference counts easy. Should ObjId's act like pointers to GrObj's, or
like pointers to pointers to GrObj's (as a typical iterator)?

(done) TrialTiming -- generic trial/experiment description.
Ding, ding, ding! Bells are ringing. Need a new structure, called
TrialTiming, or EventSequence, or some such, that holds information
about stimulus display time, trial timeout time, inter trial time,
etc. Then each Trial can hold a pointer to a TrialTiming, and the
TrialTiming's can be held in a list. (Maybe I can reuse
PtrList???). Let me just try to scratch some ideas down quickly. Need
to think carefully about the name for this thing-a-ma-jobber. --> This
is done, but right now TimingHandler is attached to ExptDriver,
eventually it should be migrated to be held by Trial.

(done 27-May-1999) I'm still stuck on how to interpret the role of the
ObjList and PosList classes. These are not supposed to be playing a
huge role... they're just a way to identify objects with an objid
rather than with a memory address, which facilitates manipulating them
in Tcl as well as reading/writing them from file. Maybe what needs to
be a first class object is the "objid" or "posid", or some kind of
iterator... The iterator should skip over NULL sites in the
list/vector, and it should match end() when there are only NULL sites
remaining. The outer appearance of ObjList and PosList is that they
are associative arrays between int's (objid's?) and GrObj*'s, but
internally they are implemented with a vector for more efficient
access times than with a map. --> Implemented ObjId and PosId classes
(although they still need better iteration).

(done 9-Jun-1999) Same thing with Tlist [should it be a singleton] ???
Ah-hah!  Tlist is different -- it's more like a Block in an Expt,
because an Expt should conceivable be able to have several blocks. So
a Tlist is a more typical container. (Later) No... the first thing was
correct: Tlist *should* be a singleton. Trial's are an
application-global resource. It is "Expt"'s (to be renamed Block's)
that might exist in multiples.

(done 13-Jun-1999) Need to find some way for reuse in the Tcl
packages. There's just too much copy-and-past going on here. Need to
think about ways to encapsulate the functioning of a Tcl command in a
template or abstract base class, that can be parameterized by certain
things like object count, return type, type of list used, etc...
--how to control the proliferation of Tcl packages needed to wrap each
class that comes up? Or at least simplify these files... maybe with a
generic way to get/set attributes.  --Cool! I've implemented the
TclObjCommand class. This does all sorts of fun stuff. Now I just have
to *use* it everywhere!

(done 13-Jun-1999) Damn. How can we serialize/deserialize
ResponseHandler's and TimingHandler's when they require an ExptDriver
reference? Maybe the RhList and ThList can store the references that
they need? No, this only postpones the problem. It'd be nice to have
the ExptDriver be a global resource, but it in turn requires a
Tcl_Interp*, so it can't be initialized until Expt_Init is called. I
guess I could just give up on multi-interpreter capability, create a
global ExptDriver first with its Tcl_Interp* set to NULL, then
initialize its Tcl_Interp* when Expt_Init is called. Or... could
switch from ExptDriver& to ExptDriver*, but this loses some
saftey. --> OK, ExptDriver has now (like just about everything
else...) become a singleton. However, its Tcl_Interp* is not set until
the Expt package is initialized. This way, ResponseHandler's and
TimingHandler's can get a reference to theExptDriver. Also,
ResponseHandler's no longer depend on ExptDriver for their
Tcl_Interp*; instead, theRhList contains a Tcl_Interp*, and ensures
that any ResponseHandler's added to theRhList have their Tcl_Interp*
set correctly. In addition, any ResponseHandler's that are on
theRhList when the Rh package is initialized will have their
Tcl_Interp*'s set correctly.

(done 13-Jun-1999) Need to write Tcl packages for RHList, THList, and
BlockList. Ugh. --> Actually, not 'ugh' ! I've implemented a TclPkg
class, which controls and contains TclCmd's. I've subclassed this with
TclListPkg, which contains the common xxList TclCmd's, and arranges
for them to forward their operations to virtual functions in
TclListPkg. This way, the RhList, ThList, etc. packages are very easy
to implement: just sublcass TclListPkg, override a few operations, and
presto-change-o you're done!

(done 13-Jun-1999) This is low down on the list, but would be
intersting... Generate an object-based C++ wrapper for the Tcl C
API's. This would be something as straightforward as possible-- not
trying to change the *design* of the API, but just making things more
C++-friendly. Could start off by wrapping up the Tcl_Interp and
Tcl_Obj classes, then add member functions as I need them. --> I think
I'm well on the way to accomplishing this sort of thing with the
recently-added TclCmd's and TclPkg's... these hide most of the
low-level Tcl API calls and provided simpler/shorter ways to
accomplish the common things, but in general don't prevent low-level
calls from being mixed in as well.

(done 13-Jun-1999) Try Tcl packages as static instances of classes
declared within Tcl_AppInit. --> This requires more code in the pkg.h
files (such as the package class declaration). OK? maybe, but I need a
while for the ramifications of this to simmer. This may be too far out
of line with Tcl coding standards... --> No: the way to do this is the
way I've accomplished it now with TclPkg's. The package is defined as
a sublcass of TclPkg, and the Pkg_Init function simply calls 'new
PkgName(interp)'. (This does not call a memory leak since TclPkg sets
up an exit handler to delete itself when Tcl is exited). This way we
can do Tcl packages as classes, yet still conform to the method of
calling the Pkg_Init functions from the AppInit.cc file.

(nix 13-Jun-1999) fix the object hierarchy so that Expt contains Tlist
by value, which contains ObjList and PosList by value ... is this a
good idea?  It seems to break some aspects of encapsulation, since it
requires ObjList/PosList declarations to be visible wherever Tlist is
used. Maybe can get around this with containment by reference, but
also ownership. Or containment by * const. Yes, this would work. Never
mind, it wouldn't make sense, since still clients of ObjList would
have to have Tlist and Expt visible in order to retrieve the current
ObjList. That is the real problem. No...... the real problem is---
Expt, Tlist, ObjList, PosList, etc... should all be top level
objects. But Expt needs to use Tlist, etc., so maybe these all should
be contained in a higher level object-- TheApp??? This could serve up
the current Expt, ObjList, etc. ---> [Later] This has taken care of
itself by way of most of these classes becoming singletons. Perhaps I
will still add a top-level class which is in charge of serializing all
of the singleton's, but this isn't too great of an issue.

(done 13-Jun-1999) Implement multiple deserialize protocols so that
old objects can be deserialized. Just need to add some sort of version
byte/code in the file to map to the appropriate deserialize
function. --> OK, I've implemented this for Face, but... this is
really more of a mess than it sounds like, since whenever a class
definition changes, not only the current deserialize protocol must
change, but also ALL of the previous supported protocols. This is a
true mess if the underlying object representation changes
dramatically. Need to think about this some more... see if I really
want to muck with multiple versions throughout the object hierarchy.

(nix 13-Jun-1999) Error handling.  Get rid of TCL_ERROR as return
status from procedures that handle Tcl, but aren't
Tcl_CmdProc's. Instead, throw TclError(useful_info_string) and then
catch these exceptions in high-level callers-- i.e.,
Tcl_CmdProc's. ---> [Later] The above was all wrong. The correct way:
in asynchronously-called procedures, Tcl errors are raised with
Tcl_Background error. And, in the new TclCmd class hierarchy, errors
are generated by throwing exceptions of class TclError; these are
caught and converted back to a 'return TCL_ERROR' before control
returns to Tcl.

(done 16-Jun-1999) figure out how to make !@#$^& shared libraries
work! [Later -->] Well, they're !@#$^ing working now, but they're
still a pain in the @$$. For some reason, objtogl doesn't like to be
linked in as a shared library, but instead as an ordinary .do file
(although the .do file can be compiled with the +Z option). If it is
linked as a shared library, everything grinds to a halt in
toglDisplayCallback, apparently on the call to glClear()... why is
this? A likely candidate would be the fact that objtogl is the only
package besides grshAppInit that uses <togl.h>, but yet it appears the
crash is occurring on the call to OpenGL... maybe this happens to be
the first call to GL?

(done 16-Jun-1999) Bitmap's are not undrawn in the same way as all
other GrObj's. In particular, it is certainly quicker to clear the
pixels rather than recopy to the framebuffer... This will entail
adding an undraw() operation to GrObj. Done --> basically, use
gluProject to find out in window coordinates where its beginning
raster position falls, then use glScissor to define a rectangle
beginning from this point and having the correct height/width.

(done 16-Jun-1999) Issues with Bitmap's:
--how to get the correct contrast? OK, added a flipContrast command.
--should implement Pbm modes 5 + 6? OK, just 'is.read(itsBytes, itsNumBytes)'
--need to optimize for bitmap operation. OK, done.

(done 16-Jun-1999) Move timing handler Tcl commands from expttcl to
thtcl. --> Done. It was a lot of fun to remove all of those pointless
accessor/manipulator functions from ExptDriver that were just
forwarding to TimingHandler or ResponseHandler.

(16-Jun-1999, done 17-Jun-1999) make a class TclEvalCmd or similar, to
serve as a wrapper for this repeated 'static Tcl_Obj*, static
TclObjLock' junk. --> Done ... but ... could extend this to make
TclEvalCmd's that declare themselves to return given types? Or is that
just too much?

(16-Jun-1999, done 17-Jun-1999) Would like to add declareIntSetter,
declareIntGetter, etc. to TclItemPkg, but first I'm going to have to
figure out how to avoid the proliferation of duplicate code that
occurs for each of the basic types that are supported. Should be able
to do this with templates, but how??? I think it comes down to the
necessity for member templates, which I'm not sure if aCC has... maybe
I should find out! [Later -->] Doh! This is what operator overloading
is for... all I have to do is overload returnVal() for the basic types
in class TclCmd, and then elsewhere in the program I can use templates
on the basic types, which will compile correctly iff the template type
is supported by a returnVal overload in TclCmd. So, now I have a
generic TclGetterCmd template working-- it's templatized on the type
of object to get from, and on the type of value to get. Also just
noticed that it's fairly expensive in compile-time to modify
tclcmd.h--this file is very heavily depended-on.

(note 18-Jun-1999) Got another core dump with a "missing symbol during
dynamic loading". The dynamic linker couldn't find TclError() for a
call inside a function defined inside an unnamed namespace. The
solution (workaround) is to put the function inside a named namespace
and follow with a using namespace directive.

(15-Jun-1999, done 18-Jun-1999) Bitmap serialization: need mainly to
record the filename. Done --> but, do I want to have an option as to
whether to record the graphics filename, or to actually write the
graphics data??? I think no, since writing the graphics data would
hugely bloat all of the expt files that are saved for subjects.

(18-Jun-1999, done 18-Jun-1999) Better find a place to 'catch' the
PbmError's that occur on an invalid filename. OK, Bitmap catches any
PbmError's that occur during loading. Should Bitmap also rethrow an
IoError, perhaps?

(17-Jun-1999, done 18-Jun-1999) Should have declareGetter,
declareSetter, declareAction in TclItemPkg along with
declareAttrib. --> OK, now I have getter/setter working, but still
need to implement declareAction. --> OK, declareAction is done too.

(16-Jun-1999, done 20-Jun-1999) Now that shared libraries are
pseudo-working, it is definitely a worthy goal to try to get Tcl's
'load' command for shared libraries working. However, this will entail
working out the various dependencies between Tcl packages (such as
that of Face on ObjList)-- these will not the same as C++ compile-time
dependencies. ... --> OK, I have this working in principle
now. Package init procedures need to be taken out of namespaces and
put in the global namespace with an 'extern "C"' declaration so that
Tcl is able to find the init procedure from a package name. Then
packages are available via 'load filename', or I can set up a Tcl
config script with a bunch of "package ifneeded"s to specify which
files to load for a filename. Now it's just a matter of working out
the dependencies between files.

(16-Jun-1999, done 20-Jun-1999) Need more generic way to do
getItemFromId() inside TclItemPkg. Would like to allow for this to
work for ExptDriver as well, which doesn't actually require an ID,
since it's a singleton... so we need to specify within TclItemPkg
which Tcl command argument, if any, should be taken to be an item
ID. Also, it would be nice for TclListPkg's to also be able to
declareAttrib, declareSetter, etc. I think this calls for a base
interface that declares and defines the declareAttrib, etc. functions,
but which forwards the retrieving of an item to a virtual function
getItem(). Then in subclasses of this interface, getItem() could be
defined to call getItemFromId(), or in the case of TclListPkg, it
could be defined to just retrieve the list singleton. How to define
the underlying TclCmd's so that they work correctly in all cases?
Right now they all call itsPkg->getItemFromId(). ... --> OK, I have a
sort of hackish way of getting this all working... TclItemPkg takes an
argument specifiying which Tcl command argument contains the item_id;
if this number is 0, then it is assumed that an id is not needed to
retrieve the item, and therefore an id of -1 is passed to the virtual
function getItemFromId. The commands that are created by TclItemPkg
also know how to do the right thing with regard to the presenc/absence
of an item_id argument. Now we should have TclListPkg inherit from
TclItemPkg so that we can add attribs, etc. to lists. ... Actually,
this would hardly be even necessary once I have declareAction working,
because then a ListPkg can just declareAction("reset") and
declareGetter("count") and we can do away with a separate TclListPkg.

(18-Jun-1999, done 20-June-1999) Question: does putting forward class
declarations in a .cc inside an unnamed namespace actually cause the
class definitions to remain locally visible only? --> NO. The way to
do this is to use a named namespace, put forward declarations inside
namespace block, then define the classes out-of-line by using an
explicit namespace qualifier when defining the class; i.e. 'class
mynamespace::my class {};'

(16-Jun-1999, done 20-Jun-1999) Move Block-related commands out of
expttcl and into blocktcl. Along the way, morph expttcl and blocktcl
into TclCmd/AttribCmd/TclPkg-compliant packages. Done. It's nice that
after "blind refactoring" with no specific goal in mind, the
underlying abstractions come out crystal clear--better than I could
have stated on my own a priori. ExptTcl now has exactly the commands
that you'd think it should: begin, stop, pause, read, and
write. (Although autosaveFile is a bit of a wart...)

(21-Jun-1999, done 21-June-1999) I think TimingHandler's really need
to be expressed more generically, in terms of TrialEvent's, whose
timing should be specified either relative to immediate, Trial start,
or response seen. This can all go in a base class; then we can
recreate the interface of the current TimingHandler in a derived
class. --> Done.

(22-Jun-1999, done 22-Jun-1999) Should add a
"mother-of-all-base-classes" base error class from which to derive all
client errors so that TclCmd can catch all errors (somehow catch(...)
is failing to work). ... Done.

(22-Jun-1999) How to improve Bitmap performance ?
-- use glBitmap --> ding, ding, ding, we have a winner! This disallows
using glZoom, though, so I'll have to manually flip the image
vertically. What a pain. Adding a flipVertical command to
Bitmap... this will require a flag to be serialized a la
itsContrastFlip. <-- Done. Got a nice performance boost out of all
this... rendering times for the 280x296 bitmaps were ~500 msec before,
and are now ~85 msec. Not bad for a day's work...

(22-Jun-1999, nix 22-Jun-1999) Maybe can also Bitmap improve
performance by using 4-byte chunks? --> Nope.

(21-Jun-1999, done 22-Jun-1999) Need to migrate base ResponseHandler
and TimingHandler code into abstract base classes, then create
subclasses for the current incarnations, such as KbdResponseHdlr and
BasicTimingHdlr (?). Need to add these classes to the IoMgr
package. Then can also add a NullResponseHdlr (which should do
nothing). Actually, the NullResponseHdlr needs to trivially generate a
response upon beginning the trial, so that no matter what happens with
the trial, it has seen a response and so can be considered complete.

(20-Jun-1999, done 22-Jun-1999) Realized the objType and posType
commands should belong to the GrObj:: and Pos:: namespaces, *not* the
ObjList:: and PosList:: namespaces.

(21-Jun-1999, done 23-Jun-1999) Going to have to go to
double-buffering in order to achieve reliable timing. How to implement
this??? Maybe with a new event type RenderNextTrial. This would
involve adding a flag to Trial (or somewhere else?) to indicate if a
Trial has already been rendered into the other buffer. Then when
Trial::draw is called, it checks the flag, and either renders the
Trial, or swaps the buffers, as appropriate. --> Blah blah
blah. Didn't need any of that fancy stuff. Just added a
SwapBuffersEvent to invoke ExptDriver::edSwapBuffers. Then the timing
handler runs the swap buffers event when appropriate. For the fMRI
experiment, one buffer is always the stim buffer, and one is always
the blank buffer. This is nice since it avoids any expensive screen
clears. The swapping is pretty fast, only about 3 msec for a large
window (1000x1000). Thus there is plenty of time in the 167 msec of
blank time to 1) swap to blank buffer (3.5 msec), 2) undraw the
current trial (4.5 msec), 3) draw the next trial (85 msec), and 4)
swap back to the stim buffer (3.5 msec).

(22-Jun-1999, done 23-Jun-1999) member template instantiation? I guess
I can somewhat get around this problem by defining an inline member
template that calls a private templatized class-static function that
does the actual work. Then that static function can be instantiated
for the basic types. Is this really better than just overloading the
function?  Errors that would have previously been compile-time errors
when the overloaded function is not present now become link-time
errors when the template instantiation is not present. On the flip
side, adding support for a new type involves only changing a .cc file
rather than a .h file. Actually, I can't even use the explicit
instantion syntax to do the instantiation; instead I have make calls
to all of the functions that I want to use--this is done inside a
dummy member function 'instantiate()' that should never actually be
called.

(note 23-Jun-1999) My TclItemPkg's are becoming sort of like
metaclasses, I think... They make the environment more like that of a
"dynamic" language, although there is still strong type checking
through use of templates and limited use of casts.

(23-Jun-1999, done 24-Jun-1999) Make Error subclass that includes a
message, such as ErrorMsg or MsgError. IoError and TclError should
then derive from this intermediate subclass. This allows for a generic
catch clause in TclCmd::dummyInvoke that catches ErrorWithMsg's and
prints their message. Done.

(23-Jun-1999, done 24-Jun-1999) Need some sort of wrapper for OpenGL
calls that seem to crash when they coexist with <tcl.h>. This is a
hack. --> Instead of this, I've just decided to link in any
GL-dependent files statically rather than dynamically... this appears
to get around the problem, which is about the best I can hope for
since I can't seem to actually pinpoint the problem.

(24-Jun-1999, done 24-Jun-1999) Need to make Bitmap::flipVertical work
correctly for 8-bit and 24-bit images. --> OK, I guess I also had to
make it work correctly for 1-bit images. But now it's a lot faster all
around. I didn't know that the images were always aligned so that each
row begins at the start of a byte. This makes flipVertical very easy,
since its just a matter of memcpy'ing a whole row's worth of bytes at
a time from the old location to the new location.

(17-Jun-1999, done 24-Jun-1999) It would be nice to get charCount()
working, even if the estimates are way-over-the-top... this would
avoid having to override getBufSize() functions in packages that make
stringify/destringify commands. ...The Problem is that charCount()
basically has to duplicate the entire logic of serialize(), which may
be very involved and tedious, so duplicating it is also tedious and
error-prone. Maybe it's best to have charCount just give a worst-case
estimate. Actually, there are two reasonable alternatives that I can
see, with opposing benefits: 1) charCount returns a maximum possible
value--this makes the estimation of number of char's very fast, but
probably wastes a lot of space, and 2) charCount actually serializes
its object into a local buffer to determine the exact char count--this
will effectively double the stringification time, but will ensure the
right count and won't waste any space. Question: can these two
strategies be mixed?  Maybe the solution is to get a good template
gCharCount<vector<T> > working, where T is of type IO*. This is a
big-ass pain. Still need to fix TimingHdlr::charCount, but that
requires more freakin' vector serialization... maybe it's time I
derived Vector from vector and IO, hmmm? But for now things are
working well enough that I can remove the getBufSize from
TclIoItemPackage... this was just a hack to get around broken
charCount implementations. Now I have few enough of those that I can
retreat any hacks back into one or two charCount's.

(23-Jun-1999, done 24-Jun-1999) Add way for Getter's/Setter's to
override the default usage string--this allows them to also be used as
generic one-argument functions/value-returning functions.

(done 24-Jun-1999) OK, now I have 6 lists: ObjList, PosList, Tlist,
RHList, THList, and BlockList. Who should serialize these? A toplevel
object, maybe whose purpose is only to read/write. Whoever it is will
have a really lengthy dependency list. OK, for now this can all be
taken care of by ExptDriver.

(19-Jun-1999, workaround 24-Jun-1999) Big Bug #1. Potential problem
with compiler or OpenGL library? Having segmentation fault problems
again in tlisttcl that occur only when the package is dynamically
linked, but not statically linked. This is maybe similar to the
problems with grshAppInit and objtogl, that also didn't like to be
dynamically linked? All three packages use OpenGL, but other packages
using OpenGL aren't crashing... This really odd-- I can work around
the problem by moving the OpenGL code out of a TclCmd virtual invoke()
procedure, either to a Tcl_ObjCmdProc (as it was before), or to a
non-virtual function in Tlist. ? Ugh. Could it be a preprocessor
problem, like the OpenGL header is getting mangled somehow? But this
wouldn't explain why the code *does* work in a Tcl_ObjCmdProc. The
problem does seem to depend on both <GL/gl.h> and <tcl.h> being
included... I wonder if there is any issue with order of
inclusion. None of the packages that use GL but not Tcl (i.e. the
GrObj subclasses, Position subclasses, Trial, Tlist) are having
problems. --> Can't seem to get anywhere... even using the debugger,
things just crash on the calls to OpenGL. For now it's easiest just to
link in statically everything that calls OpenGL.

(23-Jun-1999, done 25-Jun-1999) ExptDriver needs to be able to run
multiple blocks.  --When a block is done, see if there are more
blocks; if so, start the next one, otherwise stop. --> Done

(23-Jun-1999, done 25-Jun-1999) Need a better way to control the end
of trials. In particular, end-of-trial should not be tied to
recordResponse or abortTrial in Expt/Block's. This makes it difficult
to do expt's that have no responses. Making this fix would also
simplify NullResponseHandler (it could actually generate no
response). --> Done.

(21-Jun-1999, done 25-Jun-1999) What are the different ways we'd like
to make Blocks?  --put trialid's in numerical order, for a given range
of trialids.  --put trialid's in a randomized order, for a given range
of trialids.  Done. There are two operations, addTrials(), which puts
a range of ids into the Block in straight order, and shuffle(), which
can optionally be used after addTrials() to randomize the order of the
trialids.

(20-Jun-1999, done 25-Jun-1999) The next step in having good
genericity with TclPkg's is to allow an easy way for client errors to
be transformed into TclError's. Somehow either TclPkg's or TclCmd's
need to be parameterized with an error type... then they can catch
this type. Or... all client error classes could derive from a base
type (perhaps the standard library 'exception'), then TclCmd could
just catch the base class. Done--> added Error and ErrorWithMsg base
types that can be caught be TclCmd. All client errors should derive
from one of these bases, preferably ErrorWithMsg.

(16-Jun-1999, done 25-Jun-1999) In Expt/ExptDriver, do away with
monolithic 'init' command, and make several creational commands, such
as shuffle_init, straight_init, etc., and each command should take a
range of trial_id's as an argument. Done. (or at least started). Now
no longer need init() for ExptDriver, and Expt/Block's have
addTrials() and shuffle().

(note 25-Jun-1999) Perhaps a good way to think about the future of
grsh is to consider what would be necessary to handle other sorts of
experiments... such as dual-task expt's, staircase expt's, motion
expt's. Not that I need to implement the functionality for those, but
do I have the right abstractions in my framework so that it wouldn't
be exceedingly difficult to implement them? Which part of my framework
would handle the new functionality? I think a subclass of Block could
do a staircase. A subclass of Position could probably handle motion,
but this would require constant rescheduling of idle callbacks to
handle the redraws. Dual-task exp't, especially if the tasks appear at
different times, would be tricky. Maybe? Perhaps a subclass of Trial
could handle this, although it would require a bit of trickery on the
part of TimingHdlr's in order to get the Trial to do the right thing.

(25-Jun-1999, done 26-Jun-1999) Stop messing around and just rename
Expt to Block and ExptDriver to Expt, dammit! OK, I renamed Expt to
Block but I think I'll leave ExptDriver as is for now, partly because
renaming ExptDriver to Expt could wreak havoc in my RCS files with the
old expt.h/expt.cc files.

(25-Jun-1999, nix 26-Jun-1999) ExptDriver should be able to do
arbitrary ordering of blocks? Or should it just run through blocks in
sequence... Yes, just in sequence is fine. Just need to create enough
blocks as necessary, then address the individual blocks by id.

(27-Jun-1999, done 27-Jun-1999) Moved the decision to abort a trial
based on response value from ExptDriver back into
ResponseHandler... this makes more sense since this way ExptDriver
doesn't have to care about valid/invalid responses; it just does what
it's told. KbdResponeHdlr now either sends ExptDriver a
processResponse or abortTrial message depending on what keysym it
receives.

(21-Jun-1999, done 27-Jun-1999) Need to remove certain implicit
dependencies that remain in ExptDriver upon KbdResponseHdlr instead of
generic ResponseHandler. Also, there are some icky order dependencies
in ExptDriver relating to who of Block/ResponseHdlr/TimingHdlr is
first to receive certain messages. OK, I think there are no order
dependencies now that I've removed the requirement that every trial
must have a response-- now there are three valid ways for a trial to
end: 1) with a response), 2) with an abort, or 3) with neither a
response or abort. The only tacit dependency remaining on
ResponseHandler is the convention of using -1 for an invalid response;
this is probably fine, but should be stated more explicity
somewhere. (Maybe as a static constant in ResponseHandler?) Yes, I
think that's a good idea. Done.

(25-Jun-1999, done 28-Jun-1999) TclCmd's should be able to get and
return lists. Just need some translators from Tcl list's to C++ STL
lists. --> Easy! Just added set of functions appendVal() to append the
basic types as list elements to the Tcl result, then added a template
function returnSequence() which works with a sequence like the STL
algorithms, by incrementing and using one iterator until it matches
another iterator.

(28-Jun-1999, done 28-Jun-1999) The semantics of loadFaces are a
little bit wacky now... need to dump the first_id argument since it
now does nothing and is unnecessary anyway. --> Done.

(27-Jun-1999, done 28-Jun-1999) I've got some fairly dangerous
overloading in Tlist-- where getTrial may or may not create a new
Trial depending on whether the calling Tlist is const or not. This is
not the kind of think I'd like to have happen implicitly... should
change name of one of the functions. --> OK, changed the const version
of getTrial() to getTrialConst() so at least there are no implicit
catastrophes now.

(25-Jun-1999, done 28-Jun-1999) Must test timing issues. Add stopwatch
to ExptDriver. Add requestedTime to Trials? to Blocks? Then ExptDriver
can check actual time vs. requestedTime and make up the differences
between Trials? between Blocks? --> OK, have a stopwatch in timer now
that clocks each trial. Gee, maybe the TimingHandler should do what it
says? I.e., it should handle time, and therefore be the sole source of
timing info during the expt... if the ExptDriver needs to know the
time, it asks the TimingHandler, and the ExptDriver should feed this
info to Block in order to record the response time. This functionality
must be part of the TimingHdlr base class. OK, added clock to
TimingHdlr, and added public getElapsedMsec function to retrieve the
elapsed time at any point in the Expt. Added clock to ExptDriver to
measure the total time of the Expt.

(25-Jun-1999, done 29-Jun-1999) [Earlier] Who owns the ".togl"
widget. Is it another aspect of ExptDriver?  This is a glaring
outstanding implicit dependency among different files in the
project... again I think this is an unfortunate consequence of Tcl's
'feature' of gluing unrelated code together. The ".togl" is basically
mischievously disguised global data. This is what happens when
variables are untyped, declarations are not required, etc.-- design
flaws can creep in and lurk. [Later] Need to get rid of the ugly
implicit dependency everywhere on the presence of a widget named
".togl". Need to basically make the widget a singleton... 1) ensure
that only one Togl widget can exist at a time, and 2) provide global
accessibility to this widget, either through its Tk pathname, or
through a 'struct Togl*' (or both?)  ... fixed.

(28-Jun-1999, done 29-Jun-1999) Idea: all ObjTogl functionality is
provided in Togl:: namespace in Tcl; no direct calls through widget
command are needed (or allowed; the widget pathname should is private
in theory)... this allows only one widget to be created. OK, I think
there really isn't any way from preventing extra togl widgets from
being created via the 'togl' command, but it is possible to ensure
that only the first widget becomes the priveleged singleton through
the rest of the C++ program. OK, now I've removed all the nasty
dependencies on '.togl' throughout the C++ program, but still need to
convert the Togl procedures over to TclCmd-style.

(29-Jun-1999, done 29-Jun-1999) Need to convert the Togl procedures
over to TclCmd-style. Done.

(16-Jun-1999, done 29-Jun-1999) Would be nice to have a typeless
interface that the from which the lists could inherit their non-typed
commands (such as count(), reset(), getValidIds(), etc.). This way,
generating TclListPkg's would be totally idiot-proof... [Later]
Actually, using templates there is no need for a base
class... templates provide ad-hoc polymorphism, where the types to be
used only have to share member functions with the same signature. This
allows the functions to be non-virtual, giving better performance, at
the expense of run-time polymorphism (which is not needed in this case
anyway). Templates are cool!

(21-Jun-1999, done 29-Jun-1999) What are the different ways we'd like
to make Trials?  --make one Trial per GrObj, with trialid == posid,
for a given range of GrObj's, and using a specified posid. --> This is
exactly done by makeSingles.

(note 30-Jun-1999) OK, so templates are great for code sharing, and
are very expressive, but they aren't so great for rapid development...
code sharing through templates tends to cause lots of recompilation.

(21-Jun-1999, done 30-Jun-1999) Probably need to think about a way to
split up the duties of IoMgr into several smaller factories...
probably need to create factories and then somehow register them with
IoMgr? Let's see... each class hierarchy should have a factory, each
class in the hierarchy should override some function to return a new
instance of it (like newGrObj), and the factory should provide
functions to obtain an object by name. The bindings between names and
creational functions should be able to be generated at run-time (at
initialization). How will this interact with the PtrList's? Currently
they all use IoMgr to create new objects from a stream... if each
object hierarchy has its own factory, then the PtrList's will also
have to be parameterized by a type of factory. Hey this Factory thing
is pretty cool, all because of templates. How to ensure that all types
are registered with a factory before it is used?  IoMgr depends on
static knowledge of all the types it might have to instantiate... this
could be fixed by switching over to a Factor that allows types to
register themselves... the types could all register themselves in the
Tcl package init procedures, but this introduces a somewhat unsightly
dependence between the core of the C++ app (namely the IO factory) and
the specifics of the Tcl app (namely the package init proc's). Well,
actually I guess it's not so bad-- *somebody* is going to have to do
the intializations of the factory, and there is no reason that it
couldn't be someone other than the Tcl init proc's if necessary. OK,
this is all done. But still might want to split IoMgr into separate
categories?

(28-Jun-1999, done 30-Jun-1999) Need algorithm in Bitmap to center
Bitmap's on a point in GL coordinates. --> Done.

(1-Jul-1999, done 1-Jul-1999) Could change GrObj organization so that
subclasses don't have to deal with grNewList, glNewList, etc. Instead,
use the method template pattern so that a GrObj method does the
grNewList etc., then calls a virtual function to do the actual GL
work, then calls grPostUpdated at the end. This would also allow
GrObj's to be toggled between compiled- and direct- mode
rendering. Virtual function should be called grRender(), and
grRecompile becomes the template method. Done.

(25-Jun-1999, done 1-Jul-1999) Need a TextString subclass of
GrObj. This will require fonts--> this will require using
Togl_LoadBitmapFont --> this will require a struct Togl* --> this will
require global access to a Togl* --> this will require making the Togl
widget a singleton somehow. OK, now have global access to Togl
widget... but now, who should control loading/unloading of fonts? Each
TextString certainly doesn't need its own copy of each font... OK,
I've implemented Gtext class. There is only one font loaded at a time
for the entire class; each time time a Gtext is drawn, it checks to
see if the currently loaded font is the one it used last time it
compiled its display list and recompiles itself if necessary before
drawing.

(29-Jun-1999, done 2-Jul-1999) Analogously to TclCmd::returnSequence,
it would be great to be able to extract from a Tcl list arg into an
STL back_inserter iterator. For one thing, this would allow ItemCmd's
to be vectorized, applying the same operations to multiple items at
once. OK, I have the necessary functionality in TclCmd now, but still
need to add the appropriate stuff to TclItemPkg. Need to define some
TclCmd subclasses in the .cc file that handle vectors of
items. Clients will probably create these with something like
declareVecAction, declareVecGetter, declareVecSetter, etc. OK,
actually don't need special declareXXX functions, since I think all
commands can be vectorized by default; there is negligible run-time
cost even in the case when the vector is only one item long, and for
looping, this method is definitely faster (20%?) than doing the
iteration within Tcl. But, how to deal with VecSetter's? Do they set a
bunch of items to one value, or do the set a bunch of items to a bunch
of different values? And if the command takes two lists as input, then
what happens if the lists are not the same size? Clearly, if there are
more values than items we can probably just silently throw away the
extra values. But what if there are more items than values? Maybe the
best thing is to match values one-for-one with items until we run out
of values, then use the last value to set the remaining items. ... Now
why in heck doesn't the compiler want to generate a specialization for
'const string&' of TVecGetterCmd? Should be able to derive TVecAttrib
command from TVecSetterCmd and TVecGetterCmd somehow in order to avoid
duplication. OK, did the multiple inheritance thing. Everything is
working... this is awesome? I have all this cool template stuff and
multiple virtual inheritance going on in the same package... yes,
people are right when they say it's very complicated (MI + templates)
but it's also amazingly expressive.

(2-Jul-1999, done 2-Jul-1999) Now that vectorized commands are
working, we can change the semantics of Block::addTrials so that
rather than taking a first/last id pair, it can just take a sequence
of ids. Actually, the C++ class just needs a function addTrial() that
adds one trial at a time, and BlockTcl::addTrialsCmd can actually do
the iteration through the sequence. OK, added Block::addTrial to C++
class, added BlockTcl::addTrialIdsCmd to Tcl interface that takes a
sequence of trialids (kept the old addTrials command around just in
case...)

(3-Jul-1999, done 3-Jul-1999) Need a way to distinguish between Tcl
package name and the namespace name that is used with the package
(since the two may require different capitalization). OK, this is
fixed by just having TclPkg enforce the correct capitalization when it
calls Tcl_PkgProvide. This way, packages can use whatever
capitalization they like for their namespace prefix.

(3-Jul-1999) Maybe that weird extra stuff in Tlist should be split off
into its own class, since now it is isolated from the internals of the
list via the derivation from PtrList. This is of one of those
heuristics where a class shouldn't contain disjoint areas of
functionality. Now, I think the extra Tlist stuff could probably fit
in with that amorphous ObjTogl/ToglConfig/Togl* abstraction that is
beginning to take shape, since ObjTogl was the primary client of the
Tlist's extra functionality in the first place anyway.  [Earlier] I
think in the larger picture, the singleton Togl wants to be a new
class, which encapsulates the Togl*, the ToglConfig*, and the
GfxAttribs info, and makes all of the important info publicly
accessible. Yes, this would definitely fit in with the TclItemPkg
picture... it would allow a lot of the code to be moved out of ObjTogl
command functions and into some other abstraction. OK, these things
are coalescing into Toglet right now. But some remaining
questions... the widget should be a singleton, but conceivable we
might want to change some functionality at runtime, such as how it
handles reshapes, redraws, etc. Do these things still need to be
wrapped in a polymorphic ToglConfig-like subobject that can be
replaced with a different subobject at runtime? Right now I'm
gradually migrating existing functionality into the ToglConfig
class... need to move in the error-handling code that used to be in
ObjTogl. OK, error-handling code for setters has been moved. Next: (1
reconsider) remove project dependencies on GfxAttribs (it can be
replaced with ToglConfig now), (2 done) get rid of toglDisplayFunc and
toglReshapeFunc in ObjTogl, replace them with virtual functions in
ToglConfig, (3 done) remove loadFont from Gtext (it's replaced with
Togl::loadFont). OK, this is all done except I'm going to reconsider
whether to get rid of GfxAttribs...

(7-Jul-1999, done 7-Jul-1999) Cut out ~300 lines of code by
introducing a new template TclPkg, ListItemPkg<class C, class List>,
derived from CTclIoItemPkg. This class takes a List& argument in its
constructor; this allows the class to implement getCItemFromId and
getIoFromId automatically without having to forward these operations
on to derived classes (all of whose overrides were pretty much
duplicates anyway). In addition, ListItemPkg provides a default
"constructor" or creator for its items, since again, all of these
implementations were virtually identical. Also, I improved ListPkg in
the same way so that it takes a List& argument in its constructor,
allowing it to implement getCItemFromId and getIoFromId itself.

(3-Jul-1999, done 8-Jul-1999) Tlist should inherit from PtrList so
that it can share functionality, in particular iterators. The PtrList
iterators should eliminate the need for getValidIds... OK, Tlist now
inherits from PtrList like the rest of the lists.

(8-Jul-1999, done 9-Jul-1999) There is almost certainly still a bug in
the block(), responseHdlr(), and timingHdlr() members of
ExptDriver... they catch internally an InvalidIdException that might
be generated by a failed list access attempt, but then they are still
unable to return a reference; I think they must instead allow the
exception to propogate and force the callers to deal with the
exception. Actually, easier than this would be for callers to simply
call isValidId() before they try to retrieve an item reference. OK,
set up a method assertIds() that is called at the beginning of all of
ExptDriver's event handlers; it checks if there are any invalid id's,
and if so generates an error message and halt's the experiment.

(7-Jul-1999, done 12-Jul-1999) Should make SoundTcl into a
now-standard list/item package combo. Need to define a SoundList, and
this will help other areas of the application since I won't have to
export playProc from SoundTcl namespace anymore. Also this might
facilitate writing c++-side beedback procedures for response
handlers. Sound class should be an abstract class that (in theory) can
read a variety of sound formats, and play the sounds on a variety of
audio servers. OK, this is underway. Still need to change
KbdResponseHdlr to use the new format (in fact, now KbdResponseHdlr
can "own" the sound that it wants to use...). Perhaps should add
symbolic constants in Tcl such as Sound::OK and Sound::ERR to index
the default sounds in the SoundList. --> For this, should add
linkVar() functionality to TclPkg. Also linkConstVar(). All done.

(9-Jul-1999, done 12-Jul-1999) Should rewrite Sound tests for new
Sound package implementation. Done.

(21-Jun-1999, fixed 22-Jun-1999) Bugs! Mostly in Block: 1) abortTrial
is called when the experiment is quit, but not endTrial, so the trial
index is off by one; 2) responses were getting added twice when both
processResponse and endTrial were called.

(3-Aug-1999, done 4-Aug-1999) Really weird... I turned on LOCAL_TRACE
inside bitmap.cc, and somehow now I am getting the exit-trace messages
from several other files, such as PtrList, HpAudioSound, TclCmd,
ToglConfig... This looks very oddly like somehow these are the
"missing" exit traces that are missed when certain functions are
exited via an exception throw... but wait a minute, why is there even
code present for these guys... there shouldn't even be trace code
compiled in! Have to look at this more carefully. OK... now I'm
thinking that maybe what happens is this: the Trace destructor is
defined inline, so the normal destructor call at the end of the
lexical block is inserted inline; however destructor calls that occur
due to exceptions must be made via an out-of-line function... this
means that *lots* of copies of ~Trace are lying around, and
furthermore some of them probably have LOCAL_TRACE defined, while
others don't... somehow the linker or dynamic loader must pick one of
these as the canonical version, leading to the undesirable effect that
the code that gets called for the destructor of a particular Trace
object may depend on whether that destructor is called inline or
out-of-line. This would explain why I had noticed in the past that in
some cases it appeared that Trace objects weren't being properly
destructed on exception throws... in fact they were being destructed,
but just with the wrong destructor. There are two solutions, I think:
1) put Trace inside an unnamed namespace, so each translation unit can
have and use its own special copy of ~Trace, or 2) define ~Trace
inside trace.cc, and make LOCAL_DEBUG part of the state of the Trace
object. I guess I'll go for solution (1) in the name of efficiency,
since the Trace objects are fairly ubiquitous-- I'd like to avoid out
of line calls when possible. [4-Aug] OK, I tried using an unnamed
namespace, but this didn't seem to work... anyway I think a better
solution is to have a member of Trace be a boolean that controls
whether trace messages are printed; this way all Trace objects are the
same-- the conditional compilation only controls whether they are
constructed with a boolean member as true or as false.

(7-Sep-1999, done 8-Sep-1999) Wow! X11 bitmap routines are a good 10x
faster than glDrawPixels() at putting the face/house bitmaps
onscreen. To this end, I created an XBitmap class that is similar to
Bitmap but uses X11 to render the images rather than OpenGL. But,
duh--these should be related through inheritance somehow... probably
both XBitmap and GLBitmap should derive from an abstract base
class. Or... could use an enumerated field such as itsRenderMode that
controls a submember that actually does the rendering... this would
allow switching between OpenGL and X11 on the fly. The submember class
would be something like BitmapRenderer. OK, now I've made XBitmap and
GLBitmap subclasses of the abstract base class Bitmap. In general,
Bitmap's public functions are non-virtual, but call protected virtual
functions that do the real work. Where necessary, member data from
Bitmap is passed to these hook functions.

(17-Sep-1999, done 21-Sep-1999) GrObj could have a framework for
unrendering/undrawing that is analogous to the one currently in place
for rendering/drawing. This would entail storing another OpenGL
display list. OK, there is now a virtual function grUnRender(), that
will be used for undrawing if the unrender mode of the object is set
to GROBJ_DIRECT_RENDER.

(17-Sep-1999, done 21-Sep-1999) Grobj::update() should be
non-virtual... any changes that subclasses need to make can be handled
in grRecompile(). Likewise, GrObj::draw() and GrObj::undraw() should
probably also be non-virtual. Done.

(16-Sep-1999, done 21-Sep-1999) GrObj: would be nice to have virtual
functions to get a bounding box, so that other functions can arrange
things so that different GrObj's don't collide. Also, would be nice to
set an internal scale, so that the bounding box size+aspect ratio can
be set to specific values. Done.

(21-Sep-1999, done 22-Sep-1999) Could use a Bezier class that would
store a set of control points, and would be able to evaluate the curve
at given values of u, would be able to return derivatives for given u,
would be able to find the maxima for each dimension in the range
u=[0,1]. OK, I now have a Bezier class that can evaluate the curve and
its derivative, but I don't have a way to get the extrema... Which way
to go: analytical or numerical? Numerical for now. Just do a rough
search for zero-crossings of the derivative.

(8-Sep-1999, done 21-Sep-1999) XBitmap's should be able to handle
raster data types other than 1-bit-per-pixel bitmaps. This will just
involve a few switch statements in the XBitmap member functions. OK,
done.

(23-Sep-1999, done 29-Sep-1999) GrObj::getCategory() should definitely
*not* be pure virtual. Most subclasses don't use it. There should at
least be a no-op default implementation. Also, charCount() should be
non-pure virtual, since serialize() and deserialize() are
likewise. Done.

(9-Sep-1999, done 29-Sep-1999) MorphyFace with 22 parameters to
control the face is now mostly implemented. With such an abundance of
parameters, it would be nice to have a helper class to represent the
parameters... something that contains 1) the parameter's name, 2+3)
pointer-to-members for get+set functions, 4+5) the parameter's min+max
values, 6) the quantum for the parameter. Also, a class static
function should be able to retrieve a reference to a list of all the
parameters. Also, a class static should be able to return a particular
parameter given the parameter's name. Most of this framework could be
arranged in a base class. ...This is metaclasses revisited all over
again--it would be a way of moving some of the TclPkg stuff back into
the actual classes. The nice thing about having a parameter class is
that it makes it convenient to set up different manipulators that work
on the parameter. In fact, the TclCmd's that are generated by
declareCAttrib() are just command-line manipulators. [17-Sep-1999] The
parameter information such as its name, pointer-to-members, etc. does
not need to be stored separately for each instance of a class... this
info should be static somehow. It could be provided through template
parameters to the Parameter or Property class.

(1-Jul-1999, done) With new GrObj organization, it would be simple to
add in checks for GL errors in consistent places, such as after every
call to draw(), undraw(), grRender().

(3-Oct-1999, done 4-Oct-1999) Need to provide non-file way of
constructing Fish.

(2-Oct-1999, done 4-Oct-1999) The Tcl initialization of a class should
provide a function or variable so that the Tcl side can get access to
a list of properties and value ranges. Done in PropertyListItemPkg<>.

(4-Oct-1999, done 5-Oct-1999) Need to fix error reporting from
TclValue's, so that we get only one message, not two.

(3-Oct-1999, done 5-Oct-1999) Need to check file validity in Fish
read_file functions. Done by way of porting the read_file functions
from C I/O library to the C++ I/O library.

(3-Oct-1999, 5-Oct-1999) loadFacesCmd() should be moved to a more
generic command in ObjListTcl. Hey--actually, this should be a more
generic command in PtrList; something like loadObjects(). The function
should be able to either use a virtual constructor, or be told that
all the objects are of a specific type. OK, this is mostly done--I
added a LoadObjectsCmd to ObjlistTcl. This can be easily genericized
to work with all PtrList's at some point, but it's not necessary or
worth the hassle right now.

(3-Oct-1999, done 5-Oct-1999) Need to provide a way for Response
events to trigger in a Timing Handler without necessarily canceling
all of the start events. Maybe this could be the default behavior if
the size of the itsResponseEvents vector is 0.

(13-Oct-1999, done 13-Oct-1999) ThTcl-ThList::stringify fails on SGI
with "unable to create object of type TimingHandler". Fixed... this
was one of many problems related to typename mangling under g++, so I
set up a demangle() function that is implemented per platform to
demangle (if necessary) the result of typeinfo::name() back into
something that looks like how the type was declared in the source
code.

(12-Oct-1999, done 13-Oct-1999) Need to implement some new GL commands
in TclGL, especially those relating to RGBA, antialiasing, etc. OK--
implemented glClearColor, glBlendFunc, glEnable (which gives GL_BLEND,
GL_LINE_SMOOTH, and GL_POLYGON_SMOOTH).

(13-Oct-1999, done 14-Oct-1999) swapForeBack() should become a static
GrObj function.

(13-Oct-1999, done 14-Oct-1999) IO should provide a static
eatWhitespace() utility function.

(13-Sep-1999, done 14-Oct-1999) Should add a char const to IO like SEP
that contains a default separator, so that all of the serialize()
functions don't have to always declare "char sep = ' '".

(13-Oct-1999, done 14-Oct-1999) setForeground and setBackground should
take RGBA rather than just RGB.

(12-Oct-1999, done 14-Oct-199) SGI needs a Sound implementation, even
if it's only a stub.

(12-Oct-1999, done 14-Oct-199) Need to allow RGBA mode to work
throught the project--somehow need to encapsulate the modality of
color index vs. RGBA. Locations of use of glIndex:
<morphyface.cc>::draw_hair(), Tlist::undraw(),
ToglConfig::writeEpsFile().

(15-Oct-1999, done 15-Oct-1999) Did a full implementation of
IrixAudioSound using SGI's Audio Library and Audio File Library.

(19-Oct-1999, done 19-Oct-1999) attributeCount() is no longer needed
in IO.

(note 19-Oct-1999) For better or for worse, I think I'm going to allow
null pointers to be serialized. This involves introducing the
convention of using 0 as the IO::id() for a null object.

(21-Oct-1999, done 2-Nov-1999) Fixpt needs to change its Tcl class
name to FixPt. Done, but injected all the FixPt:: commands back into
the Fixpt:: namespace for the time being to preserve backward
compatibility.

(3-Nov-1999, done 3-Nov-1999) Need a way to script experiments, so
that we can run several experiments in a row, and a new experiment can
depend on the subject's performance in a previous experiment. OK, I
added a callback from ExptDriver to Tcl that occurs when an experiment
is completed. This is mediated by the Tcl proc
Expt::doUponCompletion. This allows for varying logic at the end of an
experiment, for example, whether to run another experiment can be
decided based upon the results of the previous experiment.

(3-Nov-1999, done 3-Nov-1999) ExptDriver needs some major
refactoring... probably best to go the same route as with GrObj: put
all data in a private implementation class, then eventually put all
behavior in the implementation class. OK, I've set the ball rolling
here by moving data+behavior into ExptImpl... eventually this behavior
will become better factored.

(8-Nov-1999, done 8-Nov-1999) Problem with
AsciiStreamReader::readRoot()-- if a root object is passed in, it is
not assigned to the correct slot in the itsCreatedObjects map, since
its current IO::id() is used, which may not be the same as the id that
it had when it was serialized. We'll need to use the first id that is
read from the stream to determine the correct value for the root
id. OK, this is done, although it looks a bit ugly. Maybe I'll find a
way to refactor...

(8-Nov-1999, done 9-Nov-1999) In KbdResponseHdlr, need to determine
which functions can allow exceptions to propagate out, and which
functions must catch exceptions and convert them into a
Tcl_BackgroundError. I suppose a good first guess is that the private
functions in Impl can let the exceptions go, and the public functions
should catch them. OK, the error handling has been fairly well cleaned
up. In particular, there is a try block in privateHandleCmd that wraps
the call to handleResponse().

(21-Jun-1999, fixed 9-Nov-1999) Bug! my TclObjPtr is woefully
broken. The copy constructor was broken--it was trying to
Tcl_DecrRefCount() on itsObj before itsObj had been set to a
meaningful value.

(3-Nov-1999, done 11-Nov-1999) Need to implement
ExptDriver::readFrom() and writeTo() so we can switch over to using
Serializer everywhere. To do this, we need to allow mulitple roots to
be read and written via Reader/Writer. ... OK, I've handled this
instead by allowing owned objects to be read and written-- this way
ExptDriver acts as though it owns all of the singleton PtrList's, and
reads/writes them as its own.

(9-Nov-1999, done 16-Nov-1999) Need to implement readFrom/writeTo for
Trial. Done. The main innovation to make this easy was to introduce
stream insertion and extraction methods into the class Value. This
allows subclasses of Value to be written or read in place by a Reader
or Writer. This technique was used to handle Trial::Response and
Trial::IdPairs as value types.

(8-Nov-1999, nixed 16-Nov-1999) Value should have getStringRep() and
setStringRep() virtual functions so that we can avoid switch
statements on getNativeType() inside AsciiStreamReader/Writer. The
need for this has effectively been averted by the introduction of
virtual functions printTo() and scanFrom() to handle stream insertion
and extraction for Value's.

(4-Nov-1999, nixed 16-Nov-1999) Reader/Writer needs to have facilities
for in-place objects (i.e. owned objects), that are referenced only
once in a hierarchy and therefore can be handled in place rather than
by writing an IO id number and deferring the read/write. This will
help to make for more readable files. Function should be called
read/writeOwnedObject. Hmmm... this is trickier than I thought--
reading objects in-place would require a significantly more complex
main read loop, since we essentially need stack frames for each level
of nesting-- there will be multiple sets of attributes active at any
one time. Perhaps it's best to defer this functionality until later,
since it is mainly a convenience to make files more readable. Wait a
moment... there's a distinction here between writing owned objects,
and writing objects in place... handling owned objects *is* definitely
important in order to be able to implement reading/writing Singletons,
for example. [Later] ... OK, I've avoided this issue by provided class
Value with methods printTo() and scanFrom(), which are intended to do
simple stream insertion and extraction. Clients can subclass Value for
types that should be treated as value types, and therefore be read and
written in place. This helps keep a clear distinction between value
types and object types.

(nixed 17-Nov-1999) [this has all been nixed by the introduction of
Reader/Writer, which allows for generic serialization and
deserialization] "generic" file descriptor format??? still need to
have ways to change internal format, and thus serialization format, of
objects while still being able to read old formats.

Wow... I just realized what the Holy Grail of this IO stuff would
be... each class would not even have to write its own serialize and
deserialize functions. Instead, it would have functions to provide a
list/vector of serializable's that it contains and would like to have
considered for reading and writing. Then, this function would be
called by a generic serialize or deserialize function in the base
class (IO) when an object needs to be read or written. This would be a
Good Thing. But how would this work with different revisions of
classes??? (Later...) Almost as good would be able to ignore order
when serializing/deserializing, and read/write members by name.

There is the thorny issue of memory management here... what to do with
all these little IoWrapper objects that will be floating around? Are
the part of an objects state (in which case they are wasted most of
the time) or are they created dynamically when a read or write is
impending? In the latter case, how can we treat handle both
dynamically allocated IoWrapper's and more hefty IO classes without
mucking up the memory management?

Think about more general way to do serialization. Concern is that file
format is not neatly stated in one place, but rather must be
maintained across serialize, deserialize, and a charcount
procedure. Charcount could be improved by using a special ostream that
doesn't really write anything but instead counts characters. Then the
charcount could be obtained by running serialize onto this special
ostream, then calling the ostream's count() function.

Make serializable wrappers for built-in types, like ioInt, ioDouble,
etc. that implement the IO interface. Then these could be used for the
members of classes derived from IO. !!! Actually, the member variables
don't need to *be* these wrappers. Instead, each class could hold a
collection of references/pointers (?) to serializable objects. The
ioInt wrapper would just hold a reference to the actual int member
variable. The list of serializables would be established in the
constructor, the appropriate references made, etc.... then
serialize/deserailize is just a matter of a simple for each!!! This
would avoid any possibility of inconsistencies between
serialize+deserialize. How would this interact with maintaining
compatibility with older versions of objects?

(1-Jul-1999, nixed 17-Nov-1999) Idea: could handle serialization of
vectors by defining a new vector iterator that is a subclass of IO?

(19-Jul-1999, done ???) Idea for how to do feedback through response
handlers: response handlers take a list of pairs where each pair
consists of a Tcl expression and a Tcl script. When a response is
given, the Tcl expressions are evaluated in order until one evaluates
to true; in that case the associated Tcl script is executed (probably
plays a sound or something), and the feedback procedure
returns. Oops... how do we pass information about the response value
to the expressions? Set up a Tcl variable that contains the response
value before we evaluate the expression, then unset it afterwards.

(13-Oct-1999, nixed 17-Nov-1999) Need a better way to robustly
serialize string's, avoiding problems related to leading whitespace,
etc... [Later] This is all taken care of by Reader/Writer

(21-Jun-1999, done ???) There should be an easy way to automatize the
code for creating items in Tcl packages... it just needs to be a
command class parameterized by the type of object to create, and the
list to add it to. Done, with TclItemCmd.

(note 11-Nov-1999) Should GrObj's draw function take a Window
argument, where the Window function provides the graphics primitives
such as draw line, etc...? Yes! Actually, I'd call it a Canvas
argument, and it could include the functionality of the widget part of
ToglConfig.

(note 10-Nov-1999) I think conceptually there are two different
abstractions in ToglConfig-- one represents the widget, with its
screen width + height, and the other represents the "camera", or the
view into the OpenGL world, with its viewport,
perspective/orthographic projection, etc.

(20-Nov-1999, done 20-Nov-1999) Could make Factory a little faster to
compile by avoiding the #include <map>. 1) Make a non-template
CreatorMapBase class that has an Impl class that hides a map<string,
void*>, with implementation in the .cc file. CreatorMapBase has an
abstract destroy(void*) function that is implemented to take care of
deleting the elements. 2) Make a typesafe templated wrapper around
CreatorMapBase. 3) Factory<Base> uses CreatorMap<Base>. Done.

(20-Jul-1999, done 21-Nov-1999) It would be highly prudent to split
off the implementation of PtrList<T> into a non-template base class
IoPtrList. The implementation of PtrList::serialize and
PtrList::deserialize requires that T be derived from IO anyway, so
this doesn't really restrict things. Then PtrList<T> could derive from
IoPtrList and achieve type-safety with casts to and from IO*;
furthermore PtrList<T> could now be defined in a header file alone
using simple inlines, avoiding explicit instantiations. This would
eliminate nearly all of the code bloat caused by the current six
instantiations of PtrList<T>, and would also significantly reduce the
recompilation time associated with changes to the implementation of
PtrList (now IoPtrList). Oops... PtrList::deserialize requires a
dynamic cast to ensure that the created object is of the correct
type... maybe we can fix this by adding a pure protected virtual to
IoPtrList called typeCheck(IO* p), which will be implemented in the
derived PtrList<T> to test dynamic_cast<T*>(p) for success. This can
be easily inlined. Arrgh. I implemented IoPtrList, but then when I got
to implementing PtrList<T> as a private derivative of IoPtrList, I
realized that the getPtr() functions in PtrList<T> must do a
*dynamic_cast*, not a static_cast, in order to convert the result of
IoPtrList::getPtr (which is an IO*) into a T*. This incurs a
significant runtime cost, whereas a static_cast would have none. Is
there no way to avoid this mess, i.e. to allow one underlying
implementation of an IO* list, yet allow type-safety through
templatized wrappers? I think somehow it should be possible, with the
idea that a dynamic_cast may be necessary when storing
pointers. [Later] ... OK, this is finally done. I split off the
implementation of PtrList into two base classes--VoidPtrList and
IoPtrList. VoidPtrList provides the basic storage management in a
vector<void*>, and delegates the destruction of pointed-to objects to
the abstract function deletePtr(). IoPtrList provides the IO
operations, and delegates the cast to/from IO* to abstract functions
fromVoidToIO() and fromIOToVoid(). PtrList<> then provides a typesafe
wrapper for all of this functionality. It stores the pointers by
static_cast'ing between void* and T*; IO*'s are retrieved by
static_cast void* to T*, then dynamic_cast T* to IO*.

(30-Nov-1999, done 30-Nov-1999) How to avoid 'unused variable'
warnings with FactoryRegistrar's? ... moved the registration from the
constructor into a static operation.

(24-Nov-1999, done 1-Dec-1999) Should refactor Bitmap with an Impl
structure so we can add private functions like an invariant.

(1-Dec-1999, done 1-Dec-1999) Can avoid the need for a global
Experiment by passing an Experiment* argument to all participants in
Experiment (such as TimingHandler, ResponseHandler, etc.).

(2-Dec-1999, done 2-Dec-1999) BmapRenderer should be able to defer
calls to bytesChangeHook() until just before doRender() is
called... this way, bytesChangeHook() can have available the
Canvas/Window argument it needs to extract X11 info. Who is
responsible for this? BmapRenderer itself, or its owner? Aha!
Actually, bytesChangeHook() doesn't need to pass in arguments... it is
just a way of notifying subclasses that the bytes of changed... if
they care, they can maintain a bit that keeps track of this... then,
when doRender comes along, they can update if necessary before doing
the drawing! This should be more efficient as well, since it avoids
unnecessary bit-twiddling if multiple byte changes occur between calls
to doRender().

(1-Dec-1999, done 2-Dec-1999) Should work to uncover cyclic
dependencies uncovered by ldep. Main ones are GrObj<->Bitmap, and
ExptDriver<->TrialEvent, TimingHdlr. Done... this was a good lesson in
the benefits of abstract protocol classes...

(3-Dec-1999, done 3-Dec-1999) writeResponsesProc should move out of
TlistTcl and into a separate TlistUtils component. Done.

(14-Oct-1999) I'm just realizing there are two main ways objects get
drawn on the screen... through TlistTcl::showCmd, and through
TlistToglConfig::display(). These two should do exactly the same
thing, and probably share an implementation. Last remaining problem is
how to store information about the current trial... specifically, when
Block calls drawTrial()--if the window triggers a redraw callback, it
won't have any way to know about the current trial. We could add a
setCurrentTrial() method to the Experiment abstraction... but this
seems a bit out of place, perhaps? Still, it might be the best way to
avoid dependencies. OK, all of the drawing stuff has now been moved
into TlistWidget, which maintains the current trial and visibility.

(8-Jul-1999, nixed 5-Dec-1999) Idea for how to unify ItemPkg's that
require an id and those that don't, and also allow Pkg::with
statements... use the idea that an id of -1 means "use the default
item". In pkg's where an id is not required, the default is to "always
use the default", but where an id is required, there could be a
'Pkg::with id' command to specify which item should be the default if
an id is not given or is -1. ...However, would this really help
things? Would the length of the argument list have to change when we
are inside a 'with' scope?

(8-Jul-1999, done 5-Dec-1999) Tlist still has this kooky augmented
interface... some of the functionality could be moved out to the new
Toglet structure, and some of it is just plain not needed (like
addToTrial... this can be done with a getPtr followed by
Trial::add). redraw(), undraw(), clearscreen(), etc. sound
oh-so-suspiciously like they belong with the Togl stuff.
loadFromObjidsOnly could go in some TlistBuilder class (along with
makeSingles, makePairs, makeTriads, and makeSummaryTrial, I might
add). ... This is now all done.

(6-Dec-1999, done 6-Dec-1999) More things to add to Canvas:
flushOutput() function. StateSaver class to manage
push/popState. clearColorBuffer().

(6-Dec-1999, done 6-Dec-1999) Remove ExptDriver's dependence on
GLCanvas::theCanvas() by adding a getCanvas() function to Widget(),
and implementing this in ToglWidget to return GLCanvas::theCanvas().

(5-Dec-1999, done 6-Dec-1999) GfxAttribs stuff should move into
Canvas... isRgba(), isColorIndex(), isDoubleBuffered(),
hasPrivateCmap(), screenPpi()?

(1-Dec-1999, done 6-Dec-1999) OK, now we desperately need a Canvas
argument to the grRender() functions. This would avoid all this muck
about trying to initialize X11 info correctly in XBmapRenderer--
instead, we could just pass a Canvas argument that contains (or can
fetch) the necessary X11 info. How would this Canvas get passed
around? Needs to end up at GrObj::draw(), from Trial::trDraw(), from
Block::drawTrial() or TlistWidget::safeDrawTrial.

(done 6-Dec-1999) Eliminated GfxAttribs from the project.

(7-Dec-1999, done 7-Dec-1999) Should move the declarations of
TVecSetterCmd, etc. out of tclitempkg.cc and into the header file so
that they can be reused via inheritance. Done.

(7-Dec-1999, done 7-Dec-1999) Can add Tcl_Interp* argument to
ExptDriver c'tor now.

(7-Dec-1999, done 7-Dec-1999) Potential unsigned problem in TclItemPkg
with 'max_valn = vals.size() - 1'. Fixed with check vals.size() >= 1.

(6-Dec-1999, done 7-Dec-1999) The TclPkg's need to be able to get a
hold of a Canvas in order to properly call some functions now, like
GrObj::update(), and potentially GrObj::getBoundingBox(). Probably we
need to provide global access to an Experiment*, from which we can
retrieve a Canvas*. OK, this is done with the Application abstraction,
which can fetch an Experiment*.

(11-Dec-1999) Ugh. Lost about eight days of work in the crash of
snowball2. So, goal #1 is to come up with my own backup plan for this
project so that I don't lose any more 2,000 lines of source code. Need
to have a 'make' target that will do everything needed to tar the
source files and ftp them somewhere safe. ... Very thankfully, Anne
was able to restore the contents of my home directory from snowball2
after some "hardcore scraping". Hopefully I've learned a lesson
here... backup backup backup!

(30-Nov-1999, done 7-Jan-2000) What to do about 'control reaching end
of non-void function' in ExptDriver::Impl::block(), responseHdlr(),
and timingHdlr()? Probably the best is to eliminate the error checking
in block(), responseHdlr(), and timingHdlr(), and require that the
id's be checked with assertIds() before these functions are called. We
can add an Assert to this effect inside block(), etc. Done.

(11-Jan-2000, done 11-Jan-2000) Need to have quick Tcl access to the
current trial id. Probably an Expt::currentTrial command for Tcl.

(14-Jan-2000, done 14-Jan-2000) There is some weird problem with
TlistWidget, perhaps?  Ah yes... first, we didn't initialize
itsCurTrial and itsVisibility in the constructor, and second of all,
we didn't check for itsVisibility in safeDrawTrial() before attempting
to draw.

