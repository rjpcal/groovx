$Id$
"Make it run, make it run correctly, make it run fast"

*** FRONT of priority queue ***

(24-Sep-2000) Big categories: 1) memory management, 2) screen update
hierarchy, 3) experiment event sequence, 4) migrate away from old IO,
5) automate data analysis, 6) automate series of experiments.

(24-Sep-2000) Add a miscellaneous "log" string property to ExptDriver,
so that we can append human-readable messages to it as needed.

(23-Sep-2000) Should have a log-file that can catch non-essential
messages (such as the timing info that is emitted by TrialEvent
destructors). 

(23-Sep-2000) Need a platform-independent way to find black/white
color indices (could be implemented as Togl:: functions).

(21-Sep-2000) Got some cool breakpoint-type things working with
Util::Trace. Basically, we can call Util::Trace::setMode() so that we
break into a command-line on trace-in and trace-out. Then this
command-line can either reset the mode to RUN, or continue
stepping. We could easily allow step-in or step-over as well, by
putting a limit on the stack depth for which tracing is allowed.

(21-Sep-2000) Arghh! More event-loop problems. Get a core dump after
Ctrl-C (which halts experiment), followed by Ctrl-Q (which rehalts,
then attempts to write data and quit). This triggers an assertion
itsCanvas != 0 in Trial::getCanvas, called from
Trial::trUndrawTrial(). OK... I'm getting to the bottom of
this. Basically, the first halt triggers Block::abortTrial(), from
Trial::trAbortTrial(), from Trial::trHaltExpt(). This changes the
current trial in the Block. Then, on the next halt, the new current
Trial attempts to trUndraw(), but this fails since the trial has never
been begun, and so itsCanvas == 0. TO SOLVE THIS: I think that
trHaltExpt() doesn't really need to trAbortTrial()... it would be fine
to just leave the current trial as is; when the experiment resumes
we'll start off with the same current trial. But this may miss the
underlying problem... that somehow it is possible to have a "current"
trial in a corrupted state. We could introduce a state flag into the
Trial, so that it ignores all requests until it has been officially
begun.

(21-Sep-2000) A new subclass of Reader/Writer could handle exporting
data in a format suitable for Matlab use, perhaps.

(12-Sep-2000) Would be nice to have some sort of resource/message
loading, so that we could put strings in a separate resource file.

(7-Jul-2000) Adding an 'itsCorrectVal' member to Response. Should this
value be serialized? We don't have a good way to do versioning of
Value types that are written/read with printTo()/scanFrom().

(22-May-2000) Need to have a way to destroy the pause keybinding when
an experiment is done. The problem is, ExptDriver shouldn't know about
the names of the Tcl commands that run it... therefore we don't want
ExptDriver to create/destroy bindings to "Expt::pause".

(28-Mar-2000) The Togl widget can take over its own event dispatching
by calling Tk_CreateEventHandler; then we can add event bindings to
the widget using C++ only, without having to use Tcl script code.

(16-Mar-2000) Block should have a parameter (or virtual function) to
control what happens on abortTrial()... i.e., should we reschedule the
trial, ignore the trial, record an invalid response?

(20-Jan-2000) We should set up a way for Trial's to have a prepare()
function which would do things like update its GrObj's (and flush
pending requests like loading bitmap data). Then Block's could have a
prepareNextTrial() function which could be called during the preceding
trial.

Goal: ExptDriver shouldn't have to know about any lists except maybe
BlockList. As for serializing, the lists should register themselves
with ExptDriver at application startup. Experiment base class should
declare an abstract manageObject(const char* name, IO* object)
function. The lists should call this in in their
Tcl_PkgInitProc's. The problem with this approach is that we lose the
ability to control the order in which the lists are read/written
through the IO interface. This is not so much a problem for the
readFrom()/writeTo() interface, as this is designed to be
order-independent, but it is a problem for the
serialize()/deserialize() interface. Perhaps we could use some ad hoc
strategy to make sure that the managed objects are written in the same
order every time (based on their ioTypename() for instance?).

========================================================================
GOAL #2
(24-Jan-2000) Allow a more flexible description of the scene graph, a
la Open Inventor.

This is now particularly important as Trial's take on more
behavior... they shouldn't be used anymore as a way to store
combinations of objects.
------------------------------------------------------------------------

========================================================================
GOAL #3
(24-Jan-2000) Implement reference counting so that smart pointers can
be used within C++ instead of integer id's.

OK, forget the traditional ref-counted pointers. Instead, we'll put
the reference counting right into the list. This will avoid the
problems with maintaining the VoidPtrList <- IoPtrList <- PtrList
hierarchy. VoidPtrList will be able to hold the ref counts, and
maintain the ref counting logic; it will just have to forward object
destruction to a derived class via a virtual function, as it does now.

Clients will use a ListItem, containing an integer id and a pointer to
a PtrList. The ListItem's constructors and destructor will manage the
ref counts via calls to PtrList member functions. ListItem will offer
an operator-> so it can be used as a smart pointer.

In order to hide PtrList from clients, we can define the necessary
functions out of line.

At the expense of some size, we can cache a C* inside ListItem so that
we don't have to call a PtrList member function every time ListItem is
used. Basically, PtrList would keep a counter that is incremented
every time the list is modified. ListItems would maintain a const* to
this count, and would also store the value of the counter from the
last time their C* was cached. Then checking that the cache is current
just involves dereferencing the const* counter and comparing it to the
stored counter value.

Problem: how to handle derived classes with a ListItem?

(10-May-2000) In lieu of true reference counting with PtrList's, we
could allow locks that clients could take that would temporarily
prevent objects from being deleted.
------------------------------------------------------------------------

========================================================================
GOAL #4
(24-Jan-2000) Develop a more coherent view of the screen-update model:
Who gets to do it, and when?
------------------------------------------------------------------------

========================================================================
GOAL #5
(15-May-2000) Improve the overall timing accuracy of the software.

(29-Nov-1999) TrialEvent's could internally adjust their requested
delays so that the actual delays converge to the requested
delays. This would require some care to ensure that we don't send the
entire system into an unstable oscillation. We'd maintain two values:
itsIdealDelay, and itsRequestedDelay. The ideal delay remains
constant, but we modify the requested delay based on experience to try
to get the actual delay to meet the ideal delay. There are several
strategies we could use to make these adjustments-- one would be to
try to minimize the total timing error of the TrialEvent, another
would be to minimize the average absolute value of the timing
error. [Later] We could also control the timing more globally... where
a block or experiment knows how long it is supposed to last, then
timer events report to the block how long they requested, and how long
they actually lasted. Then the block could adjust the requested times
for future trial events in order to compensate.

(done 14-May-2000) Implemented error-checking and adjustment in
TrialEvent's. This gives very good accuracy (+/-1msec average per
trial) over an experiment. Still need to control this error-checking
from script-level, and to provide a hint to the TrialEvent at
construction time.

(15-May-2000) Need to include info about timing throughout the
experiment object hierarchy, from Experiment, Block, and Trial, to
TimingHdlr. Each object should know its allotted time, its expected
error, and should compute its actual error and use this to give
feedback to someone in order to improve future timing. Experiment and
Block don't have too much control, but they can keep an overall view
of how the timing is going, and perhaps issue a request for future
trials to compensate their timing by a particular scale factor in
order to adjust for past errors.

(15-May-2000) Perhaps most usefully, Trial's should know their desired
length and give feedback to their TimingHdlr's so that the
TimingHdlr's can do a multiplicative scaling to compensate.
------------------------------------------------------------------------

========================================================================
GOAL #6
(16-May-2000) Phase out the old serialize()/deserialize() interface.

(13-Apr-2000) Encapsulate the old serialize/deserialize functions by
wrapping them in a special Reader/Writer pair, that has specialized
functions for each of the currently existing types. If an unsupported
type is encountered, we throw an exception. Come to think of it, we'd
only have to support a Reader, since we don't want to do any writing
if this format is to become obsolete. This would have the advantage of
moving all the ugly old code out of the current components.
------------------------------------------------------------------------

========================================================================
GOAL #7
(16-May-2000) Make bitmap caching a more fluent part of the software.

(21-Mar-2000) Need to have a way to explicitly represent GrObj's with
cached-bitmap-file representations... this way we can have access both
to a GrObj's semantic properties (i.e. face width, nose length, etc.)
while still accessing it in a bitmap form. This would involve a
command to cache a GrObj to file, given a filename, and then the
object should automatically load that file when it is deserialized at
a later time.
------------------------------------------------------------------------

========================================================================
Subsection on refactoring ToglConfig into Widget, Camera, Canvas

(15-Jan-2000) ExptDriver should really own the widget (actually a
TlistWidget)... Then we can eventually have multiple Experiment's at
once, each with its own widget??? is this right?

(27-Nov-1999) Who uses theToglConfig()?
EventResponseHdlr uses the Widget part in the attend() and ignore() methods
ExptDriver uses the Canvas part it in swapBuffers().
ExptTcl uses the Widget part in BeginCmd, SetStartCommand,
ObjTogl uses the Widget Part in DestroyCmd.
ObjToglPkg uses it in getCItemFromId().
xbitmap.cc uses a special X11Widget subclass in init_class().

Eventually, we'd like to have a list of Widget's, with ExptDriver
maintaining the current one for an experiment, so that experiment
participants can request it from ExptDriver (or it passes the Widget
to them).

(27-Nov-1999) One important reason for refactoring all this stuff is
so that we can have more than one active Togl widget... then we can
improve user interface, e.g. bring up a dialog box to edit a GrObj,
etc.

(27-Nov-1999) It looks like there should be a Window/Widget class,
that contains a Camera and a Canvas. Or does the Camera need to
contain the Canvas? It seems like the Window will pass a redraw
request on to its Camera, which would need to have a Canvas reference
to pass to the graphic objects in order for them to redraw themselves.

(17-Nov-1999) The emerging Camera abstraction: includes some of the
ToglConfig functionality such as perspective or orthographic
projection, viewing distance, viewport, and which will be used by a
Window/Widget to handle redraws and reconfigures. A subclass of Camera
can carry the Tlist functionality such as setVisible(), setCurTrial(),
etc. Actually, it seems there are two different parts to camera: one
is the object/scene that it is viewing, and the other defines the sort
of projection that is used.

(17-Nov-1999) The emerging Canvas abstraction: could be passed to
GrObj's in their grRender() function. How does it relate to a
Window/Widget? Is it owned, referred to, etc.? Has a width+height.
------------------------------------------------------------------------


========================================================================
(29-Nov-1999) How to automate the data analysis? Need to bridge the
gap between output of Grsh program running experiment, and necessary
input to Matlab to process data. I think this is a possible route:

		1) expt completes and saves files

		2) a Grsh script runs and processes the data further, generating
         the data files that matlab needs, and also **generating a
         Matlab script file (.m file)** that we can run to process the
         data.
			
		3) Run the .m file to finish the data processing.

What input does this process need? We need to know the location of the
pairs/triads experiment file, and of the classification experiment
files.

Breakdown of classification process:

1) make incidence matrices (see make_inc_mat_mfaces_s50.m as example)
   from resp files.
2) run models (see run_mfaces_models.m as example)

Important data:

- base directory which contains subjects' individual directories
- name of subject (encoded as directory for subject)
- date of pairs experiment (to create pairs directory based on date)
- name for type of objects
- names of response files in probe experiments

Use case:
1) run experiments + collect multiple data files from several subjects
2) run mds analysis on results of similarity tasks
3) compile subjects' overall categorization results across all clones
4) fit various models to the categorization results
------------------------------------------------------------------------

========================================================================
(17-Nov-1999) Need a way to automate the experiment-running process to
do several things... [later] Aha! I see that this is just yet another
level of abstraction on top of block/experiment etc. In fact, there
might be two abstractions: one which defines a series of experiments
to be run together as a session (ExperimentSession?), in which the
next experiment might depend on the results of the previous one, and a
higher level abstraction which defines a series of sessions
(ExperimentSeries) that constitute an entire experiment, lasting
perhaps several weeks. An ExperimentSession probably requires only one
process, whereas an ExperimentSeries requires multiple processes to be
run, over the course of many days/weeks (and therefore requires the
help of some persistent data in the form of files in order to maintain
itself over the entire duration).

1) 'log in' a subject ==> change to the correct directory
2) run an experiment
3) move the experiment data files to appropriate names and chmod appropriately
	--> this requires ExptDriver() to provide the names of its most
	recently saved files
4) possibly repeat steps 2+3
	--> We can store a file that contains a list of experiment commands
	that should be issued. A separate file, called 'next_expt' can be
	updated to always contain the command needed to run the next
	experiment. When one experiment is completed, the driver rewrites
	the 'next_expt' file appropriately.
5) exit
------------------------------------------------------------------------

(22-Mar-2000) We could have a more compact reader/writer format by
using a system that wrote class definitions to the file, and stored
some sort of translator for each class in the reader/writer... this
would allow us to just store the raw data for individual objects,
without having to store the metadata over and over. [Later] the
generic version of this is that each read/write requires a per-class
translater, with the default being that the normal verbose translater
is used, but if a different translater is present, then that one can
be used instead.

(19-Jan-2000) GLBitmap should use auto_ptr for itsRenderer and fix
initialization order (eliminate tempRenderer). Same for XBitmap.

(19-Jan-2000) Does BitmapRep really need to implement grUnRender(), or
can we just use GrObj's GROBJ_CLEAR_BOUNDING_BOX mode?

(19-Jan-2000) Auto-detect gzipped files? (Hint: how is Tcl's 'file
extension' implemented?)

(17-Jan-2000) We should have a TclVecItemCmd<C> template that parallels
TclItemCmd<C> but can handle vectors of items. Mainly it would need a
getItems() member that returns a reference to a vector<C*>. ... no,
better would be to have getItems() take an insert iterator. Actually,
there ought to be some way to get the base class to take care of most
of the iteration, so that the subclasses just need to define what to
do for each element. This would be similar to the way VecSetterBaseCmd
provides a partial implementation for TVecSetterCmd.

(11-Jan-2000) ObjList::saveObjects should not save base classes, perhaps?

(8-Jan-2000) How to read/write CountedPtr's? This is the big barrier
to establishing CountedPtr's as a better way to manage objects between
C++ and Tcl. Probably Reader/Writer need a special method for
CountedPtr's. The question is how to keep track of the pointers to the
reference counts. Or... we could put the reference count right in
IO... Aha! Instead of AsciiStreamReader maintaining a map<unsigned
long, IO*> during deserialization, we could use a map<unsigned long,
CountedPtr<IO> >. However, this introduces a split from the semantics
of readOwnedObject()... this suggests that we need a separate map for
owned objects. As this transition will require a nearly universal
switch to CountedPtr's, we need to provide a feasible migration route,
perhaps by providing the ability to short-circuit CountedPtr's
ref-counting at first.

(14-Dec-1999) Need Canvas& arguments on GrObj::getBoundingBox,
GrObj::grGetBoundingBox, and Bitmap::grabScreenRect/grabWorldRect.

(14-Dec-1999) The implementation of GrObj should be moved into a
separate component since it is fairly heavyweight. Subclasses would
then be required to provide this implementation upon
construction. This method would allow clients, but not subclasses, of
GrObj to avoid dependencies on such components as bitmaprep, etc. But,
how to avoid having to make all GrObj functions virtual? We'd like
some to stay non-virtual. Aha! The new lightweight GrObj shouldn't
even have the grRender(), grUnRender(), or grGetBoundingBox()
functions... these will first be defined in GrObjImpl.

(1-Dec-1999) Unsavory dependencies:
  EventResponseHdlr on ObjTogl -- axed via Widget abstraction!
  EventResponseHdlr on SoundList
  ObjTogl on Tlist -- compilation dep gone, but still link dep
  Trial on ObjList, PosList?
  Block on Tlist?
  BitmapRep on GLCanvas::theCanvas()

... I see that this whole PtrList business introduces some wacky
  dependencies... I don't think C++ clients should be depending on the
  PtrList's directly. Instead, maybe the PtrList's should manage
  CountedPtr's or something similar, so that the integer indices are
  only visible in Tcl.

(14-Dec-1999) ExptDriver should really own the ToglConfig... maybe it
should arrange to create this as part of application startup?

(12-Dec-1999) Could have an abstract class for timer callbacks, one
subclass of which could use a Tcl_Interp* to register timer callbacks.

(6-Dec-1999) Replace GrObj::getScreenFromWorld etc. with
Canvas::... in BitmapRep (how to get the Canvas& arguments where they
need to be?)

(3-Dec-1999) I have a potential type-system loophole with TclItemPkg
and TclItemCmd... TclItemPkg blindly casts TclItemCmd::getItemFromId()
from void* to T*, without any guarantee that TclItemPkg is dealing
with the correct type. Suggests we need a template wrapper around
TclItemPkg?

(22-Nov-1999) Hey, I think I might be able to totally do away with
PtrList's, at least in the public interface. I think that they could
be wrapped into the base class, so that every GrObj created is
automatically placed in the ObjList, and anytime a GrObj is destroyed
it is removed from the PtrList. This would just entail overriding
operator new + delete for that class. The class would have static
operations that mimic the PtrList's operations.

(22-Nov-1999) Need to get rjp_subject working. 1) Need to maintain a
do_expt script in each subject's directory. 2) Need to make sure that
autosave file is writable by rjp_subject, and if not, use a different
filename. (Maybe use temp filename generating facility of OS?).

(17-Nov-1999) Can we automate the use of Matlab for data analysis by
opening a pipe to a Matlab process from within Tcl?

(16-Nov-1999) Should have a Reader/Writer subclass pair that mimicks
the terse format that is used by serialize/deserialize.

(10-Nov-1999) Had an idea for allowing TclCmd's to be more
generic... define abstract classes of extractors, which provide ways
to get C++ types out of Tcl_Obj*'s. The native types would be
straightforward, but more interesting would be to define extractors
for STL containers... actually, would this give me anything more than
I have now with the various getXxxFromArg() methods in TclCmd? Answer:
Yes! -- it would provide a bit more modularity, since the extractors
would be separate from the commands, and new extractors could be
introduced without having to add a method to TclCmd by subclassing it.

(5-Nov-1999) AsciiStreamReader should gracefully report an invalid
attribute name, perhaps by throwing a NoSuchAttributeError.

(20-Oct-1999) There is a memory leak (I think) in
AsciiStreamReader::readCstring()... which returns a new char[] to a
client that may not be prepared to assume ownership.

(19-Oct-1999) Just realized how testing should work for base-class
functionality... the base class test package should provide a way to
run all of the base class tests on a particular subclass. In Tcl, this
should just be a matter of providing the subclass name to a proc, for
example 'IO::testSubClass FixPt'. This can eliminate a lot of
duplicated script code, and allows all subclasses to benefit when new
base class tests are written. OK, I just realized also that it
would make sense to put the test procedures for a class inside that
class's Tcl namespace... this can be wholly at the script-level
without having to add any C code.

(19-Oct-1999) I'm suddenly turned off by PtrList's: 1) I just fixed a
bug in insertAt that is equivalent to the 'check for assignment to
self' in assignment operators, and 2) even worse, I just realized that
it would be disastrous if the same pointer were stored at two
locations in a PtrList... double deletion would result. This suggests
to me that we need a more flexible and robust memory-management
scheme, probably using reference-counted smart pointers. This will
also eliminate a lot of "dangling id" problems that necessitated
getCheckedPtr(id). But what sort of Tcl interface should the
ref-counted smart-pointers have?

(18-Oct-1999) How to handle base classes in the Reader/Writer
interface? We can can just call Base::readFrom() or Base::writeTo(),
which will generally work, unless a base class and subclass happen to
share private data members with the same name. Perhaps we could avoid
this by giving a fully scoped attribute name (i.e. 'Face::noseLength')
when storing or retrieving attributes. The disadvantage of this is
that it is only a convention, and as such it could be ignored on
purpose or by oversight.

(15-Oct-1999) There's a unifying force behind two things: 1) Tcl's
idea of dual representation-- native rep/string rep; and 2) idea of
serializing objects to a stream by converting them into a string
format. I don't know exactly what to make of it at this point, but it
seems like it could be useful... This is parallel to the duality of
makeIoList and getProperties()... these should really be
merged. Dual-rep objects (perhaps a new DynamicValue subclass of
Value) could be used in the implementation of AsciiStreamReader.

(14-Oct-1999) Gabor should have a patchWidth/patchHeight attribute,
that controls not the size of the object inside the patch, but the
size of the patch itself (i.e. how big the window onto the Gabor patch
is).

(12-Oct-1999) The SGI-related bugs start rolling in... Had to
conditionally compile out the delete's in ~TclPkg since they were
causing an inexplicable bug.

(11-Oct-1999) Could write a Widget class that encapsulates the details
of Tk widgets. Then we could extend with subclasses... for example one
subclass could be designed to edit Property's of another class.

(8-Oct-1999) GrObj should use Property's, so that GrObj attributes can
be added to the list of a subclass's attributes.

(6-Oct-1999) GrObj needs a saveBitmapCache() function to dump a cached
bitmap to file. Or maybe just a writeBitmap() function, that would
apply even for objects whose mode is not one of the bitmap cache
modes, and that would generate a temporary bitmap if
necessary. [Later] This stuff belongs outside of the GrObj class,
since it needs only the public interface... perhaps it should just go
in grobjtcl.cc file.

(6-Oct-1999) Should Property's be Observable's? Is this worth the
extra space? Perhaps only some properties should be Observable's. How
would this be done?

(5-Oct-1999) Maybe TimingHdlr should have a toggle switch to indicate
what the behavior should be when a response is seen. (Whether to
cancel StartEvents, etc.).

(2-Oct-1999) Property's could store a pointer to something like
ValChecker, which has a virtual function, that could variously do 1)
check whether new value is the same as the current value, 2) check
whether the new value is in bounds/valid. If the ValChecker* is 0,
then no check is done, and not much time is lost worrying about the
check. This would avoid the problem of trying to maintain parallel
hierarchies of Property, BoundedProperty, etc.

(2-Oct-1999) Eventually, it should be possible to declare all of the
necessary Tcl functions for a class with something like template<C>
initTcl(), which in turn would call C::getProperties,
C::getMethods... etc.

(2-Oct-1999) Should be able to call up a property info struct from a
class by giving it a string name of a property.

(29-Sep-1999) It would be nice, in the Value/Property scheme, to be
able to avoid triggering sendChangeMsg() when the value doesn't
actually change (e.g if the new value was the same as the current
value, or was out of bounds).

(20-Sep-1999) Fixed a nasty memory corruption bug that was due to
neglecting to set GL_PACK_ALIGNMENT appropriately before reading pixel
data out of the screenbuffer into main memory. Since the value for
GL_PACK_ALIGNMENT defaults to 4, it is not sufficient to allocate
(width*height) bytes if the row size is not divisible by 4. How to
avoid these problems in the future? Include a byteAlignment member in
Bitmap, add a utility function that reallocates appropriate space for
a given width and height.

(16-Sep-1999) BUG: if somehow the current trial becomes invalid, it is
impossible to show a new trial because the program always tries to
undraw the current, invalid trial before drawing a new one. So there
is no way to un-corrupt the program state.

(16-Sep-1999) Could use some functionality in a base class to handle
the pattern of making all/some of a classes members IoWrapper's, then
doing serialize by putting the IoWrapper's into a vector and iterating
over them. Base class could handle serialize/deserialize, and would
forward the list generation to subclasses via the virtual function
makeIoList().

(13-Sep-1999) It is becoming more urgent to set up dynamic loading of
Tcl modules, so that not everything must always be loaded when
starting up grsh.

(13-Sep-1999) Should change ToglConfig to a "Camera"-style interface,
a la Open Inventor. Then different types of camera's, such as
orthographic or perspective projection, could be related by
inheritance from an abstract base class Camera. Parameters include
viewing volume, autoUpdate (determines if scene is automatically
redrawn upon Expose or Resize events)...

(19-Jul-1999) Eureka! The right way to build various experiments is
now suddenly clear (!) There must be an abstract base class
ExptBuilder that will have pretty much one function, build() (but how
does it get the params that it needs?). This abstract class can have a
Tcl interface associated with it. Subclasses will know how to build
specific types of experiments, such as triads expt's, pairs exp'ts,
facefinder expt's, etc. In particular, one subclass could do all its
work in Tcl by just taking a Tcl script as its constructor argument,
and Tcl_Eval'ing that script in its build() function. This class would
still allow great flexibility in expt-building since Tcl build scripts
could be changed without recompiling; however the framework allows
more stablebuild scripts to be migrated to their own subclasses on the
C++-side. But wait... what advantage is there to having all this stuff
in virtual functions? i.e., where is the client that will benefit by
not having to know the concrete class of some ExptBuilder?

(25-Jun-1999) Need a coherent way of handling colors............
[Earlier] Who should own foreground/background information? Seems like
it could belong to either or both of GrObj and Position. Maybe best
idea is to use ColoredObj and ColoredPosition as derived classes, if
necessary. Default behavior of non-colored classes would be to use
whatever color was active, while colored classes would set their own
color when they do their action. Useful scenarios would be
ColoredPosition with regular GrObj, or ColoredObj with regular
Position. [Later] Maybe new subclasses aren't needed, since this would
create a dual hierarchy for all other subclasses (i.e. there would
have to be a regular FixPt and a ColoredFixPt). Part of the state of
both GrObj and Position could be whether they have a color preference;
if so, they use it, and if not, they use the current color when they
are drawn. [15-Jul] Aha! I think I've got it... there should be a
class GLAttributes that can specify things like foreground/background
color, line width, etc. and one subclass could be a null subclass that
just does nothing; a virtual method setAttribs() would arrange to set
all of the attribs controlled by the class (but how to unset them?
would be nice to use constructor/destructor via lexical scope). Then
both GrObj and Position could contain a GLAttributes member which
would control the appropriate attributes, if any. [3-Aug] What is
needed is a good abstraction to model what happens when a trial is
rendered. In particular, how to represent, say, that we should go to a
Position, then draw a GrObj, then un-go from that Position, then go to
a new Position... We need some kind of a GraphicParticipant class,
that has begin() and end() functions, that is able to capture at once
the current Position and GrObj classes, as well as the forthcoming
GlAttributes class. I guess this is the composite pattern-- which we
can use to build an arbitrarily nested list, or tree. 

(8-Jul-1999) Idea: have TclCmd's be able to return doc strings; then
TclCmd or TclPkg would store a list of all registered commands, so
that a special help command (like '?') followed by a command name
could return its help string. This would be nice since the various
intermediate command classes could provide default
doc-strings. Subclasses could either append, or override, their
superclass's doc-string.

(3-Jul-1999) Tlist makeSingles, etc. could now take a sequence/list of
objids as an optional argument utilizing TclCmd::getSequenceFromArg.

(3-Jul-1999) Need to correctly handle widget destruction within the
ObjTogl package. The problem is that if a new Togl widget is created
and then destroyed, the "offical" Togl widget (the singleton) is no
longer the current glX rendering context... perhaps there should be a
line in both the create and destroy callbacks that resets the
"official" widget as the glX-current context.

(30-Jun-1999) How to late-bind error strings and other string
literals? Put them in a separate compilation unit, register them
through id's... it's no fun to have to recompile everything just to
change one lousy string literal.

(25-Jun-1999) Just realized how dynamic loading should work for grsh:
all of the lists, plus all of the base classes that are held by the
lists, need to be statically (or at least permanently dynamically-)
linked into the grsh executable. These would be the so-called 'core'
modules. Any of the separate Tcl packages should contain the subclass
(such as Face) and the TclPkg to work with that subclass (such as
FaceTcl)... these units can then be loaded with the Tcl "load"
command, and would be called 'extensions'. Dependencies between any of
the extensions should be avoided. This hierarchy urges strongly for
all the base classes handled on the lists to be abstract. The problem
right now is the issue with bus ergrors due to OpenGL calls from
dynamically-linked modules--most of the 'extensions' will use OpenGL,
so this probably makes them unable to be dynamically loaded.

(30-Jun-1999) Really need to get an iterator working for
PtrList's... and get rid of these pseudo-working Id's. OK, now have an
iterator class implemented, but how to construct them? Specifically,
I'll need to be able to construct iterators from int id's, but then
what to do if the int is an invalid index? Throw an exception? Leave
the iterator in a corrupted state? Also, basically all of the PtrList
operations should use iterators... addPtr() should return an iterator,
remove() should take an iterator.

(28-Jun-1999) Need way for TclCmd's to "own" TclEvalCmd's, so that the
Tcl_Interp* management can be hidden from the client.

(27-Jun-1999) could perhaps use TclCmd again in KbdResponseHandler to
wrap up the event binding... this would allow for exceptions during
the event handling.

(24-Jun-1999) Would be nice to define some sort of appropriate
inheritance semantics for CTclPkg's... so that CTclPkg<B> can inherit
from CTclPkg<A> iff B inherits from A, and furthermore that this
inheritance does "all the right things".

(22-Jun-1999) Ugh. Spent all day tracking down idiotic pointer
problems. Should really use vector<unsigned char> rather than C-style
arrays to hold the info in Bitmap's and Pbm's, and use checked access
through at() especially when algorithms are untested.

(21-Jun-1999) Would be nice to arrange things so that GL coordinates
correspond to degrees of visual angle... really nice.

(15-Jun-1999) Bitmaps need to have attribs for glPixelZoom() and other
operations that can affect pixel rendering... should these be placed
in a separate Position subclass?

() :) :) :) Would be _really_ nice to have a file translator in Matlab
that could read the Expt files...

() There are dependencies in tlisttcl.cc on GrObj and Position that
are due to the Creational functions that are present in that file, such
as MakeSummaryTrial, MakeSingles, etc... These are the things that
should be solved with a Creational design pattern such as Abstract
Factory or Builder.

() Would like to change event binding from eval'ing Tk's "bind"
command to using the API function Tk_CreateEventHandler. But there is
a problem with multiple possible matches to a single event -- whereas
"bind" calls the most specific binding, who knows what happens with
event handlers???

() An idea for a more generic way to describe Trial's: rather than
explicitly storing objid/posid pairs, Trial's could store sequences of
events (this overlaps my previous idea about using events to describe
trial timing). One particular *type* of event then could be
DisplayObjectAtPosition (or something less wordy). This event would
store the objid and posid (or maybe GrObj* and Position*) and would
know how to display itself. The events would have in common an
action() function or something similar. Problem: who stores the
references to ObjList and PosList that make posid's and objid's work?
Currently it is Trial's, but with this new scheme there would have to
be one for each DisplayObjectAtPosition event, and with several of
these per Trial, and perhaps thousands of Trials in an Expt, this
means many thousands of references, all of which are pointing at just
one or two ObjList's/PosList's. This seems somewhat excessive. What to
do ...? [Later] This latter problem has been solved by making ObjList
and PosList singletons.

() Observer/Notifier -- need to change private variable access
to accessor function. This provides an easy hook for notify. Further
it hides the distinction between a variable and a computation.

figure way for ObjList and PosList to notify Trials or Tlist when
GrObj or Position is deleted. Then Trial should remove that (objid,
posid) pair from its list. Possibility: have GrObj and Position
implement a Notifier interface, where clients subscribe to the object,
then the object has a notify() procedure that sends a message to each
of its clients. Contents of message might be "I've changed" or "I'm
destructed". Or... have ObjList control the notification since Trials
only know about objids and posids. PtrList could maintain an array of
info that is parallel to the stored pointers. This array could contain
sets of clients for each id. Have to think carefully about how this
structure could be maintained through serialization.

Or... do pseudo-smart pointer stuff within PtrList. Whenever some
client is going to hold on to an id within the PtrList, it must "check
out" the id. This would increment a reference count within the
PtrList. Ptr's with a non-zero ref count are not allowed to be
delete'd or overwritten. This is I guess just a simpler version of
maintaining a list of clients--it doesn't allow for any messages to be
sent back to the clients.

On third thought, this is a deep design issue. The question is, who
owns the GrObj's and Position's? Who can delete them?


() Add functionality to Tlist to extract statistics from the
experiment. Add functionality to Trial's to extract statistics from
themselves. Question: how to deal with the issue of whether to lump
two Trial's together? Such as mirror-image pairs? Also, how to
implement the statistical algorithms in a generic way? Would be nice
to have iterators over Trial's (where each val is a response, or a
response_time) and over Tlist's (where each val is a Trial). Then
could use functors to be applied to each object and extract some info
from each.

() add "login" for subjects to make sure directory is correct

() Implement GLenums with something other than STL maps. Probably
best to use Tcl_Index API's, to search for matching string in array,
and retrieve its index.

() Trial's should hold more info-- in particular, they should know
their own correct response, or at least have a virtual function to
determine if a particular response is correct/valid or not. The
derived classes could be "BinaryTrial", "AnalogTrial", etc. This would
avoid having to implement the feedback/correctness check at a high
level. Also, Trial's might know their own timing info, although they
may not necessarily implement the timing themselves.

() Maybe Position should be migrated to an abstract base class, with
the current Position class becoming StaticPosition or
FixedPosition. What would a Position subclass for moving objects look
like?

*** BACK ***

*********************************
***                           ***
*** BOTTOM of completed stack ***
***                           ***
*********************************

(30-Nov-1999, done 7-Jan-2000) What to do about 'control reaching end
of non-void function' in ExptDriver::Impl::block(), responseHdlr(),
and timingHdlr()? Probably the best is to eliminate the error checking
in block(), responseHdlr(), and timingHdlr(), and require that the
id's be checked with assertIds() before these functions are called. We
can add an Assert to this effect inside block(), etc. Done.

(11-Jan-2000, done 11-Jan-2000) Need to have quick Tcl access to the
current trial id. Probably an Expt::currentTrial command for Tcl.

(14-Jan-2000, done 14-Jan-2000) There is some weird problem with
TlistWidget, perhaps?  Ah yes... first, we didn't initialize
itsCurTrial and itsVisibility in the constructor, and second of all,
we didn't check for itsVisibility in safeDrawTrial() before attempting
to draw.

(14-Jan-2000, done 14-Jan-2000) Need to flesh out the Pipe class that
has been introduced in Bitmap::loadPbmGzCmd(). OK, this is done so now
the Pipe class itself provides access to an fstream& that can be used
to read/write from the Pipe as appropriate.

(6-Dec-1999, done 16-Jan-2000) Do we also want Canvas& arguments in
the bounding box call chain? I added a Canvas& argument to
GrObj::getBoundingBox(), but not to the protected
GrObj::grGetBoundingBox()... the only subclass that needed a Canvas in
order to implement this function was Bitmap(Rep), so for this
implementation I just retrieve the Canvas from the
Application->Experiment->Canvas call chain. Thus GLCanvas::theCanvas()
is eliminated.

(11-Jan-2000, done 20-Jan-2000) Need a way to defer loading of pbm
files from when Bitmap's are deserialized until when they are first
used. This would require a way to for the files to be loaded on
demand. It would have the added benefit that in an fMRI script, we
would only have to load the bitmaps that are actually used in the
experiment. Done using BmapData to handle the actuall caching process.

(8-Feb-2000, done 8-Feb-2000) Should think about doing dynamic tracing
generically, perhaps with a mixin base class. This is basically done
by using Util::Tracer.

(27-Jun-1999, done 13-Mar-2000) Maybe Response's want to be first
class objects rather than lowly int's? This would allow the class to
have a static member InvalidResponse... would allow subclassing of
responses... would allow different ResponseHandler's to work with
different Response subclasses... Interestingly, the creation of a
Response requires input from both ResponseHandler (for the semantic
value) and from the TimingHandler (for the response time) --> trying
to implement Response would probably raise some important design
issues. Actually, I think I do have a simple Response struct that is
just local to Trial's right now.

(3-Mar-2000, done 20-Mar-2000) Ugh. I just now realized how much time
it takes to compile STL headers. In the past, I didn't try to
forward-declare STL templates since their declarations can vary by
compiler... but I now realized (duh!) that (by using an extra level of
indirection) I can use a "stringfwd.h" file that correctly declares
string, depending on the compiler. On a tiny test file, this reduces
the compilation time from about 15 sec to only 1-2 sec !!! So I've
created "stringfwd.h" and "vectorfwd.h", and I'm going to try to use
these exclusively when a declaration is needed in one of my header
files. One issue is that of default arguments... these cannot be used
unless the full class definition is known. This particularly affects
uses like 'const string& s = ""', but I think the problem can be
easily circumvented by removing the default argument, and adding
instead an overloaded function version with no string
argument. [8-Mar-2000] Well, now, a week later, the compile time for a
full debug build of the project has been cut nearly in half, and
"stringfwd.h" is no longer needed at all!  I've found that most
interfaces can use 'const char*' just fine, and let clients and
implementors deal with more complex string classes if they so
choose. Only 12 translation units now depend on <string>, and 21 on
<vector>. [20-Mar-2000] Decreased those numbers even more now... only
5 translation units depend on <vector>, 9 on <string>, 3 on <map>, 1
on <list>, and 1 on <set>.

(21-Mar-2000, done 22-Mar-2000) We need some sort of versioning
facility for Reader/Writer. OK, but how do we handle versioning
separately for base classes? Right now, base classes are handled ad
hoc, with subclasses calling their superclass's writeTo() method from
within their own writeTo() method. OK, I've added readBaseClass() and
writeBaseClass() methods to Reader and Writer. This allows base
classes to be written inline, with a bracketed block of the base
class's attributes treated as a single attribute for its containing
class. (In principle, we could now handle owned/contained objects in
this same way). In order to correctly write base classes, we first
needed some way to pass the base part of an object as an IO* while
ensuring that the correct overrides of readFrom()/writeTo() would be
called (i.e. avoid calling the most fully derived version of these
functions). This can be done with the IOProxy template, which holds a
pointer to an object of class C, and forwards all IO functions to the
C:: versions of those functions. So we can pass an IOProxy<Base>* to
the readBaseClass() and writeBaseClass() functions in order to achieve
the desired effect. Another structural change was to allow
AsciiStreamReader to maintain a stack of attribute maps, so that we
can represent arbitrarily deep nesting hierarchies of objects. This
involved just changing itsAttribs from an AttribMap to a
slink_list<AttribMap>. Finally, we needed to allow the string enders
('^') that occur inside a base class's attribute to be ignored when
the end class's attributes are being read... to do this we introduce
the convention that {}'s protect ^'s, so in order to have reached the
end of an attribute, we must see a '^' and be at brace level 0. This
in turn required that {}'s be treated specially--they must be escaped
with '\' when occurring within an attribute string. 

(28-Mar-2000, done 29-Mar-2000) Need to implement SerialRh (response
handler). This will share a lot of code with EventResponseHdlr, so we
probably need to create a base class for both such as FeedbackRh that
will handle the inputResponseMap and the feedbackMap but will delegate
attend() and ignore() via abstract functions. ... [Later] OK, so in
fact we don't need a new ResponseHandler class; instead we can add a
new event source that translates incoming serial port characters into
window-system events via Tk_QueueWindowEvent.


========================================================================
GOAL #1 -- done 11 May 2000

Goal: ExptDriver should not have to know anything about TimingHdlr's
or ResponseHdlr's. Done!

To do this, as usual we should try an easy migration path.
1) make Trial an abstract class, and move current Trial implementation
into a derived class
2) set up abstract Trial functions to take on behavior of Experiment
functions. At first, ExptDriver can just forward stuff to Trial so
that we don't have to redefine the handlers' interfaces right away.

(24-Jan-2000) More flexible behavior by putting trial behavior in
Trial rather than in ExptDriver.

(9-May-2000) I think I may finally have my hooks into this
problem. Branched off behavior from edBeginTrial() into
edDoTrial(). Added Trial::trDoTrial(), which is called from
edBeginTrial(). For now, trDoTrial() just calls right back to
edDoTrial(), mimicking the previous behavior exactly. But... now we
can slowly migrate the behavior from edDoTrial() back into
trDoTrial(). Then this process can be iterated for the other
Experiment:: functions. Eventually this will allow us to create a
Trial base class with these new functions as virtual functions, so
that we can create Trial's with very different behaviors (e.g. a
ball-tracking trial, or a delayed-match trial).

(12-May-2000) The way things look now, there is fairly clean
separation amongst the different experiment participants. Basically:

                                ___________________________________
                               |                                   |
                               V                                   |
 Experiment ---> Block ---> Trial ---> Response     Timing       Trial
            <---       <---       <--- Handler   +->Handler ---> Event
                               |                 |                 
                               |_________________|

Importantly, this means that we can treat ResponseHandler, TimingHdlr,
and TrialEvents as implementation details of Trial... so that can now
substitute in other Trial subclasses with different behaviors.
------------------------------------------------------------------------

(15-Jan-2000, done) I think the executable shouldn't have to depend on
the shared libraries, since these should be able to be change without
forcing a relink on the main executable. ... Yes, but we need to be
able to account for whether static or dynamic linking is being used.


(16-Dec-1999, done) Try to fix ToglConfig::loadFonti on irix by
switching fontnumber to a long before casting to char*. Tried
it... didn't work.

(done 19-Sep-2000) Want an indirection for auxiliary files so that the
complete pathname is not hard-coded. To do this kind of added
indirection (e.g. for now-hard-coded sound files, etc.), we can
require an environment variable like GRSH_LIB_DIR to point to the root
of a directory tree that will hold all auxiliary files for grsh
programs. This can include the current contents of face/faces_triads,
and face/audio, plus probably some other new goodies.

(note 22-Sep-2000) Looks like I now have a new architecture to target:
irix6 w/ MIPSpro compiler. The MIPSpro compiler looks to be fairly
C++-standard compliant. It would be nice to have a separate build for
that compiler... might be faster, also might allow c++ exceptions in
shared libraries. But, this is something to try only after I get
everything compiling cleanly with g++ again (following the upgrade to
irix6.5 from irix6.3).

(done 23-Sep-2000) OK, I figured out from a post on DejaNews that the
problem on the sgi is that sgi's libGLU was implemented partially in
c++ and compiled with MIPSpro; due to incompatible ABI's, this code
cannot be linked with code compiled by g++. So, I have two options: 1)
compile a version of OpenGL using g++, or 2) figure out how to get
MIPSpro to compile my code. For option 2), I guess I can just use
reinterpret_cast (which I'll define as SGI_IDIOT_CAST)... and keep my
fingers crossed. ... OK, now I've done five hours of porting so that
everything compiles/links/runs ok on curie using MIPSpro. I have a few
bugs to wrinkle out however. And, this effort has provided an impetus
for becoming more standard-compliant, with regard to the 'std'
namespace, and the new IOStreams library.

(done 23-Sep-2000) Bug on the new irix build of grsh--the application
crashes on exit (something in EventResponseHandler::ignore()). OK,
this is due to the fact that ignore() tries to use itsWidget, but the
ToglConfig has already been destroyed by the time we try to use
it. This is fixed by adding forgetWidget() and forgetTrial(), which
set the pointers to null at the end of a trial or when the experiment
is halted.

(done 24-Sep-2000) Hey... something good came out of this whole sgi mess:
now I can use shared libraries on the sgi, since MIPSpro allows
exceptions to work correctly with shared libraries.

(23-Sep-2000, done 24-Sep-2000) Bugs on the new irix build of grsh:
togl widget won't run in rgba mode. ... OK, this was due to the hack
that I had set up to force colormaps to be set, in which the colormap
was set recursively up the window parent chain. But, trying to set a
colormap on an rgba window makes no sense, and this is what was
causing the BadMatch error. In any case, that hack is not needed in
rgba mode, so I added a check for the widget's itsRgbaFlag before we
start setting colormaps.

(nix 24-Sep-2000) make startup procedures figure out if X server is
available
