$Id$
"Make it run, make it run correctly, make it run fast"

*** FRONT of priority queue ***

========================================================================
Resource management revisited 17-Oct-2000

(1-done) Generalize Factory so it can take a creation function. Make
    class constructors protected and add make() creation functions
    instead.

(2-done) Aha! We can get rid of MasterPtr.... IoObject itself should
    handle the reference counting. Then PtrHandle<T> of different
    types can be assigned to each other, DynamicCast'ed, etc., since
    the pointee's (IoObject*'s) will be related through inheritance.

    In detail
    (done) MasterPtrBase becomes RefCounted
    (done) IoObject inherits from RefCounted
    (done) VoidPtrHandle manages RefCounted
    (done) PtrListBase manages RefCounted
    (done) PtrHandle<T> holds T* (derived from RefCounted) directly
    (done) NullablePtrHandle<T> holds T* directly
    (done) get rid of masterptrt.cc

(3-done) Make sure nobody is writing PtrList ids in writeTo().
    (done) Block
    (done) Trial ... this is tricky. Need to refactor the implementation
		  to store two vectors of GrObj's and Position's, I think. Only
		  client of beginIdPairs() is TlistUtils::writeMatlab(). That
		  can change to use an iterator over the GrObj's instead. Will
		  need to have a dummy IdPairSpoofer structure in the
		  implementation to allow us to read older files.
	 (done) ExptDriver

(4-done) Migrate all old experiment data-files over to this new format
    that will not include PtrList's. I'll make a snapshot of the
    system so that we can get back to the state that can convert
    between old+new format. Then I'll rev the project version and cut
    out the old format code so that the IO code doesn't get too messy.

(*) Make the C++ side independent of PtrList's. Block's need to store
    Trial*'s (or ItemWithId<TrialBase>'s), and ExptDriver needs to
    store ItemWithId<Block>'s.

    (done) block.cc      on tlist.h
    (*) exptdriver.cc on blocklist.h
    (*) eventresponsehdlr.cc on soundlist.h
    (*) trial.cc      on rhlist.h
    (*) trial.cc      on thlist.h

    (*) exptdriver.cc on objlist.h (IO only)
    (*) exptdriver.cc on poslist.h (IO only)
    (*) exptdriver.cc on rhlist.h (IO only)
    (*) exptdriver.cc on tlist.h (IO only)
    (*) exptdriver.cc on thlist.h (IO only)
    (*) tlistutils.cc on objlist.h (OK for now--no dependence in interface)
    (*) tlistutils.cc on poslist.h (OK for now--no dependence in interface)
    (*) tlistutils.cc on tlist.h (OK for now--no dependence in interface)

(*) Make the IoMap. When an IoObject is constructed, we put its
    id+address into the map, and when it is destroyed, we remove it
    from the map. We need functions to iterate through the map, to
    test if an id is valid, to return the count of objects.

(*) Make the PtrList's just a simple wrapper for IoMap. In essence,
    PtrList's provide a correspondence between an integer id and an
    object. IoMap will do the same, therefore, we should be able to
    reimplement PtrList's in terms of the IoMap. This will be a
    temporary stage only, to allow us to migrate old data files.

    (*) We will need a mapping (std::map?) from PtrList id's to IoMap
        id's. 

    (*) insert() should add an entry for the object's ioId().
    (*) remove() just removes reference to the object's ioId().
    (*) Spoof the capacity() function.
    (*) Spoof the reset() function.
    (*) Spoof the release() function?
    (*) Implement isValidId().
    (*) Implement count().
    (*) Implement getPtr()...
    (*) Implement readFrom()/writeTo()??? What would these do? For
        data conversion, we need to be able to read the old
        format. Actually, this should work fine in a naive
        implementation... as we read the objects in from the stream,
        they automatically go in the IoMap when they are created. Then
        we store their ioId()'s in our PtrList id<-->ioId map.
    (*) Implement insertValidIds().

(***) An important intermediate goal is the state where the PtrList's
    are still physically in place, but all of the id's in existence
    are just the plain IoId's. ... Maybe this is not really a useful
    stage. I think once we are at the point where this stage is
    feasible, we'll just be wanting to finally ditch the PtrList's.

(*) Perhaps a special IoMap iterator type would see only certain
    subclasses of objects. This would likely be a template.

(*) Expose incrRefCount and decrRefCount to the Tcl side. These
    actually shouldn't be needed much. In most cases, a Tcl command
    will create a new object with a ref-count of 0, and then this
    object will immediately be added into the object hierarchy at some
    point, causing its ref-count to be incremented (e.g. creating a
    Face, then adding it to a Trial). This will work as long as we do
    not purge the IoMap in between the Tcl calls.

(*) Reimplement ItemWithId and NullableItemWithId in terms of IoMap.

(*) Make sure there is a snapshot of the project that can read old
    files (i.e. with PtrList's) but also write new files (w/o PtrList's).

(*) ObjList::LoadObjectCmd can be replaced with something generic that
    works for all IoObject types.

(22-Oct-2000) I see the elimination of PtrList's in the
future. Instead we can maintain a map of ioId()'s to IoObject*'s. This
can be managed in the constructor+destructor for IoObject. This map
could be purged of refcount-0 objects on command. The map would allow
us to do similar operations to what the PtrList's provide now. For
example, find all objects of a given type.

(18-Oct-2000) Aha! I have a vision... the PtrList's do not need to be
serialized at all... they can become merely a runtime resource that
expose C++ objects to Tcl. This will be possible if C++ objects
serialize not object-id's, but rather actual object references. Then
the id's will be automatically reconstructed when the objects are read
back in. This requires some support for master pointers in
reader+writer. Also this is the final death blow to the LegacyWriter
format, since we don't have any way to support reference semantics
there. We might still be able to support LegacyReader, however.

(17-Oct-2000) Only ...tcl.cc files and exptdriver.cc (?) should depend
on the PtrList singletons and hence the "objlist.h" etc. include files.

(17-Oct-2000) Move ItemWithId<T> and NullableItemWithId<T> off into
their own component. Most C++ clients should not have to rely on
PtrList directly, or access any of the singletons.

(17-Oct-2000) Make C++ clients of getPtr() and getCheckedPtr() just
store an ItemWithId<T> instead.

block.cc (Trial)
eventresponsehdlr.cc (Sound)
exptdriver.cc (Block)
objlisttcl.cc (GrObj)
tlistutils.cc (GrObj, Trial,...)
trial.cc (ResponseHandler, TimingHdlr)

(done 17-Oct-2000) ItemWithId<T> could store a static PtrList<T>&,
which would allow us to construct an ItemWithId<T> from a MasterPtr
only, and insert this MasterPtr into the PtrList from within the
ItemWithId structure. Done.

(done 17-Oct-2000) Make PtrList::insert() functions return an
ItemWithId. This is a first step to eliminating reliance on the int
id's in the C++ side of things. Done.

------------------------------------------------------------------------

(11-Oct-2000) Put more behavior in Tcl::SafeInterp. This functionality
would be able to be used in many places.

(8-Jan-2000) How to read/write CountedPtr's? This is the big barrier
to establishing CountedPtr's as a better way to manage objects between
C++ and Tcl. Probably Reader/Writer need a special method for
CountedPtr's. The question is how to keep track of the pointers to the
reference counts. Or... we could put the reference count right in
IO... Aha! Instead of AsciiStreamReader maintaining a map<unsigned
long, IO*> during deserialization, we could use a map<unsigned long,
CountedPtr<IO> >. However, this introduces a split from the semantics
of readOwnedObject()... this suggests that we need a separate map for
owned objects. As this transition will require a nearly universal
switch to CountedPtr's, we need to provide a feasible migration route,
perhaps by providing the ability to short-circuit CountedPtr's
ref-counting at first.

(9-Oct-2000) Could refactor EventResponseHdlr and Trial by using a
state pattern instead of an enum TrialState.

(5-Oct-2000) Add zstream to Pbm.

(10-Oct-2000) Start reaping the benefits of my PtrList ref-counting
refactoring by allowing clients to lock onto their resources using
ItemWithId<T>.

(10-Oct-2000) PtrList could do an "idiot check" on insert to make sure
that we aren't storing the same pointer in two slots. If this happens
with the same MasterPtr, we can just return the previous MasterPtr;
however if it happens with two MasterPtr's pointing to the same
object, then it is a bug which will result in memory corruption.

(10-Oct-2000) Make the factory functions return PtrHandle's or
MasterPtr's.

========================================================================
"Dynamic templates" 4-Oct-2000

(4-Oct-2000) I like the idea I saw in the CUJ that dealt with
deferring the template nature of something. Basically a generic
interface is provided in a derived class, like

class Impl { public: virtual ~class Impl(); };

template <class T> class TImpl : public Impl { public: T data; };

class Interface {
public:
  template <class T>
  T getT() {
    TImpl* tptr = dynamic_cast<TImpl<T>*>(itsImpl);
    if (tptr) return tptr->data;
    else { throw "..."; }
  }

  Impl* itsImpl;
};

This allows Interface to gain some of the benefits of templates, but
doesn't require the entire class to be templated, only the getT()
function. If there a long chain of templates involved, this technique
might be able to defer the templated-ness to the last class in the
chain, for example. This is a particular benefit if there are virtual
functions involved, since it allows us to avoid having vtables laid
down everywhere.

As a practice before I move on to a more heavy use of this approach, I
bet I can use this approach to eliminate the use of void*'s in the
implentation of the TclPkg hierarchy. Ugh. I just realized that this
is basically skirting around the idea of just using a
mother-of-all-base classes approach, such as deriving everything from
Object. The template idea is just a way of grafting on the MOAB to a
preexisting object hierarchy. ... except that the template approach
does allow non-objects to be included, such as native types,
pointer-to-members, etc.

I think I should be able to get some benefit of this in my TclPkg
hierarchy. For example, PropertyInfo would not have to be a template
class; instead, PropertyInfo::property() would just have to be a
template member function, along with a template constructor.

*) Turning PropertyInfo into a non-template class allows us to turn
   the get getPropertyInfos() interface from an ad-hoc interface to a
   dynamic, polymorphic interface.

*) PropFriend would have an non-template base class that would define
   the functions set() and get(). These would be implemented in a
   template class that used dynamic casts to get the type information
   back out.

*) CPropertiesCmd would not have to be a template.

------------------------------------------------------------------------

(2-Oct-2000) Add a validateObject() method to the IO interface, that
can be called after an object is deserialize? This would allow us to
split the common validation code out of legacyDesrlz and readFrom
methods, and would also increase the homomorphism of the readFrom and
writeTo methods.

(29-Sep-2000) Revisit legacyValidTypenames()... this is only used in
   the PtrList hierarchy. Maybe there is a more direct/efficient way
   to handle this. We could have a map<string, list<string>> that
   would relate typenames to lists of alternate typenames. The list
   could be built at runtime by having clients install their info into
   the map, or we could just have LegacyReader "magically" know the
   correct typenames.

(29-Sep-2000) LegacyReader could probably remember the state and
   handle the braces as well. Actually, LegacyReader could just "know"
   how to handle Face and MorphyFace...

(28-Sep-2000) fixed_block and dynamic_block should have release()
members, so that we can use them for exception-safe storage, then
transfer ownership of the buffer to someone else once the operations
are safely completed.

(28-Sep-2000) Why do we occasionally get EventRH: itsWidget is NULL
when the ExptDriver general sanity test fails?

(28-Sep-2000) Why does irix occasionally core-dump during Face testing
in GrObj::invalidateCaches()?

(24-Sep-2000) Big categories: 1) memory management, 2) screen update
hierarchy, 3) experiment event sequence, 4) automate data analysis, 5)
automate series of experiments, 6) untangle the mess that is
GrObj::Impl.

(23-Sep-2000) Should have a log-file that can catch non-essential
messages (such as the timing info that is emitted by TrialEvent
destructors). 

(23-Sep-2000) Need a platform-independent way to find black/white
color indices (could be implemented as Togl:: functions).

(21-Sep-2000) A new subclass of Reader/Writer could handle exporting
data in a format suitable for Matlab use, perhaps.

(12-Sep-2000) Would be nice to have some sort of resource/message
loading, so that we could put strings in a separate resource file.

(7-Jul-2000) Adding an 'itsCorrectVal' member to Response. Should this
value be serialized? We don't have a good way to do versioning of
Value types that are written/read with printTo()/scanFrom().

(22-May-2000) Need to have a way to destroy the pause keybinding when
an experiment is done. The problem is, ExptDriver shouldn't know about
the names of the Tcl commands that run it... therefore we don't want
ExptDriver to create/destroy bindings to "Expt::pause".

(28-Mar-2000) The Togl widget can take over its own event dispatching
by calling Tk_CreateEventHandler; then we can add event bindings to
the widget using C++ only, without having to use Tcl script code.

(16-Mar-2000) Block should have a parameter (or virtual function) to
control what happens on abortTrial()... i.e., should we reschedule the
trial, ignore the trial, record an invalid response?

(20-Jan-2000) We should set up a way for Trial's to have a prepare()
function which would do things like update its GrObj's (and flush
pending requests like loading bitmap data). Then Block's could have a
prepareNextTrial() function which could be called during the preceding
trial.

Goal: ExptDriver shouldn't have to know about any lists except maybe
BlockList. As for serializing, the lists should register themselves
with ExptDriver at application startup. Experiment base class should
declare an abstract manageObject(const char* name, IO* object)
function. The lists should call this in in their
Tcl_PkgInitProc's. The problem with this approach is that we lose the
ability to control the order in which the lists are read/written
through the IO interface. This is not so much a problem for the
readFrom()/writeTo() interface, as this is designed to be
order-independent, but it is a problem for the
serialize()/deserialize() interface. Perhaps we could use some ad hoc
strategy to make sure that the managed objects are written in the same
order every time (based on their ioTypename() for instance?).

========================================================================
GOAL #2
(24-Jan-2000) Allow a more flexible description of the scene graph, a
la Open Inventor.

This is now particularly important as Trial's take on more
behavior... they shouldn't be used anymore as a way to store
combinations of objects.
------------------------------------------------------------------------

========================================================================
GOAL #4
(24-Jan-2000) Develop a more coherent view of the screen-update model:
Who gets to do it, and when?

(2-Oct-2000) The first step in this is to eliminate any direct
attempts to draw to the screen, other than by a Widget object (such as
TlistWidget). Others who want the screen updated should do so
indirectly by requesting the widget to redraw itself.

------------------------------------------------------------------------

========================================================================
GOAL #5
(15-May-2000) Improve the overall timing accuracy of the software.

(29-Nov-1999) TrialEvent's could internally adjust their requested
delays so that the actual delays converge to the requested
delays. This would require some care to ensure that we don't send the
entire system into an unstable oscillation. We'd maintain two values:
itsIdealDelay, and itsRequestedDelay. The ideal delay remains
constant, but we modify the requested delay based on experience to try
to get the actual delay to meet the ideal delay. There are several
strategies we could use to make these adjustments-- one would be to
try to minimize the total timing error of the TrialEvent, another
would be to minimize the average absolute value of the timing
error. [Later] We could also control the timing more globally... where
a block or experiment knows how long it is supposed to last, then
timer events report to the block how long they requested, and how long
they actually lasted. Then the block could adjust the requested times
for future trial events in order to compensate.

(done 14-May-2000) Implemented error-checking and adjustment in
TrialEvent's. This gives very good accuracy (+/-1msec average per
trial) over an experiment. Still need to control this error-checking
from script-level, and to provide a hint to the TrialEvent at
construction time.

(15-May-2000) Need to include info about timing throughout the
experiment object hierarchy, from Experiment, Block, and Trial, to
TimingHdlr. Each object should know its allotted time, its expected
error, and should compute its actual error and use this to give
feedback to someone in order to improve future timing. Experiment and
Block don't have too much control, but they can keep an overall view
of how the timing is going, and perhaps issue a request for future
trials to compensate their timing by a particular scale factor in
order to adjust for past errors.

(15-May-2000) Perhaps most usefully, Trial's should know their desired
length and give feedback to their TimingHdlr's so that the
TimingHdlr's can do a multiplicative scaling to compensate.
------------------------------------------------------------------------

========================================================================
GOAL #7
(16-May-2000) Make bitmap caching a more fluent part of the software.

(21-Mar-2000) Need to have a way to explicitly represent GrObj's with
cached-bitmap-file representations... this way we can have access both
to a GrObj's semantic properties (i.e. face width, nose length, etc.)
while still accessing it in a bitmap form. This would involve a
command to cache a GrObj to file, given a filename, and then the
object should automatically load that file when it is deserialized at
a later time.
------------------------------------------------------------------------

========================================================================
Subsection on refactoring ToglConfig into Widget, Camera, Canvas

(15-Jan-2000) ExptDriver should really own the widget (actually a
TlistWidget)... Then we can eventually have multiple Experiment's at
once, each with its own widget??? is this right?

(27-Nov-1999) Who uses theToglConfig()?
EventResponseHdlr uses the Widget part in the attend() and ignore() methods
ExptDriver uses the Canvas part it in swapBuffers().
ExptTcl uses the Widget part in BeginCmd, SetStartCommand,
ObjTogl uses the Widget Part in DestroyCmd.
ObjToglPkg uses it in getCItemFromId().
xbitmap.cc uses a special X11Widget subclass in init_class().

Eventually, we'd like to have a list of Widget's, with ExptDriver
maintaining the current one for an experiment, so that experiment
participants can request it from ExptDriver (or it passes the Widget
to them).

(27-Nov-1999) One important reason for refactoring all this stuff is
so that we can have more than one active Togl widget... then we can
improve user interface, e.g. bring up a dialog box to edit a GrObj,
etc.

(27-Nov-1999) It looks like there should be a Window/Widget class,
that contains a Camera and a Canvas. Or does the Camera need to
contain the Canvas? It seems like the Window will pass a redraw
request on to its Camera, which would need to have a Canvas reference
to pass to the graphic objects in order for them to redraw themselves.

(17-Nov-1999) The emerging Camera abstraction: includes some of the
ToglConfig functionality such as perspective or orthographic
projection, viewing distance, viewport, and which will be used by a
Window/Widget to handle redraws and reconfigures. A subclass of Camera
can carry the Tlist functionality such as setVisible(), setCurTrial(),
etc. Actually, it seems there are two different parts to camera: one
is the object/scene that it is viewing, and the other defines the sort
of projection that is used.

(17-Nov-1999) The emerging Canvas abstraction: could be passed to
GrObj's in their grRender() function. How does it relate to a
Window/Widget? Is it owned, referred to, etc.? Has a width+height.

(13-Sep-1999) Should change ToglConfig to a "Camera"-style interface,
a la Open Inventor. Then different types of camera's, such as
orthographic or perspective projection, could be related by
inheritance from an abstract base class Camera. Parameters include
viewing volume, autoUpdate (determines if scene is automatically
redrawn upon Expose or Resize events)...
------------------------------------------------------------------------


========================================================================
(29-Nov-1999) How to automate the data analysis? Need to bridge the
gap between output of Grsh program running experiment, and necessary
input to Matlab to process data. I think this is a possible route:

      1) expt completes and saves files

      2) a Grsh script runs and processes the data further, generating
         the data files that matlab needs, and also **generating a
         Matlab script file (.m file)** that we can run to process the
         data.
         
      3) Run the .m file to finish the data processing.

What input does this process need? We need to know the location of the
pairs/triads experiment file, and of the classification experiment
files.

Breakdown of classification process:

1) make incidence matrices (see make_inc_mat_mfaces_s50.m as example)
   from resp files.
2) run models (see run_mfaces_models.m as example)

Important data:

- base directory which contains subjects' individual directories
- name of subject (encoded as directory for subject)
- date of pairs experiment (to create pairs directory based on date)
- name for type of objects
- names of response files in probe experiments

Use case:
1) run experiments + collect multiple data files from several subjects
2) run mds analysis on results of similarity tasks
3) compile subjects' overall categorization results across all clones
4) fit various models to the categorization results
------------------------------------------------------------------------

========================================================================
(17-Nov-1999) Need a way to automate the experiment-running process to
do several things... [later] Aha! I see that this is just yet another
level of abstraction on top of block/experiment etc. In fact, there
might be two abstractions: one which defines a series of experiments
to be run together as a session (ExperimentSession?), in which the
next experiment might depend on the results of the previous one, and a
higher level abstraction which defines a series of sessions
(ExperimentSeries) that constitute an entire experiment, lasting
perhaps several weeks. An ExperimentSession probably requires only one
process, whereas an ExperimentSeries requires multiple processes to be
run, over the course of many days/weeks (and therefore requires the
help of some persistent data in the form of files in order to maintain
itself over the entire duration).

1) 'log in' a subject ==> change to the correct directory
2) run an experiment
3) move the experiment data files to appropriate names and chmod appropriately
   --> this requires ExptDriver() to provide the names of its most
   recently saved files
4) possibly repeat steps 2+3
   --> We can store a file that contains a list of experiment commands
   that should be issued. A separate file, called 'next_expt' can be
   updated to always contain the command needed to run the next
   experiment. When one experiment is completed, the driver rewrites
   the 'next_expt' file appropriately.
5) exit
------------------------------------------------------------------------

(22-Mar-2000) We could have a more compact reader/writer format by
using a system that wrote class definitions to the file, and stored
some sort of translator for each class in the reader/writer... this
would allow us to just store the raw data for individual objects,
without having to store the metadata over and over. [Later] the
generic version of this is that each read/write requires a per-class
translater, with the default being that the normal verbose translater
is used, but if a different translater is present, then that one can
be used instead.

(19-Jan-2000) GLBitmap should use auto_ptr for itsRenderer and fix
initialization order (eliminate tempRenderer). Same for XBitmap.

(19-Jan-2000) Does BitmapRep really need to implement grUnRender(), or
can we just use GrObj's GROBJ_CLEAR_BOUNDING_BOX mode?

(17-Jan-2000) We should have a TclVecItemCmd<C> template that parallels
TclItemCmd<C> but can handle vectors of items. Mainly it would need a
getItems() member that returns a reference to a vector<C*>. ... no,
better would be to have getItems() take an insert iterator. Actually,
there ought to be some way to get the base class to take care of most
of the iteration, so that the subclasses just need to define what to
do for each element. This would be similar to the way VecSetterBaseCmd
provides a partial implementation for TVecSetterCmd.

(14-Dec-1999) Need Canvas& arguments on GrObj::getBoundingBox,
GrObj::grGetBoundingBox, and Bitmap::grabScreenRect/grabWorldRect.

(14-Dec-1999) The implementation of GrObj should be moved into a
separate component since it is fairly heavyweight. Subclasses would
then be required to provide this implementation upon
construction. This method would allow clients, but not subclasses, of
GrObj to avoid dependencies on such components as bitmaprep, etc. But,
how to avoid having to make all GrObj functions virtual? We'd like
some to stay non-virtual. Aha! The new lightweight GrObj shouldn't
even have the grRender(), grUnRender(), or grGetBoundingBox()
functions... these will first be defined in GrObjImpl.

(1-Dec-1999) Unsavory dependencies:
  EventResponseHdlr on ObjTogl -- axed via Widget abstraction!
  EventResponseHdlr on SoundList
  ObjTogl on Tlist -- compilation dep gone, but still link dep
  Trial on ObjList, PosList?
  Block on Tlist?
  BitmapRep on GLCanvas::theCanvas()

... I see that this whole PtrList business introduces some wacky
  dependencies... I don't think C++ clients should be depending on the
  PtrList's directly. Instead, maybe the PtrList's should manage
  CountedPtr's or something similar, so that the integer indices are
  only visible in Tcl.

(14-Dec-1999) ExptDriver should really own the ToglConfig... maybe it
should arrange to create this as part of application startup?

(12-Dec-1999) Could have an abstract class for timer callbacks, one
subclass of which could use a Tcl_Interp* to register timer callbacks.

(3-Dec-1999) I have a potential type-system loophole with TclItemPkg
and TclItemCmd... TclItemPkg blindly casts TclItemCmd::getItemFromId()
from void* to T*, without any guarantee that TclItemPkg is dealing
with the correct type. Suggests we need a template wrapper around
TclItemPkg?

(22-Nov-1999) Hey, I think I might be able to totally do away with
PtrList's, at least in the public interface. I think that they could
be wrapped into the base class, so that every GrObj created is
automatically placed in the ObjList, and anytime a GrObj is destroyed
it is removed from the PtrList. This would just entail overriding
operator new + delete for that class. The class would have static
operations that mimic the PtrList's operations.

(22-Nov-1999) Need to get rjp_subject working. 1) Need to maintain a
do_expt script in each subject's directory. 2) Need to make sure that
autosave file is writable by rjp_subject, and if not, use a different
filename. (Maybe use temp filename generating facility of OS?).

(17-Nov-1999) Can we automate the use of Matlab for data analysis by
opening a pipe to a Matlab process from within Tcl?

(10-Nov-1999) Had an idea for allowing TclCmd's to be more
generic... define abstract classes of extractors, which provide ways
to get C++ types out of Tcl_Obj*'s. The native types would be
straightforward, but more interesting would be to define extractors
for STL containers... actually, would this give me anything more than
I have now with the various getXxxFromArg() methods in TclCmd? Answer:
Yes! -- it would provide a bit more modularity, since the extractors
would be separate from the commands, and new extractors could be
introduced without having to add a method to TclCmd by subclassing it.

(20-Oct-1999) There is a memory leak (I think) in
AsciiStreamReader::readCstring()... which returns a new char[] to a
client that may not be prepared to assume ownership.

(15-Oct-1999) There's a unifying force behind two things: 1) Tcl's
idea of dual representation-- native rep/string rep; and 2) idea of
serializing objects to a stream by converting them into a string
format. I don't know exactly what to make of it at this point, but it
seems like it could be useful... This is parallel to the duality of
makeIoList and getProperties()... these should really be
merged. Dual-rep objects (perhaps a new DynamicValue subclass of
Value) could be used in the implementation of AsciiStreamReader.

(14-Oct-1999) Gabor should have a patchWidth/patchHeight attribute,
that controls not the size of the object inside the patch, but the
size of the patch itself (i.e. how big the window onto the Gabor patch
is).

(11-Oct-1999) Could write a Widget class that encapsulates the details
of Tk widgets. Then we could extend with subclasses... for example one
subclass could be designed to edit Property's of another class.

(8-Oct-1999) GrObj should use Property's, so that GrObj attributes can
be added to the list of a subclass's attributes.

(6-Oct-1999) GrObj needs a saveBitmapCache() function to dump a cached
bitmap to file. Or maybe just a writeBitmap() function, that would
apply even for objects whose mode is not one of the bitmap cache
modes, and that would generate a temporary bitmap if
necessary. [Later] This stuff belongs outside of the GrObj class,
since it needs only the public interface... perhaps it should just go
in grobjtcl.cc file.

(6-Oct-1999) Should Property's be Observable's? Is this worth the
extra space? Perhaps only some properties should be Observable's. How
would this be done?

(5-Oct-1999) Maybe TimingHdlr should have a toggle switch to indicate
what the behavior should be when a response is seen. (Whether to
cancel StartEvents, etc.).

(2-Oct-1999) Property's could store a pointer to something like
ValChecker, which has a virtual function, that could variously do 1)
check whether new value is the same as the current value, 2) check
whether the new value is in bounds/valid. If the ValChecker* is 0,
then no check is done, and not much time is lost worrying about the
check. This would avoid the problem of trying to maintain parallel
hierarchies of Property, BoundedProperty, etc.

(2-Oct-1999) Eventually, it should be possible to declare all of the
necessary Tcl functions for a class with something like template<C>
initTcl(), which in turn would call C::getProperties,
C::getMethods... etc.

(2-Oct-1999) Should be able to call up a property info struct from a
class by giving it a string name of a property.

(29-Sep-1999) It would be nice, in the Value/Property scheme, to be
able to avoid triggering sendChangeMsg() when the value doesn't
actually change (e.g if the new value was the same as the current
value, or was out of bounds).

(20-Sep-1999) Fixed a nasty memory corruption bug that was due to
neglecting to set GL_PACK_ALIGNMENT appropriately before reading pixel
data out of the screenbuffer into main memory. Since the value for
GL_PACK_ALIGNMENT defaults to 4, it is not sufficient to allocate
(width*height) bytes if the row size is not divisible by 4. How to
avoid these problems in the future? Include a byteAlignment member in
Bitmap, add a utility function that reallocates appropriate space for
a given width and height.

(13-Sep-1999) It is becoming more urgent to set up dynamic loading of
Tcl modules, so that not everything must always be loaded when
starting up grsh.

(25-Jun-1999) Need a coherent way of handling colors............
[Earlier] Who should own foreground/background information? Seems like
it could belong to either or both of GrObj and Position. Maybe best
idea is to use ColoredObj and ColoredPosition as derived classes, if
necessary. Default behavior of non-colored classes would be to use
whatever color was active, while colored classes would set their own
color when they do their action. Useful scenarios would be
ColoredPosition with regular GrObj, or ColoredObj with regular
Position. [Later] Maybe new subclasses aren't needed, since this would
create a dual hierarchy for all other subclasses (i.e. there would
have to be a regular FixPt and a ColoredFixPt). Part of the state of
both GrObj and Position could be whether they have a color preference;
if so, they use it, and if not, they use the current color when they
are drawn. [15-Jul] Aha! I think I've got it... there should be a
class GLAttributes that can specify things like foreground/background
color, line width, etc. and one subclass could be a null subclass that
just does nothing; a virtual method setAttribs() would arrange to set
all of the attribs controlled by the class (but how to unset them?
would be nice to use constructor/destructor via lexical scope). Then
both GrObj and Position could contain a GLAttributes member which
would control the appropriate attributes, if any. [3-Aug] What is
needed is a good abstraction to model what happens when a trial is
rendered. In particular, how to represent, say, that we should go to a
Position, then draw a GrObj, then un-go from that Position, then go to
a new Position... We need some kind of a GraphicParticipant class,
that has begin() and end() functions, that is able to capture at once
the current Position and GrObj classes, as well as the forthcoming
GlAttributes class. I guess this is the composite pattern-- which we
can use to build an arbitrarily nested list, or tree. 

(8-Jul-1999) Idea: have TclCmd's be able to return doc strings; then
TclCmd or TclPkg would store a list of all registered commands, so
that a special help command (like '?') followed by a command name
could return its help string. This would be nice since the various
intermediate command classes could provide default
doc-strings. Subclasses could either append, or override, their
superclass's doc-string.

(3-Jul-1999) Tlist makeSingles, etc. could now take a sequence/list of
objids as an optional argument utilizing TclCmd::getSequenceFromArg.

(3-Jul-1999) Need to correctly handle widget destruction within the
ObjTogl package. The problem is that if a new Togl widget is created
and then destroyed, the "offical" Togl widget (the singleton) is no
longer the current glX rendering context... perhaps there should be a
line in both the create and destroy callbacks that resets the
"official" widget as the glX-current context.

(30-Jun-1999) How to late-bind error strings and other string
literals? Put them in a separate compilation unit, register them
through id's... it's no fun to have to recompile everything just to
change one lousy string literal.

(25-Jun-1999) Just realized how dynamic loading should work for grsh:
all of the lists, plus all of the base classes that are held by the
lists, need to be statically (or at least permanently dynamically-)
linked into the grsh executable. These would be the so-called 'core'
modules. Any of the separate Tcl packages should contain the subclass
(such as Face) and the TclPkg to work with that subclass (such as
FaceTcl)... these units can then be loaded with the Tcl "load"
command, and would be called 'extensions'. Dependencies between any of
the extensions should be avoided. This hierarchy urges strongly for
all the base classes handled on the lists to be abstract. The problem
right now is the issue with bus ergrors due to OpenGL calls from
dynamically-linked modules--most of the 'extensions' will use OpenGL,
so this probably makes them unable to be dynamically loaded.

(30-Jun-1999) Really need to get an iterator working for
PtrList's... and get rid of these pseudo-working Id's. OK, now have an
iterator class implemented, but how to construct them? Specifically,
I'll need to be able to construct iterators from int id's, but then
what to do if the int is an invalid index? Throw an exception? Leave
the iterator in a corrupted state? Also, basically all of the PtrList
operations should use iterators... addPtr() should return an iterator,
remove() should take an iterator.

(28-Jun-1999) Need way for TclCmd's to "own" TclEvalCmd's, so that the
Tcl_Interp* management can be hidden from the client.

(27-Jun-1999) could perhaps use TclCmd again in KbdResponseHandler to
wrap up the event binding... this would allow for exceptions during
the event handling.

(24-Jun-1999) Would be nice to define some sort of appropriate
inheritance semantics for CTclPkg's... so that CTclPkg<B> can inherit
from CTclPkg<A> iff B inherits from A, and furthermore that this
inheritance does "all the right things".

(22-Jun-1999) Ugh. Spent all day tracking down idiotic pointer
problems. Should really use vector<unsigned char> rather than C-style
arrays to hold the info in Bitmap's and Pbm's, and use checked access
through at() especially when algorithms are untested.

(21-Jun-1999) Would be nice to arrange things so that GL coordinates
correspond to degrees of visual angle... really nice.

(15-Jun-1999) Bitmaps need to have attribs for glPixelZoom() and other
operations that can affect pixel rendering... should these be placed
in a separate Position subclass?

() Would like to change event binding from eval'ing Tk's "bind"
command to using the API function Tk_CreateEventHandler. But there is
a problem with multiple possible matches to a single event -- whereas
"bind" calls the most specific binding, who knows what happens with
event handlers???

() An idea for a more generic way to describe Trial's: rather than
explicitly storing objid/posid pairs, Trial's could store sequences of
events (this overlaps my previous idea about using events to describe
trial timing). One particular *type* of event then could be
DisplayObjectAtPosition (or something less wordy). This event would
store the objid and posid (or maybe GrObj* and Position*) and would
know how to display itself. The events would have in common an
action() function or something similar. Problem: who stores the
references to ObjList and PosList that make posid's and objid's work?
Currently it is Trial's, but with this new scheme there would have to
be one for each DisplayObjectAtPosition event, and with several of
these per Trial, and perhaps thousands of Trials in an Expt, this
means many thousands of references, all of which are pointing at just
one or two ObjList's/PosList's. This seems somewhat excessive. What to
do ...? [Later] This latter problem has been solved by making ObjList
and PosList singletons.

() Observer/Notifier -- need to change private variable access
to accessor function. This provides an easy hook for notify. Further
it hides the distinction between a variable and a computation.

() Add functionality to Tlist to extract statistics from the
experiment. Add functionality to Trial's to extract statistics from
themselves. Question: how to deal with the issue of whether to lump
two Trial's together? Such as mirror-image pairs? Also, how to
implement the statistical algorithms in a generic way? Would be nice
to have iterators over Trial's (where each val is a response, or a
response_time) and over Tlist's (where each val is a Trial). Then
could use functors to be applied to each object and extract some info
from each.

() add "login" for subjects to make sure directory is correct

() Implement GLenums with something other than STL maps. Probably
best to use Tcl_Index API's, to search for matching string in array,
and retrieve its index.

() Trial's should hold more info-- in particular, they should know
their own correct response, or at least have a virtual function to
determine if a particular response is correct/valid or not. The
derived classes could be "BinaryTrial", "AnalogTrial", etc. This would
avoid having to implement the feedback/correctness check at a high
level. Also, Trial's might know their own timing info, although they
may not necessarily implement the timing themselves.

() Maybe Position should be migrated to an abstract base class, with
the current Position class becoming StaticPosition or
FixedPosition. What would a Position subclass for moving objects look
like?

*** BACK ***

(note 18-Oct-2000) I need to think a lot more carefully in the future
if/when changing file formats. As a one-user system, I think it is
reasonable to consider migrating all old data over to a new format
rather than trying to support multiple formats. Hopefully this is less
of a problem with ASW format than with the Legacy format. I need to
add a bunch of test cases that ensure that various old files
(e.g. from psychophysics, fMRI) are still readable with each version.
