# $Id$

import os, re, sys, operator

def sort(seq):
    seq.sort()
    return seq


# DirectIncludeMap class -- maintains a cached mapping between source
# files and lists of files that they directly include

class DirectIncludeMap:
    includeRegex = re.compile('^#\s*include\s*"(.*)"$', re.MULTILINE)

    def isFile(self, path):
        return os.path.isfile(path)

    def isNotFile(self, path):
        return not os.path.isfile(path)

    def resolve(self, rawIncludes, rootPathCopies):
        fullPaths = map(operator.add, \
                        rootPathCopies[:len(rawIncludes)], rawIncludes)

        resolved = filter(self.isFile, fullPaths)

        if len(resolved) == len(fullPaths):
            return (resolved, [])
        else:
            unresolved = filter(self.isNotFile, fullPaths)
            rootlen = len(rootPathCopies[0])
            for i in range(len(unresolved)):
                unresolved[i] = unresolved[i][rootlen:]
            return (resolved, unresolved)

    def loadDirectIncludes(self, file):
        theRegex = self.includeRegex

        f = open(file, 'r')
        text = f.read()
        f.close()

        unresolved = theRegex.findall(text)
        resolved = []

        for pathCopies in self.itsPathCopies:
            (newResolved, unresolved) = self.resolve(unresolved, pathCopies)
            resolved.extend(newResolved)

        if len(unresolved) > 0:
            sys.stderr.write("missing dependencies in file: %s\n" % file)
            sys.stderr.write("\twith search path: %s\n" % self.itsPaths)
            for dep in unresolved:
                sys.stderr.write("\t'%s'\n" % dep)

        self.itsIncludes[file] = resolved

    def __init__(self, paths):
        self.itsPaths = []
        self.itsPathCopies = []
        for path in paths:
            path = path + '/'
            self.itsPaths.append(path)
            self.itsPathCopies.append((path,)*200)

        self.itsIncludes = {}

    def get(self, file):
        if not self.itsIncludes.has_key(file):
            self.loadDirectIncludes(file)

        return self.itsIncludes[file]

#
# DepBuilder class
#

class DepBuilder:

    # private interface

    def addRecursiveDeps(self, target, rootdep):
        self.itsFullIncludes[target][rootdep] = 1

        for dep in self.itsDirectIncludes.get(rootdep):
            self.addRecursiveDeps(target, dep)

    def visitDir(self, arg, dirname, contents):
        if os.path.basename(dirname)[0].isupper():
            return

        for file in contents:
            if not file.endswith('.cc'):
                continue

            fullname = os.path.join(dirname,file)

            assert not self.itsFullIncludes.has_key(fullname)
            self.itsFullIncludes[fullname] = {}

            self.addRecursiveDeps(fullname, fullname)

    objDir = 'obj/' + os.getenv('ARCH') + '/'

    def printTarget(self, file, stream):
        parts = file.split('/')

        assert parts[0] == self.itsProjectPath
        stem = '/'.join(parts[1:])

        (stem, ext) = os.path.splitext(stem)
        assert ext == '.cc'

        ostem = self.objDir + stem

        stream.write('\n\n%s.do %s.o:' % (ostem, ostem))

        for dep in sort(self.itsFullIncludes[file].keys()):
            stream.write(' \\\n\t%s' % dep)

    # public interface

    def __init__(self, paths):
        self.itsProjectPath = paths[0]
        self.itsFullIncludes = {}
        self.itsDirectIncludes = DirectIncludeMap(paths)

    def buildDepTree(self):
        os.path.walk(self.itsProjectPath, self.visitDir, None)

    def printMakeDeps(self, stream):
        header = "# Do not edit this file! It is automatically generated. Changes will be lost."

        stream.write(header)

        for file in sort(self.itsFullIncludes.keys()):
            self.printTarget(file, stream)

        stream.write('\n')
