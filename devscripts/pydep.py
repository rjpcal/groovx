#!/usr/bin/env python2

# This is a quick script to build a dependency file suitable for
# inclusion into a Makefile, by scanning for source files ('.cc'
# files) within a source tree passed as a command-line argument.

# $Id$

import os
import re
import sys

PATH = os.path.normpath(sys.argv[1])

DEPS = {}

FLATDEPS = {}

CHECKSUM = 0

include_regex = re.compile('^\s*#\s*include\s*"(.*)"')

def findFlatDeps(file):
    if not FLATDEPS.has_key(file):
        FLATDEPS[file] = []
        f = open(file, 'r')
        for line in f.readlines():
            match = include_regex.match(line)
            if match:
                global CHECKSUM
                CHECKSUM += 1
                dependency = os.path.join(PATH,match.group(1))
                if os.path.isfile(dependency):
                    FLATDEPS[file].append(dependency)
                else:
                    print 'in file: ', file,
                    print ', missing dependency: ', dependency
        f.close()

    return FLATDEPS[file]


def addRecursiveDeps(target, rootdep):
    DEPS[target][rootdep] = 1

    flatdeps = findFlatDeps(rootdep)
    for dep in flatdeps:
        addRecursiveDeps(target, dep)


def findincludes(file):
    if not DEPS.has_key(file):
        DEPS[file] = {}
        addRecursiveDeps(file, file)


def visit(arg, dirname, contents):
    if os.path.basename(dirname)[0].isupper():
        return
    for file in contents:
        if not file[-3:] == '.cc':
            continue
        fullname = os.path.join(dirname,file)
        findincludes(fullname)


#
# Run
#

os.path.walk(PATH, visit, None)

sortedfiles = DEPS.keys()
sortedfiles.sort()

arch = os.getenv('ARCH')
objdir = 'obj/' + arch

header = "# Do not edit this file! It is automatically generated. Changes will be lost."

sys.stdout.write(header)

sep = '/'

for file in sortedfiles:
    parts = file.split(sep)

    assert parts[0] == PATH
    fileroot = sep.join(parts[1:])

    (fileroot, fileext) = os.path.splitext(fileroot)
    assert fileext == '.cc'

    l = '\n\ndep/%s.d %s/%s.do %s/%s.o:' % (fileroot, objdir, fileroot, objdir, fileroot)
    sys.stdout.write(l)

    sorteddeps = DEPS[file].keys()
    sorteddeps.sort()
    for dep in sorteddeps:
        d = ' \\\n\t%s' % dep
        sys.stdout.write(d)

sys.stdout.write('\n')
