* -*- outline -*-

* ChangeLog file
  $Id$

* Rob Peters <rjpeters at klab dot caltech dot edu>

* 1999 STARTS HERE

* need to have a way to initialize the appropriate data structures
  for an experiment (probably ObjList, Glist, and RealExpt) from Tcl,
  based on a simple file description of the experiment

  would like to avoid having to manipulate/store Tcl data structures,
  preferring C++ STL structures instead

  who should own the ObjList, Glist, Expt data structures? when do
  they come into existence?

  problem: don't want to have to have default constructors for ObjList
  + Glist, yet they are necessary for ToglConfig and togl widgets
  shouldn't be dependent on having a valid glist constructed already

  solution? hold references to pointers in the relevant locations, so
  that the actual objects can come in and out of existence as
  necessary

  --> problem with this is that this requires constant testing for
  null pointers to see if the objects actually exist



  problem: it should be easy to do something simple, like create one
  face and display it

  solution? some derived class of Expt or Glist could manage these
  special situations


  what are necessary steps to start experiment?

  1) create GrObj's (Faces) and ObjList, knowing the size of the
  groups in Glist (how?)-- this requires some temporary data structure
  to store the ids of the objects in the different locations

  ... createObjs function returns a vector of objids giving the objids
  for the list of objects that were specified

  ... would like to be able to have a way to create a set of GrObj's
  that it is independent of their exact type, yet that involves a
  straightforward file format (maybe give each type a constructor that
  takes a string, which in turn contains the obj-specific parameters?)

  ... how is the number of objects in each group determined? more
  fundamental problem: how are the groups stored-- in terms of face
  class id (as in STIMDG(groups)) or in terms of actual objid's, where
  the objid depends on the position in the group. Is there a way to
  avoid having to store both forms of information?

  2) create Glist (list of stimulus groups) from input file, or from
  (???) that describes special ways to initialize (all pairs, or all
  triads...)

  3) create an Expt object based on Glist and on the number of repeats


  radical idea??? have multiple ObjList's, one for each position in
  which a GrObj will be displayed?


  solution to big problem??? have Glist own an/the ObjList, so that
  they are constructed at the same time, from two files; maybe the
  Glist is also owned by the Expt object



* Friday, 5 Mar 1999 started moving the stimdg implementation out of Tcl

  first goal: remove direct access to Tcl array fields by providing
  interface in class Stimdg. Stimdg's are currently initialized with a
  Tcl_Interp and a Tcl_Obj holding the name of a Tcl array that has
  the relevant fields. But, no one should directly access those
  fields. Eventually, a global Stimdg object will be used, whose
  implementation can then be something other than a Tcl array.

  next steps:

  1) must port remaining Tcl files to C++
  init_stimdg.tcl : this will eventually become the Stimdg constructor

  load_face_data.tcl : straightforward, must read file data into the
  NL, MH, etc. fields of the Tcl array

  trial.tcl (mostly done) : just need to write recordResponse

  parse_stimdg.tcl : actually doesn't need to be ported, since it
  doesn't require a Stimdg structure in particular

  2) develop some token other than an array name to be passed to C++
  from a Tcl script -- this is the final modification necessary for
  the encapsulation into C++

* Saturday, 6 Mar 1999

  1) ported replace_response to C++. This requires using
  Tcl_ListObjReplace to exchange the curstim'th element in the
  remaining and responses fields. However, the function prototype in
  the man page is a little misleading, since the prototype itself
  shows the range of indices into the list specified by 'first,
  count', but the argument declaration list shows the indices as
  'first, last'. Turns out 'first, count' is correct, but this seems
  redundant with the objc... aha! you don't necessarily have to
  replace a range with the same number of elements that were there
  before; thus both 'count' and 'objc'.

  2) ported init_stimdg to C++, splitting into a Tcl Cmd proc
  init_stimg, which in turn calls the Stimdg member function init
  (which should later be moved into a constructor). But ugh; still
  have to port the init_triad_stimdg and init_pair_stimdg procedures.

  3) had an awful time porting load_face_data to C++. Problem was the
  procedure that tried to append an element to one of Stimdg's fields,
  by way of Tcl_ListAppendElement. If the field didn't exist before,
  there wasn't a problem creating it when it was asked for; however,
  it didn't behave very nicely as a list, generating some error about
  not converting a string to type. (?) So, had to create an
  'initFaceFields' procedure for Stimdg to first create all of the
  related fields before calling the append procedures.

  4) ugh. trying to port write_array and read_array to C++. Getting
  that same error message:

  UpdateStringProc should not be invoked for type
  IOT trap

  This time my problem was I was trying to call Tcl_GetsObj to read
  into an object from the file, but I was trying to read into a null
  pointer, rather than an object that had been initialized with
  Tcl_NewObj(). Dumb mistake, but still, the error message could
  certainly have been more helpful.

  Also, I can't make read_array work the way I want using C++ strings,
  file streams, and string streams, since this lame implementation on
  the HP's can't do a getline into a C++ string.

  5) There is now one global Stimdg in the StimdgTcl namespace that is
  created at startup in Stimdg_Init. This means that the dg_name
  arguments being passed to stimdg Tcl functions are just dummy
  arguments at the present time; the global Stimdg is always used.

  Should the Tcl array that implements the Stimdg be isolated by
  putting it in its own Tcl_Interp? Would this prevent access to the
  other Tcl commands that are necessary in the implementation?
  Duh--no, it wouldn't since the CmdProc's can be called from C just
  like any other function--it's only in Tcl that they must be
  registered with the running Tcl_Interp.

  6) There. I made Stimdg use its own Tcl_Interp separate from the one
  running the interactive Tcl application.


* 7-8 Mar 1999

  Ugh. Very late last night, and today, I implemented a *much*
  improved version of the functionality necessary to control an
  experiment, through the interface class Expt, and the concrete class
  RealExpt. Unfortunately, I also tossed out completely the ~1000 line
  of code I had written for Stimdg and StimdgTcl. But, I think things
  are much better off now. I realized that there was too much
  duplication of data between Stimdg and the other data structures
  such as Glist and ObjList and the various GrObj's. Instead of
  duplicating data, the Expt class merely provides an interface to the
  other data structures, and allows everything to be written to and
  read from a single file. As another bonus, this implementation is
  even more efficient-- now takes only ~0.84u to start up a triad
  experiment.

  A few loose ends:

  1) need to make the object specification truly polymorphic. Who
  should control when and where the type strings get written to files?
  Want to be able to read files both ways:

     a) assuming a fixed type all the way through
     b) polymorphic--determine the type one line/obj at a time

  2) need another c'tor or two to be able to generate the different
  types of experiments such as pairs and singles--just have to pass
  these options to the Glist constructor

  NOTE: must change makePairs, makeTriads, so that the objid's take
  into account their position in the group

  3) need to use symbolic constant to determine how StimClass is set


* 10 Mar 1999

  Things are mostly nice now, but, as always, I have many possible
  revisions in mind.

  1) There are too many 'little fixes' that I have to keep on
  remembering to apply in new code. For example:

     - Glist stores objid's-- indexes into ObjList, which do not
     necessarily reflect the object 'type', since the same 'type' of
     Face, say, may be created at multiple locations, giving multiple
     objid's. In order to check if two objects are the 'same', I have
     to adjust for this factor. This is sure to lead to trouble at
     some point

     - within RealExpt, there is a discrepancy between trial type (an
     index into Glist) and trial number (which reflects how many times
     a type is repeated). This also requires many conversions back and
     forth, sure to cause eventual problems.


  2) Perhaps I am missing some underlying datatypes that are really
  needed, such as Trial, Position, etc. Then

  3) Ugh. Too much of this design has been designed for the sake of
  Tcl. I'm starting not to like that language much.

  4) Gee, now I have a really nice design for Trials that I should
  have switched to months ago. I guess this is what they mean by "be
  prepared to throw your first draft (or four) away".

  Wait--Trials should hold id's, not pointers to, GrObjs and
  Scaleables. This will make things much easier when we have to
  serialize-- in fact, an Expt is starting to look quite nice:

  class Expt {
        vec<Trial *> itsTrials; // each is unique
        vec<int> itsTrialList; // randomly ordered list of indexes into itsTrials
                               // (may contain repeats)

        int itsCurstim;        // index into itsTrialList
        void beginNextTrial();
        void recordResponse(int resp);
        int lastResponse() {
          return itsTrials[itsTrialList[itsCurstim-1]]->lastResponse();
        }
  }

  To achieve better backward compatibility with Glist functionality
  (which must interact with ToglConfig), perhaps define Tlist class,
  which can exist outside an Expt, but which is controlled by the Expt
  while the Expt is in progress.

  The only duplication of data here would be Curstim (and
  Tlist::itsCurTrial). During an expt these would normally line up,
  but Tlist::itsCurTrial could be controlled independently from Tcl.


  5) Back to the concrete (i.e. currently existing) software. Grsh
  crashed in the 'train' experiment, using repeat of 1, after all 10
  trials were completed, and I entered a response anyway. This points
  out that we need a good way to know when the experiment is over.


* 11 Mar 1999

  1) started using RCS via Emacs' vc utilities. I hope this will
  reduce some of the confusion surrounding versions.

* 13 Mar 1999

  1) had very good progress implementing Position, PosList, Trial,
  TrialExpt. Spent a lot of time on the serialization/deserialization
  functions. This new design is far superior to the old plan--it's
  really nice to have the GrObj separated from the Position objects,
  to be able to be controlled independently. This fact greatly
  simplifies the process of reading and writing expt files.

  2) What is left?

  * implement functions to read into a TrialExpt from simpler file
  formats (such as nos_faces_sel and tr_nossel)

  * reimplement the expttcl package for TrialExpt instead of
  * RealExpt. Fortunately, except for the constructors this won't be too
  * much work since both classes implement the Expt interface. (A real
  * instance of OO design at work!)

  * figure out a more elegant way to do STL input and output. I can use
  * ostream_iterators and istream_iterators, but I'm not too familiar
  * with them at this point, and most importantly I'd like to be able to
  * control the spacing of the container elements in the output file.

  * implement derived classes from Trial to get the right trialType()
  * for singles, pairs, triads, etc.

  * think about a really robust way to do the file formatting. Perhaps
  * some file format descriptor classes?

  * some rigorous testing/debugging. Need to add in Assert() statements
  * throughout old code, and design Tcl packages to allow for easy testing.

* 14 Mar 1999

  1) need a good way to enforce proper order of initialization of Tcl
  packages, such as ObjlistTcl, PoslistTcl, TlistTcl, and
  ExptTcl. Actually, the problem is the use of the pointers. Maybe I
  don't even need the pointers anymore, since most of the objects
  don't ever need to be deleted--they can be adjusted at will using
  member functions. In fact, I think the only object that might need
  to be reallocated is TrialExpt, and this is at the highest level so
  everything is peachy. Still it would be nice to know why
  Tcl_PkgRequire isn't working.

  2) Don't need to have derived classes of Trial. Instead, should
  provide some (non-member) utility functions to go through and set
  the types appropriately. Such as findside(const Trial&).


* (1999) make ObjlistTcl::theObjList a static object, not a pointer
  since no one ever needs to delete it. same for Poslist.  move the
  makeTriads, makePairs etc. to Tlist instead of TlistTcl

* (done 1999) add test_objects to Makefile
  that includes test versions of each of the object modules. These
  should be compiled with appropriate macros defined, such as
  LOCAL_PROF, INVARIANT, LOCAL_ASSERT, etc. Need to macroize Makefile
  so that debugging object dependencies are generated automatically.

* (done 1999) Need better way to clear screen in between Trials
  glClear is responsible most of the graphics time. Could either clear
  a bounding region, or redraw the Trial with foreground/background
  swapped. The latter is easy, except Jitter's don't currently know
  how to re-do their previous operation.

* (nix 1999) Try implementing GrObj's with stored pixmaps
  rather than direct rendering to see if display speed is
  improved. --> This would probably interact poorly with
  Position's. e.g. rotating...

* (done 1999) Implement reaction time measurements
  directly in Expt class rather than through Tcl.

* (done 1999) Add auto save to expt.tcl
  save the experiment in a temp file every 100 trials or so.

* (done 1999) Add ioTag() method
  to classes to return whatever name they want to use as their
  official typename in serialize/deserialize. This is better than
  using typeid(class).name() since this may not be portable across
  systems. Also, using ioTag() avoids having to rewrite typeid... all
  the time, and minimizes the chance of mucking things up.

* (done 1999) Bug: with "pause"
  if pause is hit immediately after a previous pause is released,
  there is a problem with overlapping faces being displayed. Fix -->
  hold an id for the resume timer, so that the resume can be cancelled
  if the experiment is re-paused again before the timer would go into
  effect. OK, that was a problem, but the real problem was: Tlist's
  visibility was not being set to false when trials were undrawn; thus
  when the pause window was destroyed, part of the Togl widget was
  revealed, invoking a redraw callback, invoking drawCurTrial(), which
  redrew the trial that had been undrawn before the pause. Fix -->
  Tlist's visibility is now set to false whenever a trial is undrawn.

* (done 1999) move Tcl scripts for Expt:: proc's to C++
  Everything is ported to C++ now, but there are still a fair number
  of Tcl_Eval call's, so there is still a bit more work to be done.

* (note 1999) The problem with the current design(?)/implementation
  is that most of the Hard Work is still going on inside the
  expttcl.cc implementation (of course it didn't appear that way when
  it was implemented in Tcl-- this is why I'm afraid that Tcl can be
  conducive to poor designs -- it promotes the use of C++ classes as
  just data-holders that expose everything publicly to Tcl). The goal
  now is to distribute that work amongst the other objects in the
  system. I don't really need to create any new major types; it's just
  a matter of getting each of the existing types to take on a little
  more work. ...this also means that I'll have to be using some Tcl
  API's in the implementation (but not the interface, hopefully) of
  the components that were previously isolated from Tcl. But I think
  this is not a problem, since the use of Tcl in the implementation is
  not done in a way that provides access from Tcl scripts. Actually,
  Tcl should only have to be used to implement Expt, which it is
  practically doing now anyway in the guise of the ExptTcl package.

* (done 1999) Need to store *all* exp't variables somewhere
  probably in Expt class, so that they can be serialized. Get rid of
  the -global- data in ExptTcl such as inter_trial_interval, autosave
  file, etc. Change to functions in Expt class, and
  accessor/manipulator functions in Tcl. OK, moved most things into
  experiment class-- some will still need to be moved down further to
  the Trial level eventually. Much old ExptTcl functionality is now
  encapsulated in ExptDriver class -- a temporary solution (?) until
  things are rolled back into Expt...

* (done 1999) Add virtual method to IO
  for classes to say how many chars they need to write themselves. -->
  Done. Need to test it as part of generalizing the IO system.

* (done 27-May-1999) PtrList is really used more as an object database
  than as an ordinary collection. This seems to cement the idea that
  ObjList and PosList should be bonafide singletons, rather than the
  pseudo-singletons that are provided now via ObjlistTcl and
  PoslistTcl namespaces. Good.  ==> Done. ObjList and PosList are
  singletons.

* (note 1999) I see: the real advantage of changing ObjList and PosList
  to singleton classes is that I no longer need to store references to
  them all over the place; instead, classes can just include the
  headers and then access the singleton instance.

* (done 1999) The ObjId class
  should contain 1) an int index, and 2) a reference to its ObjList.
  !! Scratch #2-- ObjList is now a singleton, so we don't need to
  worry about it! Thus there is no space overhead in making ObjId a
  dedicated class. Goal: clients should not have to know about ObjList
  + PosList; instead they only know about ObjId and PosId. Should
  ObjId's be flyweight objects?  This would make keeping reference
  counts easy. Should ObjId's act like pointers to GrObj's, or like
  pointers to pointers to GrObj's (as a typical iterator)?

* (done 1999) TrialTiming -- generic trial/experiment description
  Ding, ding, ding! Bells are ringing. Need a new structure, called
  TrialTiming, or EventSequence, or some such, that holds information
  about stimulus display time, trial timeout time, inter trial time,
  etc. Then each Trial can hold a pointer to a TrialTiming, and the
  TrialTiming's can be held in a list. (Maybe I can reuse
  PtrList???). Let me just try to scratch some ideas down
  quickly. Need to think carefully about the name for this
  thing-a-ma-jobber. --> This is done, but right now TimingHandler is
  attached to ExptDriver, eventually it should be migrated to be held
  by Trial.

* (done 27-May-1999) I'm still stuck
  on how to interpret the role of the ObjList and PosList
  classes. These are not supposed to be playing a huge role... they're
  just a way to identify objects with an objid rather than with a
  memory address, which facilitates manipulating them in Tcl as well
  as reading/writing them from file. Maybe what needs to be a first
  class object is the "objid" or "posid", or some kind of
  iterator... The iterator should skip over NULL sites in the
  list/vector, and it should match end() when there are only NULL
  sites remaining. The outer appearance of ObjList and PosList is that
  they are associative arrays between int's (objid's?)  and GrObj*'s,
  but internally they are implemented with a vector for more efficient
  access times than with a map. --> Implemented ObjId and PosId
  classes (although they still need better iteration).

* (note Jun-1999) What should the requirements be
  on reading in to a Trial by ObjId's only? Should we require that the
  proper ObjId's already exist, or do we assume they will be created
  later? Right now we assume they will be created later, and do not
  check for their validity as they are read in.

* (Jun-1999, done) Need major modifications to prepare for fMRI work.

** need to make different types of trials, mainly varying according to
   how they collect responses, if at all, and how they give
   feedback. Most of this stuff could be wrapped in ResponseHandler
   and TimingHandler objects; it's just a matter of moving those from
   ExptDriver into Trial's. How to do a FeedbackPolicy within C++
   rather than from Tcl?

** Order dependency should be removed from serialize/deserialize
   methods: members should be requested by name. Need capability for
   versioning in serialize/deserialize.

** need to look seriously at some industrial-strength creational
   patterns: I've got a lot of functionality implemented, but it the
   various objects need to be able to be assembled in the right
   ways. E.g., set the TimingHandler for a whole bunch of Trial's,
   vary one parameter along a set of Trial's, etc. Most of this will
   probably be helped by having some good iterators for PtrList's.

* (fixed Jun-1999) Buggy behavior
  if Expt::begin is called on an empty experiment, the message "expt
  is complete" comes up but the Expt keeps on running empty trials,
  then aborting them.

* (fixed Jun-1999) Damn. another bug
  if a GrObj is changed while it is onscreen, it cannot be properly
  undrawn since its old state is not remembered...

* (done 9-Jun-1999) Same thing with Tlist [should it be a singleton] ???
  Ah-hah!  Tlist is different -- it's more like a Block in an Expt,
  because an Expt should conceivable be able to have several
  blocks. So a Tlist is a more typical container. (Later) No... the
  first thing was correct: Tlist *should* be a singleton. Trial's are
  an application-global resource. It is "Expt"'s (to be renamed
  Block's) that might exist in multiples.

* (done 13-Jun-1999) Need more reuse in the Tcl packages.
  There's just too much copy-and-paste going on here. Need to think
  about ways to encapsulate the functioning of a Tcl command in a
  template or abstract base class, that can be parameterized by
  certain things like object count, return type, type of list used,
  etc...  --how to control the proliferation of Tcl packages needed to
  wrap each class that comes up? Or at least simplify these
  files... maybe with a generic way to get/set attributes.  --Cool!
  I've implemented the TclObjCommand class. This does all sorts of fun
  stuff. Now I just have to *use* it everywhere!

* (done 13-Jun-1999) Damn. How can we serialize/deserialize
  ResponseHandler's and TimingHandler's when they require an
  ExptDriver reference? Maybe the RhList and ThList can store the
  references that they need? No, this only postpones the problem. It'd
  be nice to have the ExptDriver be a global resource, but it in turn
  requires a Tcl_Interp*, so it can't be initialized until Expt_Init
  is called. I guess I could just give up on multi-interpreter
  capability, create a global ExptDriver first with its Tcl_Interp*
  set to NULL, then initialize its Tcl_Interp* when Expt_Init is
  called. Or... could switch from ExptDriver& to ExptDriver*, but this
  loses some saftey. --> OK, ExptDriver has now (like just about
  everything else...) become a singleton. However, its Tcl_Interp* is
  not set until the Expt package is initialized. This way,
  ResponseHandler's and TimingHandler's can get a reference to
  theExptDriver. Also, ResponseHandler's no longer depend on
  ExptDriver for their Tcl_Interp*; instead, theRhList contains a
  Tcl_Interp*, and ensures that any ResponseHandler's added to
  theRhList have their Tcl_Interp* set correctly. In addition, any
  ResponseHandler's that are on theRhList when the Rh package is
  initialized will have their Tcl_Interp*'s set correctly.

* (done 13-Jun-1999) Need to write Tcl packages for RHList, THList, and
  BlockList. Ugh. --> Actually, not 'ugh' ! I've implemented a TclPkg
  class, which controls and contains TclCmd's. I've subclassed this
  with TclListPkg, which contains the common xxList TclCmd's, and
  arranges for them to forward their operations to virtual functions
  in TclListPkg. This way, the RhList, ThList, etc. packages are very
  easy to implement: just sublcass TclListPkg, override a few
  operations, and presto-change-o you're done!

* (done 13-Jun-1999) This is low down on the list
  but would be intersting... Generate an object-based C++ wrapper for
  the Tcl C API's. This would be something as straightforward as
  possible-- not trying to change the *design* of the API, but just
  making things more C++-friendly. Could start off by wrapping up the
  Tcl_Interp and Tcl_Obj classes, then add member functions as I need
  them. --> I think I'm well on the way to accomplishing this sort of
  thing with the recently-added TclCmd's and TclPkg's... these hide
  most of the low-level Tcl API calls and provided simpler/shorter
  ways to accomplish the common things, but in general don't prevent
  low-level calls from being mixed in as well.

* (done 13-Jun-1999) Try Tcl packages as static instances of classes
  declared within Tcl_AppInit. --> This requires more code in the
  pkg.h files (such as the package class declaration). OK? maybe, but
  I need a while for the ramifications of this to simmer. This may be
  too far out of line with Tcl coding standards... --> No: the way to
  do this is the way I've accomplished it now with TclPkg's. The
  package is defined as a sublcass of TclPkg, and the Pkg_Init
  function simply calls 'new PkgName(interp)'. (This does not call a
  memory leak since TclPkg sets up an exit handler to delete itself
  when Tcl is exited). This way we can do Tcl packages as classes, yet
  still conform to the method of calling the Pkg_Init functions from
  the AppInit.cc file.

* (nix 13-Jun-1999) fix the object hierarchy
  so that Expt contains Tlist by value, which contains ObjList and
  PosList by value ... is this a good idea?  It seems to break some
  aspects of encapsulation, since it requires ObjList/PosList
  declarations to be visible wherever Tlist is used. Maybe can get
  around this with containment by reference, but also ownership. Or
  containment by * const. Yes, this would work. Never mind, it
  wouldn't make sense, since still clients of ObjList would have to
  have Tlist and Expt visible in order to retrieve the current
  ObjList. That is the real problem. No...... the real problem is---
  Expt, Tlist, ObjList, PosList, etc... should all be top level
  objects. But Expt needs to use Tlist, etc., so maybe these all
  should be contained in a higher level object-- TheApp???  This could
  serve up the current Expt, ObjList, etc. ---> [Later] This has taken
  care of itself by way of most of these classes becoming
  singletons. Perhaps I will still add a top-level class which is in
  charge of serializing all of the singleton's, but this isn't too
  great of an issue.

* (done 13-Jun-1999) Implement multiple deserialize protocols
  so that old objects can be deserialized. Just need to add some sort
  of version byte/code in the file to map to the appropriate
  deserialize function. --> OK, I've implemented this for Face,
  but... this is really more of a mess than it sounds like, since
  whenever a class definition changes, not only the current
  deserialize protocol must change, but also ALL of the previous
  supported protocols. This is a true mess if the underlying object
  representation changes dramatically. Need to think about this some
  more... see if I really want to muck with multiple versions
  throughout the object hierarchy.

* (nix 13-Jun-1999) Error handling.
  Get rid of TCL_ERROR as return status from procedures that handle
  Tcl, but aren't Tcl_CmdProc's. Instead, throw
  TclError(useful_info_string) and then catch these exceptions in
  high-level callers-- i.e., Tcl_CmdProc's. ---> [Later] The above was
  all wrong. The correct way: in asynchronously-called procedures, Tcl
  errors are raised with Tcl_Background error. And, in the new TclCmd
  class hierarchy, errors are generated by throwing exceptions of
  class TclError; these are caught and converted back to a 'return
  TCL_ERROR' before control returns to Tcl.

* (15-Jun-1999, done) Clean up some old Tcl package files
  by converting them to TclCmd/TclPkg format. ... in progress ... I'll
  skip misctcl, tcldlist. But still need to do subjecttcl.

* (done 16-Jun-1999) figure out how to make !@#$^& shared libraries work! [Later -->] Well, they're !@#$^ing working now, but they're
  still a pain in the @$$. For some reason, objtogl doesn't like to be
  linked in as a shared library, but instead as an ordinary .do file
  (although the .do file can be compiled with the +Z option). If it is
  linked as a shared library, everything grinds to a halt in
  toglDisplayCallback, apparently on the call to glClear()... why is
  this? A likely candidate would be the fact that objtogl is the only
  package besides grshAppInit that uses <togl.h>, but yet it appears
  the crash is occurring on the call to OpenGL... maybe this happens
  to be the first call to GL?

* (done 16-Jun-1999) Bitmap's are not undrawn in the same way
  as all other GrObj's. In particular, it is certainly quicker to
  clear the pixels rather than recopy to the framebuffer... This will
  entail adding an undraw() operation to GrObj. Done --> basically,
  use gluProject to find out in window coordinates where its beginning
  raster position falls, then use glScissor to define a rectangle
  beginning from this point and having the correct height/width.

* (done 16-Jun-1999) Issues with Bitmap's:

  --how to get the correct contrast? OK, added a flipContrast command.

  --should implement Pbm modes 5 + 6? OK, just 'is.read(itsBytes,
    itsNumBytes)'

  --need to optimize for bitmap operation. OK, done.

* (done 16-Jun-1999) Move timing handler Tcl commands
  from expttcl to thtcl. --> Done. It was a lot of fun to remove all
  of those pointless accessor/manipulator functions from ExptDriver
  that were just forwarding to TimingHandler or ResponseHandler.

* (16-Jun-1999, done 17-Jun-1999) make a class TclEvalCmd or similar
  to serve as a wrapper for this repeated 'static Tcl_Obj*, static
  TclObjLock' junk. --> Done ... but ... could extend this to make
  TclEvalCmd's that declare themselves to return given types? Or is
  that just too much?

* (16-Jun-1999, done 17-Jun-1999) Would like to add
  declareIntSetter, declareIntGetter, etc. to TclItemPkg, but first
  I'm going to have to figure out how to avoid the proliferation of
  duplicate code that occurs for each of the basic types that are
  supported. Should be able to do this with templates, but how??? I
  think it comes down to the necessity for member templates, which I'm
  not sure if aCC has... maybe I should find out! [Later -->] Doh!
  This is what operator overloading is for... all I have to do is
  overload returnVal() for the basic types in class TclCmd, and then
  elsewhere in the program I can use templates on the basic types,
  which will compile correctly iff the template type is supported by a
  returnVal overload in TclCmd. So, now I have a generic TclGetterCmd
  template working-- it's templatized on the type of object to get
  from, and on the type of value to get. Also just noticed that it's
  fairly expensive in compile-time to modify tclcmd.h--this file is
  very heavily depended-on.

* (17-Jun-1999) Looks like TlistTcl could also use some de-bloating
  via conversion to TclCmd/TclPkg. --> This is under way: TlistPkg now
  implements the TcllListPkg interface, so stringify, destringify,
  reset, and count are now handled automagically. Actually most of the
  bloat in TlistTcl is due to the creational functions makeSingles,
  etc that really belong elsewhere (where?) Should all this creational
  code go toether in one area, or does Tlist need a separate
  creational packaged from Expt, for example? [Later] ... this stuff
  has moved to TlistUtils.

* (note 18-Jun-1999) Got another core dump
  with a "missing symbol during dynamic loading". The dynamic linker
  couldn't find TclError() for a call inside a function defined inside
  an unnamed namespace. The solution (workaround) is to put the
  function inside a named namespace and follow with a using namespace
  directive.

* (15-Jun-1999, done 18-Jun-1999) Bitmap serialization
  need mainly to record the filename. Done --> but, do I want to have
  an option as to whether to record the graphics filename, or to
  actually write the graphics data??? I think no, since writing the
  graphics data would hugely bloat all of the expt files that are
  saved for subjects.

* (18-Jun-1999, done 18-Jun-1999) Better find a place to 'catch'
  the PbmError's that occur on an invalid filename. OK, Bitmap catches
  any PbmError's that occur during loading. Should Bitmap also rethrow
  an IoError, perhaps?

* (17-Jun-1999, done 18-Jun-1999) Should have declareGetter
  declareSetter, declareAction in TclItemPkg along with
  declareAttrib. --> OK, now I have getter/setter working, but still
  need to implement declareAction. --> OK, declareAction is done too.

* (19-Jun-1999, done) Big Bug #2.
  There seems to be a problem with exceptions: in
  TclCmd::getDoubleFromArg, when an exception is thrown, the Trace
  object is not properly destructed... maybe this is underneath the
  problems that have popped up with exceptions elsewhere?  [Later] I
  think this was a problem with having multiple versions of the Trace
  objects floating around (i.e. some compiled with tracing on, others
  with tracing off)... this led to multiple definitions of
  ~Trace()... a "bad thing".

* (16-Jun-1999, done 20-Jun-1999) Now that shared libraries are
  pseudo-working, it is definitely a worthy goal to try to get Tcl's
  'load' command for shared libraries working. However, this will
  entail working out the various dependencies between Tcl packages
  (such as that of Face on ObjList)-- these will not the same as C++
  compile-time dependencies. ... --> OK, I have this working in
  principle now. Package init procedures need to be taken out of
  namespaces and put in the global namespace with an 'extern "C"'
  declaration so that Tcl is able to find the init procedure from a
  package name. Then packages are available via 'load filename', or I
  can set up a Tcl config script with a bunch of "package ifneeded"s
  to specify which files to load for a filename. Now it's just a
  matter of working out the dependencies between files.

* (16-Jun-1999, done 20-Jun-1999) Need more generic way
  to do getItemFromId() inside TclItemPkg. Would like to allow for
  this to work for ExptDriver as well, which doesn't actually require
  an ID, since it's a singleton... so we need to specify within
  TclItemPkg which Tcl command argument, if any, should be taken to be
  an item ID. Also, it would be nice for TclListPkg's to also be able
  to declareAttrib, declareSetter, etc. I think this calls for a base
  interface that declares and defines the declareAttrib,
  etc. functions, but which forwards the retrieving of an item to a
  virtual function getItem(). Then in subclasses of this interface,
  getItem() could be defined to call getItemFromId(), or in the case
  of TclListPkg, it could be defined to just retrieve the list
  singleton. How to define the underlying TclCmd's so that they work
  correctly in all cases?  Right now they all call
  itsPkg->getItemFromId(). ... --> OK, I have a sort of hackish way of
  getting this all working... TclItemPkg takes an argument specifiying
  which Tcl command argument contains the item_id; if this number is
  0, then it is assumed that an id is not needed to retrieve the item,
  and therefore an id of -1 is passed to the virtual function
  getItemFromId. The commands that are created by TclItemPkg also know
  how to do the right thing with regard to the presenc/absence of an
  item_id argument. Now we should have TclListPkg inherit from
  TclItemPkg so that we can add attribs, etc. to lists. ... Actually,
  this would hardly be even necessary once I have declareAction
  working, because then a ListPkg can just declareAction("reset") and
  declareGetter("count") and we can do away with a separate
  TclListPkg.

* (18-Jun-1999, done 20-June-1999) Question:
  does putting forward class declarations in a .cc inside an unnamed
  namespace actually cause the class definitions to remain locally
  visible only? --> NO. The way to do this is to use a named
  namespace, put forward declarations inside namespace block, then
  define the classes out-of-line by using an explicit namespace
  qualifier when defining the class; i.e. 'class mynamespace::my class
  {};'

* (16-Jun-1999, done 20-Jun-1999) Move Block-related commands
  out of expttcl and into blocktcl. Along the way, morph expttcl and
  blocktcl into TclCmd/AttribCmd/TclPkg-compliant packages. Done. It's
  nice that after "blind refactoring" with no specific goal in mind,
  the underlying abstractions come out crystal clear--better than I
  could have stated on my own a priori. ExptTcl now has exactly the
  commands that you'd think it should: begin, stop, pause, read, and
  write. (Although autosaveFile is a bit of a wart...)

* (21-Jun-1999, done 21-June-1999) I think TimingHandler's really need
  to be expressed more generically, in terms of TrialEvent's, whose
  timing should be specified either relative to immediate, Trial
  start, or response seen. This can all go in a base class; then we
  can recreate the interface of the current TimingHandler in a derived
  class. --> Done.

* (21-Jun-1999) Can get seg-fault by closing Tk-Togl window
  while tcl shell is still running, then calling exit. Problem is: who
  'owns' the ToglConfig, and who 'owns' the Togl widget that it
  contains? I would like ToglConfig to own its widget, and for ObjTogl
  to own the ToglConfig singleton. But the problem is that the
  ToglConfig doesn't have total control over the destruction of its
  widget, since the widget can be destroyed by dismissing the
  top-level application window or by exiting the application. If the
  ToglConfig handled the widget's destruction, it could arrange to
  delete itself when the widget was destroyed, but then it would have
  no way of informing ObjTogl that it had gone away... Right now I've
  patched the problem by having ObjTogl own the widget, in the sense
  of creating and destroying it. There is a static destroyCallback
  that is registered through the Togl API as a destroy callback; this
  callback will be invoked in one of several ways...

* (22-Jun-1999, done 22-Jun-1999) Should add
  a "mother-of-all-base-classes" base error class from which to derive
  all client errors so that TclCmd can catch all errors (somehow
  catch(...)  is failing to work). ... Done.

* (22-Jun-1999) How to improve Bitmap performance ?
  -- use glBitmap --> ding, ding, ding, we have a winner! This
  disallows using glZoom, though, so I'll have to manually flip the
  image vertically. What a pain. Adding a flipVertical command to
  Bitmap... this will require a flag to be serialized a la
  itsContrastFlip. <-- Done. Got a nice performance boost out of all
  this... rendering times for the 280x296 bitmaps were ~500 msec
  before, and are now ~85 msec. Not bad for a day's work...

* (22-Jun-1999, nix 22-Jun-1999) Maybe can improve Bitmap performance
  by using 4-byte chunks? --> Nope.

* (21-Jun-1999, done 22-Jun-1999) Need to migrate base ResponseHandler
  and TimingHandler code into abstract base classes, then create
  subclasses for the current incarnations, such as KbdResponseHdlr and
  BasicTimingHdlr (?). Need to add these classes to the IoMgr
  package. Then can also add a NullResponseHdlr (which should do
  nothing). Actually, the NullResponseHdlr needs to trivially generate
  a response upon beginning the trial, so that no matter what happens
  with the trial, it has seen a response and so can be considered
  complete.

* (20-Jun-1999, done 22-Jun-1999) Realized the objType and posType
  commands should belong to the GrObj:: and Pos:: namespaces, *not*
  the ObjList:: and PosList:: namespaces.

* (21-Jun-1999, done 23-Jun-1999) Going to need double-buffering
  in order to achieve reliable timing. How to implement this??? Maybe
  with a new event type RenderNextTrial. This would involve adding a
  flag to Trial (or somewhere else?) to indicate if a Trial has
  already been rendered into the other buffer. Then when Trial::draw
  is called, it checks the flag, and either renders the Trial, or
  swaps the buffers, as appropriate. --> Blah blah blah. Didn't need
  any of that fancy stuff. Just added a SwapBuffersEvent to invoke
  ExptDriver::edSwapBuffers. Then the timing handler runs the swap
  buffers event when appropriate. For the fMRI experiment, one buffer
  is always the stim buffer, and one is always the blank buffer. This
  is nice since it avoids any expensive screen clears. The swapping is
  pretty fast, only about 3 msec for a large window (1000x1000). Thus
  there is plenty of time in the 167 msec of blank time to 1) swap to
  blank buffer (3.5 msec), 2) undraw the current trial (4.5 msec), 3)
  draw the next trial (85 msec), and 4) swap back to the stim buffer
  (3.5 msec).

* (22-Jun-1999, done 23-Jun-1999) member template instantiation?
  I guess I can somewhat get around this problem by defining an inline
  member template that calls a private templatized class-static
  function that does the actual work. Then that static function can be
  instantiated for the basic types. Is this really better than just
  overloading the function?  Errors that would have previously been
  compile-time errors when the overloaded function is not present now
  become link-time errors when the template instantiation is not
  present. On the flip side, adding support for a new type involves
  only changing a .cc file rather than a .h file. Actually, I can't
  even use the explicit instantion syntax to do the instantiation;
  instead I have make calls to all of the functions that I want to
  use--this is done inside a dummy member function 'instantiate()'
  that should never actually be called.

* (note 23-Jun-1999) My TclItemPkg's are becoming
  sort of like metaclasses, I think... They make the environment more
  like that of a "dynamic" language, although there is still strong
  type checking through use of templates and limited use of casts.

* (23-Jun-1999, done 24-Jun-1999) Make Error subclass that includes
  a message, such as ErrorMsg or MsgError. IoError and TclError should
  then derive from this intermediate subclass. This allows for a
  generic catch clause in TclCmd::dummyInvoke that catches
  ErrorWithMsg's and prints their message. Done.

* (23-Jun-1999, done 24-Jun-1999) Need some sort of wrapper
  for OpenGL calls that seem to crash when they coexist with
  <tcl.h>. This is a hack. --> Instead of this, I've just decided to
  link in any GL-dependent files statically rather than
  dynamically... this appears to get around the problem, which is
  about the best I can hope for since I can't seem to actually
  pinpoint the problem.

* (24-Jun-1999, done 24-Jun-1999) Need to make Bitmap::flipVertical work
  correctly for 8-bit and 24-bit images. --> OK, I guess I also had to
  make it work correctly for 1-bit images. But now it's a lot faster
  all around. I didn't know that the images were always aligned so
  that each row begins at the start of a byte. This makes flipVertical
  very easy, since its just a matter of memcpy'ing a whole row's worth
  of bytes at a time from the old location to the new location.

* (17-Jun-1999, done 24-Jun-1999) It would be nice
  to get charCount() working, even if the estimates are
  way-over-the-top... this would avoid having to override getBufSize()
  functions in packages that make stringify/destringify
  commands. ...The Problem is that charCount() basically has to
  duplicate the entire logic of serialize(), which may be very
  involved and tedious, so duplicating it is also tedious and
  error-prone. Maybe it's best to have charCount just give a
  worst-case estimate. Actually, there are two reasonable alternatives
  that I can see, with opposing benefits: 1) charCount returns a
  maximum possible value--this makes the estimation of number of
  char's very fast, but probably wastes a lot of space, and 2)
  charCount actually serializes its object into a local buffer to
  determine the exact char count--this will effectively double the
  stringification time, but will ensure the right count and won't
  waste any space. Question: can these two strategies be mixed?  Maybe
  the solution is to get a good template gCharCount<vector<T> >
  working, where T is of type IO*. This is a big-ass pain. Still need
  to fix TimingHdlr::charCount, but that requires more freakin' vector
  serialization... maybe it's time I derived Vector from vector and
  IO, hmmm? But for now things are working well enough that I can
  remove the getBufSize from TclIoItemPackage... this was just a hack
  to get around broken charCount implementations. Now I have few
  enough of those that I can retreat any hacks back into one or two
  charCount's.

* (23-Jun-1999, done 24-Jun-1999) Add way for Getter's/Setter's
  to override the default usage string--this allows them to also be
  used as generic one-argument functions/value-returning functions.

* (done 24-Jun-1999) OK, now I have 6 lists
  ObjList, PosList, Tlist, RHList, THList, and BlockList. Who should
  serialize these? A toplevel object, maybe whose purpose is only to
  read/write. Whoever it is will have a really lengthy dependency
  list. OK, for now this can all be taken care of by ExptDriver.

* (19-Jun-1999, workaround 24-Jun-1999) Big Bug #1.
  Potential problem with compiler or OpenGL library? Having
  segmentation fault problems again in tlisttcl that occur only when
  the package is dynamically linked, but not statically linked. This
  is maybe similar to the problems with grshAppInit and objtogl, that
  also didn't like to be dynamically linked? All three packages use
  OpenGL, but other packages using OpenGL aren't crashing... This
  really odd-- I can work around the problem by moving the OpenGL code
  out of a TclCmd virtual invoke() procedure, either to a
  Tcl_ObjCmdProc (as it was before), or to a non-virtual function in
  Tlist. ? Ugh. Could it be a preprocessor problem, like the OpenGL
  header is getting mangled somehow? But this wouldn't explain why the
  code *does* work in a Tcl_ObjCmdProc. The problem does seem to
  depend on both <GL/gl.h> and <tcl.h> being included... I wonder if
  there is any issue with order of inclusion. None of the packages
  that use GL but not Tcl (i.e. the GrObj subclasses, Position
  subclasses, Trial, Tlist) are having problems. --> Can't seem to get
  anywhere... even using the debugger, things just crash on the calls
  to OpenGL. For now it's easiest just to link in statically
  everything that calls OpenGL.

* (24-Jun-1999, done) Now that we have a standard location
  for catching run-time errors in TclCmd, I should be able to remove
  many catch blocks from within current TclCmd's, particularly those
  doing I/O. Also, IoError probably no longer needs the semantics of
  adding its own type to the beginning of the error message; this
  could be done instead in the TclCmd's catch block.

* (23-Jun-1999, done 25-Jun-1999) ExptDriver needs
  to be able to run multiple blocks.  --When a block is done, see if
  there are more blocks; if so, start the next one, otherwise
  stop. --> Done

* (23-Jun-1999, done 25-Jun-1999) Need a better way
  to control the end of trials. In particular, end-of-trial should not
  be tied to recordResponse or abortTrial in Expt/Block's. This makes
  it difficult to do expt's that have no responses. Making this fix
  would also simplify NullResponseHandler (it could actually generate
  no response). --> Done.

* (21-Jun-1999, done 25-Jun-1999) What are the different ways
  we'd like to make Blocks?  --put trialid's in numerical order, for a
  given range of trialids.  --put trialid's in a randomized order, for
  a given range of trialids.  Done. There are two operations,
  addTrials(), which puts a range of ids into the Block in straight
  order, and shuffle(), which can optionally be used after addTrials()
  to randomize the order of the trialids.

* (20-Jun-1999, done 25-Jun-1999) The next step
  in having good genericity with TclPkg's is to allow an easy way for
  client errors to be transformed into TclError's. Somehow either
  TclPkg's or TclCmd's need to be parameterized with an error
  type... then they can catch this type. Or... all client error
  classes could derive from a base type (perhaps the standard library
  'exception'), then TclCmd could just catch the base class. Done-->
  added Error and ErrorWithMsg base types that can be caught be
  TclCmd. All client errors should derive from one of these bases,
  preferably ErrorWithMsg.

* (16-Jun-1999, done 25-Jun-1999) In Expt/ExptDriver
  do away with monolithic 'init' command, and make several creational
  commands, such as shuffle_init, straight_init, etc., and each
  command should take a range of trial_id's as an argument. Done. (or
  at least started). Now no longer need init() for ExptDriver, and
  Expt/Block's have addTrials() and shuffle().

* (note 25-Jun-1999) Perhaps a good way to think about the future of
  grsh is to consider what would be necessary to handle other sorts of
  experiments... such as dual-task expt's, staircase expt's, motion
  expt's. Not that I need to implement the functionality for those,
  but do I have the right abstractions in my framework so that it
  wouldn't be exceedingly difficult to implement them? Which part of
  my framework would handle the new functionality? I think a subclass
  of Block could do a staircase. A subclass of Position could probably
  handle motion, but this would require constant rescheduling of idle
  callbacks to handle the redraws. Dual-task exp't, especially if the
  tasks appear at different times, would be tricky. Maybe? Perhaps a
  subclass of Trial could handle this, although it would require a bit
  of trickery on the part of TimingHdlr's in order to get the Trial to
  do the right thing.

* (25-Jun-1999, done 26-Jun-1999) Stop messing around
  and just rename Expt to Block and ExptDriver to Expt, dammit! OK, I
  renamed Expt to Block but I think I'll leave ExptDriver as is for
  now, partly because renaming ExptDriver to Expt could wreak havoc in
  my RCS files with the old expt.h/expt.cc files.

* (25-Jun-1999, nix 26-Jun-1999) ExptDriver should be able to
  do arbitrary ordering of blocks? Or should it just run through
  blocks in sequence... Yes, just in sequence is fine. Just need to
  create enough blocks as necessary, then address the individual
  blocks by id.

* (26-Jun-1999, under way) OpenGL crash problems
  raise issue of who should really be allowed to call OpenGL? Best to
  keep all graphics calls as localized as possible... this still needs
  some work. [Later 16-May-2000] This is a slow migration, but the
  necessary architecture is now in place with GWT::Canvas.

* (27-Jun-1999, done 27-Jun-1999) Moved the decision
  to abort a trial based on response value from ExptDriver back into
  ResponseHandler... this makes more sense since this way ExptDriver
  doesn't have to care about valid/invalid responses; it just does
  what it's told. KbdResponeHdlr now either sends ExptDriver a
  processResponse or abortTrial message depending on what keysym it
  receives.

* (21-Jun-1999, done 27-Jun-1999) Need to remove
  certain implicit dependencies that remain in ExptDriver upon
  KbdResponseHdlr instead of generic ResponseHandler. Also, there are
  some icky order dependencies in ExptDriver relating to who of
  Block/ResponseHdlr/TimingHdlr is first to receive certain
  messages. OK, I think there are no order dependencies now that I've
  removed the requirement that every trial must have a response-- now
  there are three valid ways for a trial to end: 1) with a response),
  2) with an abort, or 3) with neither a response or abort. The only
  tacit dependency remaining on ResponseHandler is the convention of
  using -1 for an invalid response; this is probably fine, but should
  be stated more explicity somewhere. (Maybe as a static constant in
  ResponseHandler?) Yes, I think that's a good idea. Done.

* (25-Jun-1999, done 28-Jun-1999) TclCmd's should be able
  to get and return lists. Just need some translators from Tcl list's
  to C++ STL lists. --> Easy! Just added set of functions appendVal()
  to append the basic types as list elements to the Tcl result, then
  added a template function returnSequence() which works with a
  sequence like the STL algorithms, by incrementing and using one
  iterator until it matches another iterator.

* (28-Jun-1999, done 28-Jun-1999) The semantics of loadFaces
  are a little bit wacky now... need to dump the first_id argument
  since it now does nothing and is unnecessary anyway. --> Done.

* (27-Jun-1999, done 28-Jun-1999) I've got some fairly dangerous
  overloading in Tlist-- where getTrial may or may not create a new
  Trial depending on whether the calling Tlist is const or not. This
  is not the kind of think I'd like to have happen
  implicitly... should change name of one of the functions. --> OK,
  changed the const version of getTrial() to getTrialConst() so at
  least there are no implicit catastrophes now.

* (25-Jun-1999, done 28-Jun-1999) Must test timing issues
  Add stopwatch to ExptDriver. Add requestedTime to Trials? to Blocks?
  Then ExptDriver can check actual time vs. requestedTime and make up
  the differences between Trials? between Blocks? --> OK, have a
  stopwatch in timer now that clocks each trial. Gee, maybe the
  TimingHandler should do what it says? I.e., it should handle time,
  and therefore be the sole source of timing info during the
  expt... if the ExptDriver needs to know the time, it asks the
  TimingHandler, and the ExptDriver should feed this info to Block in
  order to record the response time. This functionality must be part
  of the TimingHdlr base class. OK, added clock to TimingHdlr, and
  added public getElapsedMsec function to retrieve the elapsed time at
  any point in the Expt. Added clock to ExptDriver to measure the
  total time of the Expt.

* (25-Jun-1999, done 29-Jun-1999) Who owns the ".togl" widget?
  Is it another aspect of ExptDriver?  This is a glaring outstanding
  implicit dependency among different files in the project... again I
  think this is an unfortunate consequence of Tcl's 'feature' of
  gluing unrelated code together. The ".togl" is basically
  mischievously disguised global data. This is what happens when
  variables are untyped, declarations are not required, etc.-- design
  flaws can creep in and lurk. [Later] Need to get rid of the ugly
  implicit dependency everywhere on the presence of a widget named
  ".togl". Need to basically make the widget a singleton... 1) ensure
  that only one Togl widget can exist at a time, and 2) provide global
  accessibility to this widget, either through its Tk pathname, or
  through a 'struct Togl*' (or both?)  ... fixed.

* (28-Jun-1999, done 29-Jun-1999) Idea: all ObjTogl functionality is
  provided in Togl:: namespace in Tcl; no direct calls through widget
  command are needed (or allowed; the widget pathname should is
  private in theory)... this allows only one widget to be created. OK,
  I think there really isn't any way from preventing extra togl
  widgets from being created via the 'togl' command, but it is
  possible to ensure that only the first widget becomes the priveleged
  singleton through the rest of the C++ program. OK, now I've removed
  all the nasty dependencies on '.togl' throughout the C++ program,
  but still need to convert the Togl procedures over to TclCmd-style.

* (29-Jun-1999, done 29-Jun-1999) Need to convert
  the Togl procedures over to TclCmd-style. Done.

* (16-Jun-1999, done 29-Jun-1999) Would be nice to have
  a typeless interface that the from which the lists could inherit
  their non-typed commands (such as count(), reset(), getValidIds(),
  etc.). This way, generating TclListPkg's would be totally
  idiot-proof... [Later] Actually, using templates there is no need
  for a base class... templates provide ad-hoc polymorphism, where the
  types to be used only have to share member functions with the same
  signature. This allows the functions to be non-virtual, giving
  better performance, at the expense of run-time polymorphism (which
  is not needed in this case anyway). Templates are cool!

* (21-Jun-1999, done 29-Jun-1999) What are the different ways
  we'd like to make Trials?  --make one Trial per GrObj, with trialid
  == posid, for a given range of GrObj's, and using a specified
  posid. --> This is exactly done by makeSingles.

* (note 30-Jun-1999) OK, so templates are great for code sharing
  and are very expressive, but they aren't so great for rapid
  development...  code sharing through templates tends to cause lots
  of recompilation.

* (21-Jun-1999, done 30-Jun-1999) Probably need to think
  about a way to split up the duties of IoMgr into several smaller
  factories...  probably need to create factories and then somehow
  register them with IoMgr? Let's see... each class hierarchy should
  have a factory, each class in the hierarchy should override some
  function to return a new instance of it (like newGrObj), and the
  factory should provide functions to obtain an object by name. The
  bindings between names and creational functions should be able to be
  generated at run-time (at initialization). How will this interact
  with the PtrList's?  Currently they all use IoMgr to create new
  objects from a stream... if each object hierarchy has its own
  factory, then the PtrList's will also have to be parameterized by a
  type of factory. Hey this Factory thing is pretty cool, all because
  of templates. How to ensure that all types are registered with a
  factory before it is used?  IoMgr depends on static knowledge of all
  the types it might have to instantiate... this could be fixed by
  switching over to a Factor that allows types to register
  themselves... the types could all register themselves in the Tcl
  package init procedures, but this introduces a somewhat unsightly
  dependence between the core of the C++ app (namely the IO factory)
  and the specifics of the Tcl app (namely the package init
  proc's). Well, actually I guess it's not so bad-- *somebody* is
  going to have to do the intializations of the factory, and there is
  no reason that it couldn't be someone other than the Tcl init proc's
  if necessary. OK, this is all done. But still might want to split
  IoMgr into separate categories?

* (28-Jun-1999, done 30-Jun-1999) Need algorithm in Bitmap
  to center Bitmap's on a point in GL coordinates. --> Done.

* (1-Jul-1999, done 1-Jul-1999) Could change GrObj organization
  so that subclasses don't have to deal with grNewList, glNewList,
  etc. Instead, use the method template pattern so that a GrObj method
  does the grNewList etc., then calls a virtual function to do the
  actual GL work, then calls grPostUpdated at the end. This would also
  allow GrObj's to be toggled between compiled- and direct- mode
  rendering. Virtual function should be called grRender(), and
  grRecompile becomes the template method. Done.

* (25-Jun-1999, done 1-Jul-1999) Need a TextString subclass
  of GrObj. This will require fonts--> this will require using
  Togl_LoadBitmapFont --> this will require a struct Togl* --> this
  will require global access to a Togl* --> this will require making
  the Togl widget a singleton somehow. OK, now have global access to
  Togl widget... but now, who should control loading/unloading of
  fonts? Each TextString certainly doesn't need its own copy of each
  font... OK, I've implemented Gtext class. There is only one font
  loaded at a time for the entire class; each time time a Gtext is
  drawn, it checks to see if the currently loaded font is the one it
  used last time it compiled its display list and recompiles itself if
  necessary before drawing.

* (1-Jul-1999) Time to get back to testing
  OK, I have a bit more flexible framework for testing now; each Tcl
  package gets its own XXX_test.tcl file, and all of these files are
  sourced in the main grshtest.tcl file. The idea, though, is that any
  of the individual test files should be able to stand on its own-- it
  should acquire and release any resources that it might need
  locally. Now that I have generic TclCmd's etc. working, it would be
  nice to make the testing process a little generic as well, such that
  tests that are repeatedly testing the same C++ code (such as the arg
  check for a TVecAttribCmd, for example) can be a bit more automated.

  [Earlier] I squashed a bug that was basically a result of having
  written less-than-accurate function names. ExptDriver::stopTime was
  used to cancel all timer callbacks, but it also aborted the current
  trial, which is not necessarily implied by its name. Aborting the
  trial in the middle of ExptDriver::handleResponse then had a
  disastrous effect. Better rename these functions quick. Also, there
  should have been a test in place to identify this bug... better write
  those ExptDriver tests quick.

* (29-Jun-1999, done 2-Jul-1999) Analogously to TclCmd::returnSequence
  it would be great to be able to extract from a Tcl list arg into an
  STL back_inserter iterator. For one thing, this would allow
  ItemCmd's to be vectorized, applying the same operations to multiple
  items at once. OK, I have the necessary functionality in TclCmd now,
  but still need to add the appropriate stuff to TclItemPkg. Need to
  define some TclCmd subclasses in the .cc file that handle vectors of
  items. Clients will probably create these with something like
  declareVecAction, declareVecGetter, declareVecSetter, etc. OK,
  actually don't need special declareXXX functions, since I think all
  commands can be vectorized by default; there is negligible run-time
  cost even in the case when the vector is only one item long, and for
  looping, this method is definitely faster (20%?) than doing the
  iteration within Tcl. But, how to deal with VecSetter's? Do they set
  a bunch of items to one value, or do the set a bunch of items to a
  bunch of different values? And if the command takes two lists as
  input, then what happens if the lists are not the same size?
  Clearly, if there are more values than items we can probably just
  silently throw away the extra values. But what if there are more
  items than values? Maybe the best thing is to match values
  one-for-one with items until we run out of values, then use the last
  value to set the remaining items. ... Now why in heck doesn't the
  compiler want to generate a specialization for 'const string&' of
  TVecGetterCmd? Should be able to derive TVecAttrib command from
  TVecSetterCmd and TVecGetterCmd somehow in order to avoid
  duplication. OK, did the multiple inheritance thing. Everything is
  working... this is awesome? I have all this cool template stuff and
  multiple virtual inheritance going on in the same package... yes,
  people are right when they say it's very complicated (MI +
  templates) but it's also amazingly expressive.

* (2-Jul-1999, done 2-Jul-1999) Now that vectorized commands
  are working, we can change the semantics of Block::addTrials so that
  rather than taking a first/last id pair, it can just take a sequence
  of ids. Actually, the C++ class just needs a function addTrial()
  that adds one trial at a time, and BlockTcl::addTrialsCmd can
  actually do the iteration through the sequence. OK, added
  Block::addTrial to C++ class, added BlockTcl::addTrialIdsCmd to Tcl
  interface that takes a sequence of trialids (kept the old addTrials
  command around just in case...)

* (3-Jul-1999, done 3-Jul-1999) Need a way to
  distinguish between Tcl package name and the namespace name that is
  used with the package (since the two may require different
  capitalization). OK, this is fixed by just having TclPkg enforce the
  correct capitalization when it calls Tcl_PkgProvide. This way,
  packages can use whatever capitalization they like for their
  namespace prefix.

* (3-Jul-1999) Maybe that weird extra stuff in Tlist
  should be split off into its own class, since now it is isolated
  from the internals of the list via the derivation from PtrList. This
  is of one of those heuristics where a class shouldn't contain
  disjoint areas of functionality. Now, I think the extra Tlist stuff
  could probably fit in with that amorphous ObjTogl/ToglConfig/Togl*
  abstraction that is beginning to take shape, since ObjTogl was the
  primary client of the Tlist's extra functionality in the first place
  anyway.  [Earlier] I think in the larger picture, the singleton Togl
  wants to be a new class, which encapsulates the Togl*, the
  ToglConfig*, and the GfxAttribs info, and makes all of the important
  info publicly accessible. Yes, this would definitely fit in with the
  TclItemPkg picture... it would allow a lot of the code to be moved
  out of ObjTogl command functions and into some other
  abstraction. OK, these things are coalescing into Toglet right
  now. But some remaining questions... the widget should be a
  singleton, but conceivable we might want to change some
  functionality at runtime, such as how it handles reshapes, redraws,
  etc. Do these things still need to be wrapped in a polymorphic
  ToglConfig-like subobject that can be replaced with a different
  subobject at runtime? Right now I'm gradually migrating existing
  functionality into the ToglConfig class... need to move in the
  error-handling code that used to be in ObjTogl. OK, error-handling
  code for setters has been moved. Next: (1 reconsider) remove project
  dependencies on GfxAttribs (it can be replaced with ToglConfig now),
  (2 done) get rid of toglDisplayFunc and toglReshapeFunc in ObjTogl,
  replace them with virtual functions in ToglConfig, (3 done) remove
  loadFont from Gtext (it's replaced with Togl::loadFont). OK, this is
  all done except I'm going to reconsider whether to get rid of
  GfxAttribs...

* (3-Jul-1999, done 3-Jul-1999) Maybe PtrList<T>::iterator should
  return a pair<int, T*>?  This makes PtrList look suspiciously like a
  map... which I guess is really how I am using it. The ids are just
  used as tags... I'm just wary of using an STL map for implementation
  since they tend to be quite sluggish... wish I had a hash_map. At
  least PtrList's interface is reasonably well encapsulated so I could
  try new implementations. I guess I could even try an implementation
  using Tcl's hash map API... Trying the Tcl_HashMap implementation
  now. Maybe need to provide two kinds of iterators: one for fast but
  non-sequential access using Tcl_HashSearch, and one for slower but
  sequential (sorted) access through the keys. ... OK, I see now that
  the idea of the elements being ordered sequentially *was* an
  important part of the interface provided by the old implementation
  (I think), so for now I'll stick with the old implementation.

* (5-Jul-1999) I could improve the efficiency of id-list manipulations
  in Tcl by adding a new Tcl object type that stored an STL vector or
  list as its internal rep. Then there would be no translations between
  Tcl lists and STL vectors/sequences required... Also I could make a
  Tcl_ObjType for the ids themselves, where the internal rep is a
  PtrList::iterator, and the Obj is able to provide an Item* from the
  list when asked. But... how to avoid having to put functions for this
  stuff all in the TclCmd base class? Maybe TclCmd subclasses could add
  the necessary functionality through getVectorFromArg, getGrObjFromArg,
  etc. Probably I would want to wrap up Tcl_Obj in a C++ class TclObj
  before doing any of this... this would actually be a great chance to
  use reference-counted proxy semantics... the C++ class would be a
  proxy for the Tcl_Obj, so the TclObj objects could be passed around by
  value if their constructors called Tcl_IncrRefCount and the
  destructors called Tcl_DecrRefCount (but how likely is aCC to ensure
  that all the destructors are called in the face of
  exceptions?). ... Hold on, maybe this is all too much-- it's pretty
  complicated, since Tcl_ObjType is like a metaclass (the class of a
  class), and Tcl_Obj is like a polymorphic class. [Later] The need for
  a vector Tcl_Obj is eliminated by the introduction of STL-style
  iterators than can retrieve elements of a template type from
  Tcl_Obj's.

* (5-Jul-1999) To trash or not to trash GfxAttribs?
  It's functionality is superfluous at the moment, since all the
  information it provides is available in ToglConfig, but switching
  dependencies from GfxAttribs to ToglConfig will tend to introduce
  coupling as well as recompiling, since ToglConfig is probably more
  volatile than GfxAttribs...  Something to think about. [Later]
  GfxAttribs is gone bye-bye...

* (7-Jul-1999, done 7-Jul-1999) Cut out ~300 lines of code
  by introducing a new template TclPkg, ListItemPkg<class C, class
  List>, derived from CTclIoItemPkg. This class takes a List& argument
  in its constructor; this allows the class to implement
  getCItemFromId and getIoFromId automatically without having to
  forward these operations on to derived classes (all of whose
  overrides were pretty much duplicates anyway). In addition,
  ListItemPkg provides a default "constructor" or creator for its
  items, since again, all of these implementations were virtually
  identical. Also, I improved ListPkg in the same way so that it takes
  a List& argument in its constructor, allowing it to implement
  getCItemFromId and getIoFromId itself.

* (3-Jul-1999, done 8-Jul-1999) Tlist should inherit from PtrList
  so that it can share functionality, in particular iterators. The
  PtrList iterators should eliminate the need for getValidIds... OK,
  Tlist now inherits from PtrList like the rest of the lists.

* (8-Jul-1999, done 9-Jul-1999) There is almost certainly still a bug
  in the block(), responseHdlr(), and timingHdlr() members of
  ExptDriver... they catch internally an InvalidIdException that might
  be generated by a failed list access attempt, but then they are
  still unable to return a reference; I think they must instead allow
  the exception to propogate and force the callers to deal with the
  exception. Actually, easier than this would be for callers to simply
  call isValidId() before they try to retrieve an item reference. OK,
  set up a method assertIds() that is called at the beginning of all
  of ExptDriver's event handlers; it checks if there are any invalid
  id's, and if so generates an error message and halt's the
  experiment.

* (7-Jul-1999, done 12-Jul-1999) Should make SoundTcl
  into a now-standard list/item package combo. Need to define a
  SoundList, and this will help other areas of the application since I
  won't have to export playProc from SoundTcl namespace anymore. Also
  this might facilitate writing c++-side beedback procedures for
  response handlers. Sound class should be an abstract class that (in
  theory) can read a variety of sound formats, and play the sounds on
  a variety of audio servers. OK, this is underway. Still need to
  change KbdResponseHdlr to use the new format (in fact, now
  KbdResponseHdlr can "own" the sound that it wants to
  use...). Perhaps should add symbolic constants in Tcl such as
  Sound::OK and Sound::ERR to index the default sounds in the
  SoundList. --> For this, should add linkVar() functionality to
  TclPkg. Also linkConstVar(). All done.

* (9-Jul-1999, done 12-Jul-1999) Should rewrite Sound tests
  for new Sound package implementation. Done.

* (21-Jun-1999, fixed 22-Jun-1999) Bugs!
  Mostly in Block: 1) abortTrial is called when the experiment is
  quit, but not endTrial, so the trial index is off by one; 2)
  responses were getting added twice when both processResponse and
  endTrial were called.

* (3-Aug-1999, done 4-Aug-1999) Really weird...
  I turned on LOCAL_TRACE inside bitmap.cc, and somehow now I am
  getting the exit-trace messages from several other files, such as
  PtrList, HpAudioSound, TclCmd, ToglConfig... This looks very oddly
  like somehow these are the "missing" exit traces that are missed
  when certain functions are exited via an exception throw... but wait
  a minute, why is there even code present for these guys... there
  shouldn't even be trace code compiled in! Have to look at this more
  carefully. OK... now I'm thinking that maybe what happens is this:
  the Trace destructor is defined inline, so the normal destructor
  call at the end of the lexical block is inserted inline; however
  destructor calls that occur due to exceptions must be made via an
  out-of-line function... this means that *lots* of copies of ~Trace
  are lying around, and furthermore some of them probably have
  LOCAL_TRACE defined, while others don't... somehow the linker or
  dynamic loader must pick one of these as the canonical version,
  leading to the undesirable effect that the code that gets called for
  the destructor of a particular Trace object may depend on whether
  that destructor is called inline or out-of-line. This would explain
  why I had noticed in the past that in some cases it appeared that
  Trace objects weren't being properly destructed on exception
  throws... in fact they were being destructed, but just with the
  wrong destructor. There are two solutions, I think: 1) put Trace
  inside an unnamed namespace, so each translation unit can have and
  use its own special copy of ~Trace, or 2) define ~Trace inside
  trace.cc, and make LOCAL_DEBUG part of the state of the Trace
  object. I guess I'll go for solution (1) in the name of efficiency,
  since the Trace objects are fairly ubiquitous-- I'd like to avoid
  out of line calls when possible. [4-Aug] OK, I tried using an
  unnamed namespace, but this didn't seem to work... anyway I think a
  better solution is to have a member of Trace be a boolean that
  controls whether trace messages are printed; this way all Trace
  objects are the same-- the conditional compilation only controls
  whether they are constructed with a boolean member as true or as
  false.

* (7-Sep-1999, done 8-Sep-1999) Wow!
  X11 bitmap routines are a good 10x faster than glDrawPixels() at
  putting the face/house bitmaps onscreen. To this end, I created an
  XBitmap class that is similar to Bitmap but uses X11 to render the
  images rather than OpenGL. But, duh--these should be related through
  inheritance somehow... probably both XBitmap and GLBitmap should
  derive from an abstract base class. Or... could use an enumerated
  field such as itsRenderMode that controls a submember that actually
  does the rendering... this would allow switching between OpenGL and
  X11 on the fly. The submember class would be something like
  BitmapRenderer. OK, now I've made XBitmap and GLBitmap subclasses of
  the abstract base class Bitmap. In general, Bitmap's public
  functions are non-virtual, but call protected virtual functions that
  do the real work. Where necessary, member data from Bitmap is passed
  to these hook functions.

* (17-Sep-1999, done 21-Sep-1999) GrObj could have a framework
  for unrendering/undrawing that is analogous to the one currently in
  place for rendering/drawing. This would entail storing another
  OpenGL display list. OK, there is now a virtual function
  grUnRender(), that will be used for undrawing if the unrender mode
  of the object is set to GROBJ_DIRECT_RENDER.

* (17-Sep-1999, done 21-Sep-1999) Grobj::update() should be
  non-virtual... any changes that subclasses need to make can be
  handled in grRecompile(). Likewise, GrObj::draw() and
  GrObj::undraw() should probably also be non-virtual. Done.

* (16-Sep-1999, done 21-Sep-1999) GrObj: would be nice to have
  virtual functions to get a bounding box, so that other functions can
  arrange things so that different GrObj's don't collide. Also, would
  be nice to set an internal scale, so that the bounding box
  size+aspect ratio can be set to specific values. Done.

* (21-Sep-1999, done 22-Sep-1999) Could use a Bezier class
  that would store a set of control points, and would be able to
  evaluate the curve at given values of u, would be able to return
  derivatives for given u, would be able to find the maxima for each
  dimension in the range u=[0,1]. OK, I now have a Bezier class that
  can evaluate the curve and its derivative, but I don't have a way to
  get the extrema... Which way to go: analytical or numerical?
  Numerical for now. Just do a rough search for zero-crossings of the
  derivative.

* (8-Sep-1999, done 21-Sep-1999) XBitmap's should be able to
  handle raster data types other than 1-bit-per-pixel bitmaps. This
  will just involve a few switch statements in the XBitmap member
  functions. OK, done.

* (23-Sep-1999, done 29-Sep-1999) GrObj::getCategory() should
  definitely *not* be pure virtual. Most subclasses don't use
  it. There should at least be a no-op default implementation. Also,
  charCount() should be non-pure virtual, since serialize() and
  deserialize() are likewise. Done.

* (9-Sep-1999, done 29-Sep-1999) MorphyFace with 22 parameters
  to control the face is now mostly implemented. With such an
  abundance of parameters, it would be nice to have a helper class to
  represent the parameters... something that contains 1) the
  parameter's name, 2+3) pointer-to-members for get+set functions,
  4+5) the parameter's min+max values, 6) the quantum for the
  parameter. Also, a class static function should be able to retrieve
  a reference to a list of all the parameters. Also, a class static
  should be able to return a particular parameter given the
  parameter's name. Most of this framework could be arranged in a base
  class. ...This is metaclasses revisited all over again--it would be
  a way of moving some of the TclPkg stuff back into the actual
  classes. The nice thing about having a parameter class is that it
  makes it convenient to set up different manipulators that work on
  the parameter. In fact, the TclCmd's that are generated by
  declareCAttrib() are just command-line manipulators. [17-Sep-1999]
  The parameter information such as its name, pointer-to-members,
  etc. does not need to be stored separately for each instance of a
  class... this info should be static somehow. It could be provided
  through template parameters to the Parameter or Property class.

* (1-Jul-1999, done) With new GrObj organization
  it would be simple to add in checks for GL errors in consistent
  places, such as after every call to draw(), undraw(), grRender().

* (3-Oct-1999, done 4-Oct-1999) Need to provide
  non-file way of constructing Fish.

* (2-Oct-1999, done 4-Oct-1999) The Tcl initialization of a class
  should provide a function or variable so that the Tcl side can get
  access to a list of properties and value ranges. Done in
  PropertyListItemPkg<>.

* (4-Oct-1999, done 5-Oct-1999) Need to fix error reporting
  from TclValue's, so that we get only one message, not two.

* (3-Oct-1999, done 5-Oct-1999) Need to check file validity
  in Fish read_file functions. Done by way of porting the read_file
  functions from C I/O library to the C++ I/O library.

* (3-Oct-1999, 5-Oct-1999) loadFacesCmd() should be moved
  to a more generic command in ObjListTcl. Hey--actually, this should
  be a more generic command in PtrList; something like
  loadObjects(). The function should be able to either use a virtual
  constructor, or be told that all the objects are of a specific
  type. OK, this is mostly done--I added a LoadObjectsCmd to
  ObjlistTcl. This can be easily genericized to work with all
  PtrList's at some point, but it's not necessary or worth the hassle
  right now.

* (3-Oct-1999, done 5-Oct-1999) Need to provide a way
  for Response events to trigger in a Timing Handler without
  necessarily canceling all of the start events. Maybe this could be
  the default behavior if the size of the itsResponseEvents vector is
  0.

* (13-Oct-1999, done 13-Oct-1999) ThTcl-ThList::stringify fails
  on SGI with "unable to create object of type
  TimingHandler". Fixed... this was one of many problems related to
  typename mangling under g++, so I set up a demangle() function that
  is implemented per platform to demangle (if necessary) the result of
  typeinfo::name() back into something that looks like how the type
  was declared in the source code.

* (12-Oct-1999, done 13-Oct-1999) Need to implement
  some new GL commands in TclGL, especially those relating to RGBA,
  antialiasing, etc. OK-- implemented glClearColor, glBlendFunc,
  glEnable (which gives GL_BLEND, GL_LINE_SMOOTH, and
  GL_POLYGON_SMOOTH).

* (13-Oct-1999, done 14-Oct-1999) swapForeBack() should become
  a static GrObj function.

* (13-Oct-1999, done 14-Oct-1999) IO should provide
  a static eatWhitespace() utility function.

* (13-Sep-1999, done 14-Oct-1999) Should add a char const
  to IO like SEP that contains a default separator, so that all of the
  serialize() functions don't have to always declare "char sep = ' '".

* (13-Oct-1999, done 14-Oct-1999) setForeground and setBackground
  should take RGBA rather than just RGB.

* (12-Oct-1999, done 14-Oct-199) SGI needs a Sound implementation
  even if it's only a stub.

* (12-Oct-1999, done 14-Oct-199) Need to allow RGBA mode to work
  throught the project--somehow need to encapsulate the modality of
  color index vs. RGBA. Locations of use of glIndex:
  <morphyface.cc>::draw_hair(), Tlist::undraw(),
  ToglConfig::writeEpsFile().

* (15-Oct-1999, done 15-Oct-1999) Did a full implementation
  of IrixAudioSound using SGI's Audio Library and Audio File Library.

* (19-Oct-1999, done 19-Oct-1999) attributeCount() is no longer needed
  in IO.

* (note 19-Oct-1999) For better or for worse
  I think I'm going to allow null pointers to be serialized. This
  involves introducing the convention of using 0 as the IO::id() for a
  null object.

* (22-Oct-1999) Can now write generic IO tests
  which take a class name and a list of properties, and then try
  reading/writing an object to make sure the values of those
  properties are correctly retrieved.

* (21-Oct-1999, done 2-Nov-1999) Fixpt needs to change
  its Tcl class name to FixPt. Done, but injected all the FixPt::
  commands back into the Fixpt:: namespace for the time being to
  preserve backward compatibility.

* (2-Nov-1999) Major flaw in serialize/deserialize semantics
  when doing virtual construction with newIO, we first read the
  typename, and then deserialize using ~IO::TYPENAME in the
  flags. However, this turns off typename reading in base classes as
  well, which is disastrous. For now, I guess we can explicitly force
  typenames to be used when calling serialize or deserialize on a base
  class, but this is pretty ugly.

* (3-Nov-1999, done 3-Nov-1999) Need a way to script experiments
  so that we can run several experiments in a row, and a new
  experiment can depend on the subject's performance in a previous
  experiment. OK, I added a callback from ExptDriver to Tcl that
  occurs when an experiment is completed. This is mediated by the Tcl
  proc Expt::doUponCompletion. This allows for varying logic at the
  end of an experiment, for example, whether to run another experiment
  can be decided based upon the results of the previous experiment.

* (3-Nov-1999, done 3-Nov-1999) ExptDriver needs
  some major refactoring... probably best to go the same route as with
  GrObj: put all data in a private implementation class, then
  eventually put all behavior in the implementation class. OK, I've
  set the ball rolling here by moving data+behavior into
  ExptImpl... eventually this behavior will become better factored.

* (8-Nov-1999, done 8-Nov-1999) Problem with AsciiStreamReader::readRoot()
  if a root object is passed in, it is not assigned to the correct
  slot in the itsCreatedObjects map, since its current IO::id() is
  used, which may not be the same as the id that it had when it was
  serialized. We'll need to use the first id that is read from the
  stream to determine the correct value for the root id. OK, this is
  done, although it looks a bit ugly. Maybe I'll find a way to
  refactor...

* (8-Nov-1999, done 9-Nov-1999) In KbdResponseHdlr
  need to determine which functions can allow exceptions to propagate
  out, and which functions must catch exceptions and convert them into
  a Tcl_BackgroundError. I suppose a good first guess is that the
  private functions in Impl can let the exceptions go, and the public
  functions should catch them. OK, the error handling has been fairly
  well cleaned up. In particular, there is a try block in
  privateHandleCmd that wraps the call to handleResponse().

* (21-Jun-1999, fixed 9-Nov-1999) Bug!
  my TclObjPtr is woefully broken. The copy constructor was broken--it
  was trying to Tcl_DecrRefCount() on itsObj before itsObj had been
  set to a meaningful value.

* (3-Nov-1999, done 11-Nov-1999) Need to implement
  ExptDriver::readFrom() and writeTo() so we can switch over to using
  Serializer everywhere. To do this, we need to allow mulitple roots
  to be read and written via Reader/Writer. ... OK, I've handled this
  instead by allowing owned objects to be read and written-- this way
  ExptDriver acts as though it owns all of the singleton PtrList's,
  and reads/writes them as its own.

* (9-Nov-1999, done 16-Nov-1999) Need to implement readFrom/writeTo
  for Trial. Done. The main innovation to make this easy was to
  introduce stream insertion and extraction methods into the class
  Value. This allows subclasses of Value to be written or read in
  place by a Reader or Writer. This technique was used to handle
  Trial::Response and Trial::IdPairs as value types.

* (8-Nov-1999, nixed 16-Nov-1999) Value should have
  getStringRep() and setStringRep() virtual functions so that we can
  avoid switch statements on getNativeType() inside
  AsciiStreamReader/Writer. The need for this has effectively been
  averted by the introduction of virtual functions printTo() and
  scanFrom() to handle stream insertion and extraction for Value's.

* (4-Nov-1999, nixed 16-Nov-1999) Reader/Writer needs
  to have facilities for in-place objects (i.e. owned objects), that
  are referenced only once in a hierarchy and therefore can be handled
  in place rather than by writing an IO id number and deferring the
  read/write. This will help to make for more readable files. Function
  should be called read/writeOwnedObject. Hmmm... this is trickier
  than I thought-- reading objects in-place would require a
  significantly more complex main read loop, since we essentially need
  stack frames for each level of nesting-- there will be multiple sets
  of attributes active at any one time. Perhaps it's best to defer
  this functionality until later, since it is mainly a convenience to
  make files more readable. Wait a moment... there's a distinction
  here between writing owned objects, and writing objects in
  place... handling owned objects *is* definitely important in order
  to be able to implement reading/writing Singletons, for
  example. [Later] ... OK, I've avoided this issue by provided class
  Value with methods printTo() and scanFrom(), which are intended to
  do simple stream insertion and extraction. Clients can subclass
  Value for types that should be treated as value types, and therefore
  be read and written in place. This helps keep a clear distinction
  between value types and object types.

* (nixed 17-Nov-1999) "generic" file descriptor format???
  [this has all been nixed by the introduction of Reader/Writer, which
  allows for generic serialization and deserialization] still need to
  have ways to change internal format, and thus serialization format,
  of objects while still being able to read old formats.

  Wow... I just realized what the Holy Grail of this IO stuff would
  be... each class would not even have to write its own serialize and
  deserialize functions. Instead, it would have functions to provide a
  list/vector of serializable's that it contains and would like to
  have considered for reading and writing. Then, this function would
  be called by a generic serialize or deserialize function in the base
  class (IO) when an object needs to be read or written. This would be
  a Good Thing. But how would this work with different revisions of
  classes??? (Later...) Almost as good would be able to ignore order
  when serializing/deserializing, and read/write members by name.

  There is the thorny issue of memory management here... what to do
  with all these little IoWrapper objects that will be floating
  around? Are the part of an objects state (in which case they are
  wasted most of the time) or are they created dynamically when a read
  or write is impending? In the latter case, how can we treat handle
  both dynamically allocated IoWrapper's and more hefty IO classes
  without mucking up the memory management?

  Think about more general way to do serialization. Concern is that
  file format is not neatly stated in one place, but rather must be
  maintained across serialize, deserialize, and a charcount
  procedure. Charcount could be improved by using a special ostream
  that doesn't really write anything but instead counts
  characters. Then the charcount could be obtained by running
  serialize onto this special ostream, then calling the ostream's
  count() function.

  Make serializable wrappers for built-in types, like ioInt, ioDouble,
  etc. that implement the IO interface. Then these could be used for
  the members of classes derived from IO. !!! Actually, the member
  variables don't need to *be* these wrappers. Instead, each class
  could hold a collection of references/pointers (?) to serializable
  objects. The ioInt wrapper would just hold a reference to the actual
  int member variable. The list of serializables would be established
  in the constructor, the appropriate references made, etc.... then
  serialize/deserailize is just a matter of a simple for each!!! This
  would avoid any possibility of inconsistencies between
  serialize+deserialize. How would this interact with maintaining
  compatibility with older versions of objects?

* (1-Jul-1999, nixed 17-Nov-1999) Idea
  could handle serialization of vectors by defining a new vector
  iterator that is a subclass of IO?

* (19-Jul-1999, done ???) Idea for how to do feedback
  through response handlers: response handlers take a list of pairs
  where each pair consists of a Tcl expression and a Tcl script. When
  a response is given, the Tcl expressions are evaluated in order
  until one evaluates to true; in that case the associated Tcl script
  is executed (probably plays a sound or something), and the feedback
  procedure returns. Oops... how do we pass information about the
  response value to the expressions? Set up a Tcl variable that
  contains the response value before we evaluate the expression, then
  unset it afterwards.

* (13-Oct-1999, nixed 17-Nov-1999) Need a better way
  to robustly serialize string's, avoiding problems related to leading
  whitespace, etc... [Later] This is all taken care of by
  Reader/Writer

* (21-Jun-1999, done ???) There should be an easy way
  to automatize the code for creating items in Tcl packages... it just
  needs to be a command class parameterized by the type of object to
  create, and the list to add it to. Done, with TclItemCmd.

* (note 11-Nov-1999) Should GrObj's draw function take
  a Window argument, where the Window function provides the graphics
  primitives such as draw line, etc...? Yes! Actually, I'd call it a
  Canvas argument, and it could include the functionality of the
  widget part of ToglConfig.

* (note 10-Nov-1999) I think conceptually there are two
  different abstractions in ToglConfig-- one represents the widget,
  with its screen width + height, and the other represents the
  "camera", or the view into the OpenGL world, with its viewport,
  perspective/orthographic projection, etc.

* (28-Jun-1999, done 18-Nov-1999) Need Stopwatch class
  to handle all this timing stuff that needs to go on.

* (20-Nov-1999, done 20-Nov-1999) Could make Factory
  a little faster to compile by avoiding the #include <map>. 1) Make a
  non-template CreatorMapBase class that has an Impl class that hides
  a map<string, void*>, with implementation in the .cc
  file. CreatorMapBase has an abstract destroy(void*) function that is
  implemented to take care of deleting the elements. 2) Make a
  typesafe templated wrapper around CreatorMapBase. 3) Factory<Base>
  uses CreatorMap<Base>. Done.

* (20-Jul-1999, done 21-Nov-1999) It would be highly prudent
  to split off the implementation of PtrList<T> into a non-template
  base class IoPtrList. The implementation of PtrList::serialize and
  PtrList::deserialize requires that T be derived from IO anyway, so
  this doesn't really restrict things. Then PtrList<T> could derive
  from IoPtrList and achieve type-safety with casts to and from IO*;
  furthermore PtrList<T> could now be defined in a header file alone
  using simple inlines, avoiding explicit instantiations. This would
  eliminate nearly all of the code bloat caused by the current six
  instantiations of PtrList<T>, and would also significantly reduce
  the recompilation time associated with changes to the implementation
  of PtrList (now IoPtrList). Oops... PtrList::deserialize requires a
  dynamic cast to ensure that the created object is of the correct
  type... maybe we can fix this by adding a pure protected virtual to
  IoPtrList called typeCheck(IO* p), which will be implemented in the
  derived PtrList<T> to test dynamic_cast<T*>(p) for success. This can
  be easily inlined. Arrgh. I implemented IoPtrList, but then when I
  got to implementing PtrList<T> as a private derivative of IoPtrList,
  I realized that the getPtr() functions in PtrList<T> must do a
  *dynamic_cast*, not a static_cast, in order to convert the result of
  IoPtrList::getPtr (which is an IO*) into a T*. This incurs a
  significant runtime cost, whereas a static_cast would have none. Is
  there no way to avoid this mess, i.e. to allow one underlying
  implementation of an IO* list, yet allow type-safety through
  templatized wrappers? I think somehow it should be possible, with
  the idea that a dynamic_cast may be necessary when storing
  pointers. [Later] ... OK, this is finally done. I split off the
  implementation of PtrList into two base classes--VoidPtrList and
  IoPtrList. VoidPtrList provides the basic storage management in a
  vector<void*>, and delegates the destruction of pointed-to objects
  to the abstract function deletePtr(). IoPtrList provides the IO
  operations, and delegates the cast to/from IO* to abstract functions
  fromVoidToIO() and fromIOToVoid(). PtrList<> then provides a
  typesafe wrapper for all of this functionality. It stores the
  pointers by static_cast'ing between void* and T*; IO*'s are
  retrieved by static_cast void* to T*, then dynamic_cast T* to IO*.

* (21-Nov-1999, under way) Would like to split project
  into loosely coupled subprojects that can be used separately in
  other projects. Each subproject should generate its own library. OK,
  I think the way to manage this large task is to split the steps into
  1) logically partitioning things into namespaces, 2) physically
  partioning things into different libraries, 3) physically
  partitioning the source + libraries into different directories, and
  4) generating separate makefiles for each directory. I've started
  this process with doing 1+2) for the Tcl namespace, and the tclworks
  library.

* (30-Nov-1999, done 30-Nov-1999) How to avoid 'unused variable'
  warnings with FactoryRegistrar's? ... moved the registration from
  the constructor into a static operation.

* (24-Nov-1999, done 1-Dec-1999) Should refactor Bitmap
  with an Impl structure so we can add private functions like an
  invariant.

* (1-Dec-1999, done 1-Dec-1999) Can avoid the need for
  a global Experiment by passing an Experiment* argument to all
  participants in Experiment (such as TimingHandler, ResponseHandler,
  etc.).

* (2-Dec-1999, done 2-Dec-1999) BmapRenderer should be able to
  defer calls to bytesChangeHook() until just before doRender() is
  called... this way, bytesChangeHook() can have available the
  Canvas/Window argument it needs to extract X11 info. Who is
  responsible for this? BmapRenderer itself, or its owner? Aha!
  Actually, bytesChangeHook() doesn't need to pass in arguments... it
  is just a way of notifying subclasses that the bytes of
  changed... if they care, they can maintain a bit that keeps track of
  this... then, when doRender comes along, they can update if
  necessary before doing the drawing! This should be more efficient as
  well, since it avoids unnecessary bit-twiddling if multiple byte
  changes occur between calls to doRender().

* (1-Dec-1999, done 2-Dec-1999) Should work to uncover
  cyclic dependencies uncovered by ldep. Main ones are GrObj<->Bitmap,
  and ExptDriver<->TrialEvent, TimingHdlr. Done... this was a good
  lesson in the benefits of abstract protocol classes...

* (3-Dec-1999, done 3-Dec-1999) writeResponsesProc should move
  out of TlistTcl and into a separate TlistUtils component. Done.

* (14-Oct-1999) I'm just realizing there are two main ways
  objects get drawn on the screen... through TlistTcl::showCmd, and
  through TlistToglConfig::display(). These two should do exactly the
  same thing, and probably share an implementation. Last remaining
  problem is how to store information about the current
  trial... specifically, when Block calls drawTrial()--if the window
  triggers a redraw callback, it won't have any way to know about the
  current trial. We could add a setCurrentTrial() method to the
  Experiment abstraction... but this seems a bit out of place,
  perhaps? Still, it might be the best way to avoid dependencies. OK,
  all of the drawing stuff has now been moved into TlistWidget, which
  maintains the current trial and visibility.

* (8-Jul-1999, nixed 5-Dec-1999) Idea for how to unify
  ItemPkg's that require an id and those that don't, and also allow
  Pkg::with statements... use the idea that an id of -1 means "use the
  default item". In pkg's where an id is not required, the default is
  to "always use the default", but where an id is required, there
  could be a 'Pkg::with id' command to specify which item should be
  the default if an id is not given or is -1. ...However, would this
  really help things? Would the length of the argument list have to
  change when we are inside a 'with' scope?

* (8-Jul-1999, done 5-Dec-1999) Tlist still has this kooky
  augmented interface... some of the functionality could be moved out
  to the new Toglet structure, and some of it is just plain not needed
  (like addToTrial... this can be done with a getPtr followed by
  Trial::add). redraw(), undraw(), clearscreen(), etc. sound
  oh-so-suspiciously like they belong with the Togl stuff.
  loadFromObjidsOnly could go in some TlistBuilder class (along with
  makeSingles, makePairs, makeTriads, and makeSummaryTrial, I might
  add). ... This is now all done.

* (6-Dec-1999, done 6-Dec-1999) More things to add to Canvas
  flushOutput() function. StateSaver class to manage
  push/popState. clearColorBuffer().

* (6-Dec-1999, done 6-Dec-1999) Remove ExptDriver's dependence
  on GLCanvas::theCanvas() by adding a getCanvas() function to
  Widget(), and implementing this in ToglWidget to return
  GLCanvas::theCanvas().

* (5-Dec-1999, done 6-Dec-1999) GfxAttribs stuff should move
  into Canvas... isRgba(), isColorIndex(), isDoubleBuffered(),
  hasPrivateCmap(), screenPpi()?

* (1-Dec-1999, done 6-Dec-1999) OK, now we desperately need
  a Canvas argument to the grRender() functions. This would avoid all
  this muck about trying to initialize X11 info correctly in
  XBmapRenderer-- instead, we could just pass a Canvas argument that
  contains (or can fetch) the necessary X11 info. How would this
  Canvas get passed around? Needs to end up at GrObj::draw(), from
  Trial::trDraw(), from Block::drawTrial() or
  TlistWidget::safeDrawTrial.

* (done 6-Dec-1999) Eliminated GfxAttribs from the project.

* (7-Dec-1999, done 7-Dec-1999) Should move the declarations
  of TVecSetterCmd, etc. out of tclitempkg.cc and into the header file
  so that they can be reused via inheritance. Done.

* (7-Dec-1999, done 7-Dec-1999) Can add Tcl_Interp* argument
  to ExptDriver c'tor now.

* (7-Dec-1999, done 7-Dec-1999) Potential unsigned problem
  in TclItemPkg with 'max_valn = vals.size() - 1'. Fixed with check
  vals.size() >= 1.

* (6-Dec-1999, done 7-Dec-1999) The TclPkg's need to be able to
  get a hold of a Canvas in order to properly call some functions now,
  like GrObj::update(), and potentially
  GrObj::getBoundingBox(). Probably we need to provide global access
  to an Experiment*, from which we can retrieve a Canvas*. OK, this is
  done with the Application abstraction, which can fetch an
  Experiment*.

* (11-Dec-1999) Ugh. Lost about eight days of work in the crash of
  snowball2. So, goal #1 is to come up with my own backup plan for
  this project so that I don't lose any more 2,000 lines of source
  code. Need to have a 'make' target that will do everything needed to
  tar the source files and ftp them somewhere safe. ... Very
  thankfully, Anne was able to restore the contents of my home
  directory from snowball2 after some "hardcore scraping". Hopefully
  I've learned a lesson here... backup backup backup!

* (7-Dec-1999, done 16-Dec-1999) I guess I need to split
  tclitempkg into two componenets, one with TclItemPkg, Getter,
  Setter, Attrib, and Action, and another with CTclItemPkg,
  CTclIoItemPkg, etc. OK, this is done by creating "tclitempkgbase.h"
  to contain Getter, Setter, Attrib, Attrib, Action, and
  TclItemPkgBase.

* 2000 STARTS HERE

* (19-Jul-1999, nix) Eureka!
  The right way to build various experiments is now suddenly clear (!)
  There must be an abstract base class ExptBuilder that will have
  pretty much one function, build() (but how does it get the params
  that it needs?). This abstract class can have a Tcl interface
  associated with it. Subclasses will know how to build specific types
  of experiments, such as triads expt's, pairs exp'ts, facefinder
  expt's, etc. In particular, one subclass could do all its work in
  Tcl by just taking a Tcl script as its constructor argument, and
  Tcl_Eval'ing that script in its build() function. This class would
  still allow great flexibility in expt-building since Tcl build
  scripts could be changed without recompiling; however the framework
  allows more stablebuild scripts to be migrated to their own
  subclasses on the C++-side. But wait... what advantage is there to
  having all this stuff in virtual functions? i.e., where is the
  client that will benefit by not having to know the concrete class of
  some ExptBuilder?

* (18-Oct-1999, done) How to handle base classes
  in the Reader/Writer interface? We can can just call
  Base::readFrom() or Base::writeTo(), which will generally work,
  unless a base class and subclass happen to share private data
  members with the same name. Perhaps we could avoid this by giving a
  fully scoped attribute name (i.e. 'Face::noseLength') when storing
  or retrieving attributes. The disadvantage of this is that it is
  only a convention, and as such it could be ignored on purpose or by
  oversight. [Later] Now I have a readBaseClass() and writeBaseClass()
  that are able to handle a base class's attributes inline, inside a
  nested {} pair.

* (19-Oct-1999, done) Just realized how testing should work
  for base-class functionality... the base class test package should
  provide a way to run all of the base class tests on a particular
  subclass. In Tcl, this should just be a matter of providing the
  subclass name to a proc, for example 'IO::testSubClass FixPt'. This
  can eliminate a lot of duplicated script code, and allows all
  subclasses to benefit when new base class tests are written. OK, I
  just realized also that it would make sense to put the test
  procedures for a class inside that class's Tcl namespace... this can
  be wholly at the script-level without having to add any C code.

* (5-Nov-1999, done) AsciiStreamReader should gracefully report
  an invalid attribute name, perhaps by throwing a
  NoSuchAttributeError.

* (30-Nov-1999, done 7-Jan-2000) What to do about
  'control reaching end of non-void function' in
  ExptDriver::Impl::block(), responseHdlr(), and timingHdlr()?
  Probably the best is to eliminate the error checking in block(),
  responseHdlr(), and timingHdlr(), and require that the id's be
  checked with assertIds() before these functions are called. We can
  add an Assert to this effect inside block(), etc. Done.

* (6-Dec-1999, done) Replace GrObj::getScreenFromWorld etc.
  with Canvas::... in BitmapRep (how to get the Canvas& arguments
  where they need to be?)

* (11-Jan-2000, done 11-Jan-2000) Need to have quick Tcl access
  to the current trial id. Probably an Expt::currentTrial command for
  Tcl.

* (14-Jan-2000, done 14-Jan-2000) There is some weird problem
  with TlistWidget, perhaps?  Ah yes... first, we didn't initialize
  itsCurTrial and itsVisibility in the constructor, and second of all,
  we didn't check for itsVisibility in safeDrawTrial() before
  attempting to draw.

* (14-Jan-2000, done 14-Jan-2000) Need to flesh out the Pipe class
  that has been introduced in Bitmap::loadPbmGzCmd(). OK, this is done
  so now the Pipe class itself provides access to an fstream& that can
  be used to read/write from the Pipe as appropriate.

* (6-Dec-1999, done 16-Jan-2000) Do we also want Canvas& arguments
  in the bounding box call chain? I added a Canvas& argument to
  GrObj::getBoundingBox(), but not to the protected
  GrObj::grGetBoundingBox()... the only subclass that needed a Canvas
  in order to implement this function was Bitmap(Rep), so for this
  implementation I just retrieve the Canvas from the
  Application->Experiment->Canvas call chain. Thus
  GLCanvas::theCanvas() is eliminated.

* (20-Sep-1999, done 19-Jan-2000) Fixed a nasty memory corruption bug
  that was due to neglecting to set GL_PACK_ALIGNMENT appropriately
  before reading pixel data out of the screenbuffer into main
  memory. Since the value for GL_PACK_ALIGNMENT defaults to 4, it is
  not sufficient to allocate (width*height) bytes if the row size is
  not divisible by 4. How to avoid these problems in the future?
  Include a byteAlignment member in Bitmap, add a utility function
  that reallocates appropriate space for a given width and
  height. [Later] OK, this is handled centrally by Gfx::BmapData.

* (11-Jan-2000, done 20-Jan-2000) Need a way to defer loading
  of pbm files from when Bitmap's are deserialized until when they are
  first used. This would require a way to for the files to be loaded
  on demand. It would have the added benefit that in an fMRI script,
  we would only have to load the bitmaps that are actually used in the
  experiment. Done using BmapData to handle the actuall caching
  process.

* (8-Feb-2000, done 8-Feb-2000) Should think about doing dynamic tracing
  generically, perhaps with a mixin base class. This is basically done
  by using Util::Tracer.

* (27-Jun-1999, done 13-Mar-2000) Maybe Response's want to be
  first class objects rather than lowly int's? This would allow the
  class to have a static member InvalidResponse... would allow
  subclassing of responses... would allow different ResponseHandler's
  to work with different Response subclasses... Interestingly, the
  creation of a Response requires input from both ResponseHandler (for
  the semantic value) and from the TimingHandler (for the response
  time) --> trying to implement Response would probably raise some
  important design issues. Actually, I think I do have a simple
  Response struct that is just local to Trial's right now.

* (3-Mar-2000, done 20-Mar-2000) Ugh. I just now realized how much time
  it takes to compile STL headers. In the past, I didn't try to
  forward-declare STL templates since their declarations can vary by
  compiler... but I now realized (duh!) that (by using an extra level
  of indirection) I can use a "stringfwd.h" file that correctly
  declares string, depending on the compiler. On a tiny test file,
  this reduces the compilation time from about 15 sec to only 1-2 sec
  !!! So I've created "stringfwd.h" and "vectorfwd.h", and I'm going
  to try to use these exclusively when a declaration is needed in one
  of my header files. One issue is that of default arguments... these
  cannot be used unless the full class definition is known. This
  particularly affects uses like 'const string& s = ""', but I think
  the problem can be easily circumvented by removing the default
  argument, and adding instead an overloaded function version with no
  string argument. [8-Mar-2000] Well, now, a week later, the compile
  time for a full debug build of the project has been cut nearly in
  half, and "stringfwd.h" is no longer needed at all!  I've found that
  most interfaces can use 'const char*' just fine, and let clients and
  implementors deal with more complex string classes if they so
  choose. Only 12 translation units now depend on <string>, and 21 on
  <vector>. [20-Mar-2000] Decreased those numbers even more
  now... only 5 translation units depend on <vector>, 9 on <string>, 3
  on <map>, 1 on <list>, and 1 on <set>.

* (21-Mar-2000, done 22-Mar-2000) We need some sort of versioning
  facility for Reader/Writer. OK, but how do we handle versioning
  separately for base classes? Right now, base classes are handled ad
  hoc, with subclasses calling their superclass's writeTo() method
  from within their own writeTo() method. OK, I've added
  readBaseClass() and writeBaseClass() methods to Reader and
  Writer. This allows base classes to be written inline, with a
  bracketed block of the base class's attributes treated as a single
  attribute for its containing class. (In principle, we could now
  handle owned/contained objects in this same way). In order to
  correctly write base classes, we first needed some way to pass the
  base part of an object as an IO* while ensuring that the correct
  overrides of readFrom()/writeTo() would be called (i.e. avoid
  calling the most fully derived version of these functions). This can
  be done with the IOProxy template, which holds a pointer to an
  object of class C, and forwards all IO functions to the C:: versions
  of those functions. So we can pass an IOProxy<Base>* to the
  readBaseClass() and writeBaseClass() functions in order to achieve
  the desired effect. Another structural change was to allow
  AsciiStreamReader to maintain a stack of attribute maps, so that we
  can represent arbitrarily deep nesting hierarchies of objects. This
  involved just changing itsAttribs from an AttribMap to a
  slink_list<AttribMap>. Finally, we needed to allow the string enders
  ('^') that occur inside a base class's attribute to be ignored when
  the end class's attributes are being read... to do this we introduce
  the convention that {}'s protect ^'s, so in order to have reached
  the end of an attribute, we must see a '^' and be at brace level
  0. This in turn required that {}'s be treated specially--they must
  be escaped with '\' when occurring within an attribute string.

* (6-Oct-1999, done 23-Mar-2000) GrObj needs a saveBitmapCache()
  function to dump a cached bitmap to file. Or maybe just a
  writeBitmap() function, that would apply even for objects whose mode
  is not one of the bitmap cache modes, and that would generate a
  temporary bitmap if necessary. [Later] This stuff belongs outside of
  the GrObj class, since it needs only the public interface... perhaps
  it should just go in grobjtcl.cc file.

* (28-Mar-2000, done 29-Mar-2000) Need to implement SerialRh
  (response handler). This will share a lot of code with
  EventResponseHdlr, so we probably need to create a base class for
  both such as FeedbackRh that will handle the inputResponseMap and
  the feedbackMap but will delegate attend() and ignore() via abstract
  functions. ... [Later] OK, so in fact we don't need a new
  ResponseHandler class; instead we can add a new event source that
  translates incoming serial port characters into window-system events
  via Tk_QueueWindowEvent.

* (done 11-May-2000) GOAL: ExptDriver should not have to know
  anything about TimingHdlr's. Done!

  To do this, as usual we should try an easy migration path.
  1) make Trial an abstract class, and move current Trial implementation
  into a derived class
  2) set up abstract Trial functions to take on behavior of Experiment
  functions. At first, ExptDriver can just forward stuff to Trial so
  that we don't have to redefine the handlers' interfaces right away.

** (24-Jan-2000) More flexible behavior
   by putting trial behavior in Trial rather than in ExptDriver.

** (9-May-2000) I think I may finally have my hooks into
   this problem. Branched off behavior from edBeginTrial() into
   edDoTrial(). Added Trial::trDoTrial(), which is called from
   edBeginTrial(). For now, trDoTrial() just calls right back to
   edDoTrial(), mimicking the previous behavior exactly. But... now we
   can slowly migrate the behavior from edDoTrial() back into
   trDoTrial(). Then this process can be iterated for the other
   Experiment:: functions. Eventually this will allow us to create a
   Trial base class with these new functions as virtual functions, so
   that we can create Trial's with very different behaviors (e.g. a
   ball-tracking trial, or a delayed-match trial).

** (12-May-2000) The way things look now,
   there is fairly clean separation amongst the different experiment
   participants. Basically:

                                   ___________________________________
                                  |                                   |
                                  V                                   |
    Experiment ---> Block ---> Trial ---> Response     Timing       Trial
               <---       <---       <--- Handler   +->Handler ---> Event
                                  |                 |
                                  |_________________|

   Importantly, this means that we can treat ResponseHandler, TimingHdlr,
   and TrialEvents as implementation details of Trial... so that can now
   substitute in other Trial subclasses with different behaviors.

* (15-Jan-2000, done) I think the executable shouldn't
  have to depend on the shared libraries, since these should be able
  to be change without forcing a relink on the main
  executable. ... Yes, but we need to be able to account for whether
  static or dynamic linking is being used.

* (16-Dec-1999, done) Try to fix ToglConfig::loadFonti on irix
  by switching fontnumber to a long before casting to char*. Tried
  it... didn't work.

* (done 19-Sep-2000) Want an indirection for auxiliary files
  so that the complete pathname is not hard-coded. To do this kind of
  added indirection (e.g. for now-hard-coded sound files, etc.), we
  can require an environment variable like GRSH_LIB_DIR to point to
  the root of a directory tree that will hold all auxiliary files for
  grsh programs. This can include the current contents of
  face/faces_triads, and face/audio, plus probably some other new
  goodies.

* (note 22-Sep-2000) Looks like I now have a new architecture to target
  irix6 w/ MIPSpro compiler. The MIPSpro compiler looks to be fairly
  C++-standard compliant. It would be nice to have a separate build
  for that compiler... might be faster, also might allow c++
  exceptions in shared libraries. But, this is something to try only
  after I get everything compiling cleanly with g++ again (following
  the upgrade to irix6.5 from irix6.3).

* (done 23-Sep-2000) OK, I figured out from a post on DejaNews
  that the problem on the sgi is that sgi's libGLU was implemented
  partially in c++ and compiled with MIPSpro; due to incompatible
  ABI's, this code cannot be linked with code compiled by g++. So, I
  have two options: 1) compile a version of OpenGL using g++, or 2)
  figure out how to get MIPSpro to compile my code. For option 2), I
  guess I can just use reinterpret_cast (which I'll define as
  SGI_IDIOT_CAST)... and keep my fingers crossed. ... OK, now I've
  done five hours of porting so that everything compiles/links/runs ok
  on curie using MIPSpro. I have a few bugs to wrinkle out
  however. And, this effort has provided an impetus for becoming more
  standard-compliant, with regard to the 'std' namespace, and the new
  IOStreams library.

* (done 23-Sep-2000) Bug on the new irix build of grsh
  the application crashes on exit (something in
  EventResponseHandler::ignore()). OK, this is due to the fact that
  ignore() tries to use itsWidget, but the ToglConfig has already been
  destroyed by the time we try to use it. This is fixed by adding
  forgetWidget() and forgetTrial(), which set the pointers to null at
  the end of a trial or when the experiment is halted.

* (done 24-Sep-2000) Hey... something good came
  out of this whole sgi mess: now I can use shared libraries on the
  sgi, since MIPSpro allows exceptions to work correctly with shared
  libraries.

* (23-Sep-2000, done 24-Sep-2000) Bugs on the new irix build of grsh:
  togl widget won't run in rgba mode. ... OK, this was due to the hack
  that I had set up to force colormaps to be set, in which the
  colormap was set recursively up the window parent chain. But, trying
  to set a colormap on an rgba window makes no sense, and this is what
  was causing the BadMatch error. In any case, that hack is not needed
  in rgba mode, so I added a check for the widget's itsRgbaFlag before
  we start setting colormaps.

* (nix 24-Sep-2000) make startup procedures figure out
  if X server is available

* (done 25-Sep-2000) Added a miscellaneous "log" string property
  to ExptDriver, so that we can append human-readable messages to it
  as needed.

* (done 29-Sep-2000) GOAL -- Refactoring the legacy IO interface
  (serialize/deserialize)

** (29-Sep-2000) This is done enough for now
   I now have a LegacyReader and LegacyWriter that have an augmented
   interface that allows client classes to emulate the format of their
   old serialize/deserialize functions within the readFrom/writeTo
   context. It's a bit clunky, but I think it's much better than
   before, and there is still room for more streamlining if it becomes
   important in the future.

** (16-May-2000) Phase out the old serialize()/deserialize() interface.

** (25-Sep-2000) The main obstacle here
   is that loadFaces() and loadObjects() rely on the old
   interface. These will continue to be needed for some time, in order
   to read older files. But, this only requires the old interface for
   the GrObj hierarchy. In fact, we only need Face, MorphyFace, and
   Fish. Plus, we need to arrange a new way to store object databases
   that works with the new IO interface.

   Basically we need an Adapter class that can be used to implement the
   old IO interface using the functionality defined by the new
   interface. This would work by trapping all calls to
   serialize/deserialize in the IoObject base class. This class would
   then construct an appropriate adapter, and call readFrom or writeTo
   using this adapter.

   The problem that we face is that in the new IO interface, the
   Reader/Writer does the parsing, but in the old IO interface, the
   individual classes do the parsing, and they don't always do it the
   same way. Maybe I have a plan for a big refactoring job:

   1-done) rename current serialize/deserialize/charCount to legacySrlz,
      legacyDesrlz, and legacyCharCount.

   2-done) Make legacy functions protected, and force callers to call
      through a new serialize/deserialize interface. For now IoObject
      just forwards onto the protected functions.

   3-done) Change parameter list of legacy functions to take a Reader* or
      Writer*.

   4-done) Have ioSerialize() and ioDeserialize() pass a LegacyReader* or
      LegacyWriter* to the legacy functions. These classes will allow
      access to the stream and the IOFlag. Add downcasts to the
      implementation of the legacy functions.

   5-done) Eliminate legacyCharCount(), and replace it with a slow, but
      generic implementation in ioCharCount().

   6-done) Eliminate the stream and flag parameters from the legacy functions.

   7-done) Use writeTypename() rather than checking IO::TYPENAME.

   8-done) Remove the stream and IOFlag parameters from the legacy functions.

   9-done) Reimplement the legacy functions in terms of the LegacyReader and
      LegacyWriter interfaces.

       9a-done) Do the easy stuff--the basic types char, int, bool, double.
       9b-done) Do the harder stuff--Value types.
       9c-done) Let LegacyReader and LegacyWriter handle the typenames
       9c-done) Do the harder stuff--sequences.
       9d-done) Do the harder stuff--strings.

   10-done) Ditch unused IoMgr::newIO() functions.

   11-done) Remove unneeded #include <iostream.h>'s.

   12-done) Eliminate the ioSerialize wrapper functions, and have former
      clients just instantiate a LegacyReader/LegacyWriter on their own.

   13-done) Remove legacySrlz and legacyDesrlz from IoObject. Subclasses
       can continue to implement these as private functions, and then
       branch into them (if necessary) from writeTo and readFrom based on
       a dynamic_cast. This way, classes can keep their legacy code
       separate from current code, but clients see only a uniform IO
       interface via readFrom() and writeTo().

   14-done) Remove the now unnecessary dynamic_cast's from legacySrlz() and
       legacyDesrlz() implementations.

   15-done) Remove legacyIoTypename()? I think this might be everywhere the
       same as ioTypename().

   16-done) Add readLegacyVersion() to LegacyReader to handle the '@1' format
       used by Face and MorphyFace.

** (13-Apr-2000) Encapsulate the old serialize/deserialize functions
   by wrapping them in a special Reader/Writer pair, that has
   specialized functions for each of the currently existing types. If
   an unsupported type is encountered, we throw an exception. Come to
   think of it, we'd only have to support a Reader, since we don't
   want to do any writing if this format is to become obsolete. This
   would have the advantage of moving all the ugly old code out of the
   current components.

* (21-Sep-2000, done 2-Oct-2000) Arghh! More event-loop problems.
  Get a core dump after Ctrl-C (which halts experiment), followed by
  Ctrl-Q (which rehalts, then attempts to write data and quit). This
  triggers an assertion itsCanvas != 0 in Trial::getCanvas, called
  from Trial::trUndrawTrial(). OK... I'm getting to the bottom of
  this. Basically, the first halt triggers Block::abortTrial(), from
  Trial::trAbortTrial(), from Trial::trHaltExpt(). This changes the
  current trial in the Block. Then, on the next halt, the new current
  Trial attempts to trUndraw(), but this fails since the trial has
  never been begun, and so itsCanvas == 0. TO SOLVE THIS: I think that
  trHaltExpt() doesn't really need to trAbortTrial()... it would be
  fine to just leave the current trial as is; when the experiment
  resumes we'll start off with the same current trial. But this may
  miss the underlying problem... that somehow it is possible to have a
  "current" trial in a corrupted state. We could introduce a state
  flag into the Trial, so that it ignores all requests until it has
  been officially begun. Yes-- this would work. I think the
  gang-of-four State pattern would be good here. Have an abstract
  TrialState class with virtual functions that match the main trial
  events. These functions take a Trial&, and the concrete subclasses
  take the appropriate action for that state. The instances of
  TrialState are themselves stateless (they have no member data, only
  behavior), so we can store static instances of the various states
  within the TrialState base class. But, maybe we should work with
  Block also to ensure that its 'current' trial is not adjusted until
  that trial is going to be begun. ... Well, I added an 'itsState'
  member to Trial::Impl. Right now this is just an enum, and all of
  the action functions check for (itsState == INACTIVE) before doing
  anything. More elegant would be to have itsState be a pointer to an
  implementation of TrialState, so that the (itsState == INACTIVE)
  checks would be just handled by virtual function dispatch. However,
  that solution is probably overkill right now, although I'll keep it
  in mind for the future. But, I still think my solution smells like
  defensive programming... I should perhaps still take a look at Block
  to see if it can be restructured in a better way so that it doesn't
  call action functions on inactive trials.

* (nix 2-Oct-2000) Idea for a generic ExptElement interface
  that would apply to Experiment, Block, Trial, ResponseHandler, and
  TimingHandler. In the pseudo chain-of-command hierarchy that
  describes experiment control, this would allow children to know
  their parents only as ExperimentElements, while parents would know
  the specific type of their children. This would help reduce
  coupling. In particular, TrialEvents would only have to know Trial's
  as ExptElem's in order to implement callbacks. Maybe this doesn't
  work... it looks like ExptElement would be nearly identical to
  TrialBase.

* (done 21-Sep-2000) Got some cool breakpoint-type things working
  with Util::Trace. Basically, we can call Util::Trace::setMode() so
  that we break into a command-line on trace-in and trace-out. Then
  this command-line can either reset the mode to RUN, or continue
  stepping. We could easily allow step-in or step-over as well, by
  putting a limit on the stack depth for which tracing is allowed.

* (done 9-Oct-2000) GOAL #3  -- Implement reference counting
  so that smart pointers can be used within C++ instead of integer
  id's.

** 1-done) Add a SharedPtr to PtrList
   that starts the provides reference counting skeleton.

** 2-done) Add a MasterVoidPtr to VoidPtrList
   and turn over the control of object destruction to it.

** 3-done) Add a VoidPtrHandle.

** 4-done) VoidPtrHandle should become ref-counting.

** 5-done) MasterVoidPtr should become abstract
   and we should use MasterIoPtr as a concret subclass instead. Then
   we can dynamic_cast to/from IO*'s, rather than static_cast'ing
   to/from void*. MasterVoidPtr should not need the ptr() function
   anymore.

** 6-done) MasterVoidPtr can be renamed MasterPtrBase.

** 7-done) We can remove destroyPtr() from the PtrList specification
   since the destruction of raw pointers can now be handled in the
   MasterPtr hierarchy.

** 8-done) Make MasterIoPtr abstract
   and derive a template MasterPtr<T> from it

** 9-done) Move the ref-counting implementation into MasterPtrBase
   Then we can have different handle classes that are allowed to
   manage the ref-counted objects. VoidPtrList can use
   VoidPtrHandle's, but PtrList might use PtrHandle<T>.

** 10-done) Add ItemWithId<T> that is basically a pair<int,SharedPtr>.

** 11-done) Add isShared() to MasterPtrBase.

** 12-done) Add the policy that VoidPtrList::remove() is not allowed
   unless the object at that id is currently unshared. This should
   apply to clear() as well.

** 13-done) VoidPtrList can be renamed PtrListBase (!).

** (very early) figure way for ObjList and PosList to notify Trials or
   Tlist when GrObj or Position is deleted. Then Trial should remove that
   (objid, posid) pair from its list. Possibility: have GrObj and
   Position implement a Notifier interface, where clients subscribe to
   the object, then the object has a notify() procedure that sends a
   message to each of its clients. Contents of message might be "I've
   changed" or "I'm destructed". Or... have ObjList control the
   notification since Trials only know about objids and posids. PtrList
   could maintain an array of info that is parallel to the stored
   pointers. This array could contain sets of clients for each id. Have
   to think carefully about how this structure could be maintained
   through serialization.

** Or... do pseudo-smart pointer stuff within PtrList.
   Whenever some client is going to hold on to an id within the
   PtrList, it must "check out" the id. This would increment a
   reference count within the PtrList. Ptr's with a non-zero ref count
   are not allowed to be delete'd or overwritten. This is I guess just
   a simpler version of maintaining a list of clients--it doesn't
   allow for any messages to be sent back to the clients.

** On third thought, this is a deep design issue.
   The question is, who owns the GrObj's and Position's? Who can
   delete them?

** (19-Oct-1999) I'm suddenly turned off by PtrList's
   1) I just fixed a bug in insertAt that is equivalent to the 'check
   for assignment to self' in assignment operators, and 2) even worse,
   I just realized that it would be disastrous if the same pointer
   were stored at two locations in a PtrList... double deletion would
   result. This suggests to me that we need a more flexible and robust
   memory-management scheme, probably using reference-counted smart
   pointers. This will also eliminate a lot of "dangling id" problems
   that necessitated getCheckedPtr(id). But what sort of Tcl interface
   should the ref-counted smart-pointers have?

** (24-Jan-2000) OK, forget the traditional ref-counted pointers
   Instead, we'll put the reference counting right into the list. This
   will avoid the problems with maintaining the VoidPtrList <-
   IoPtrList <- PtrList hierarchy. VoidPtrList will be able to hold
   the ref counts, and maintain the ref counting logic; it will just
   have to forward object destruction to a derived class via a virtual
   function, as it does now.

   Clients will use a ListItem, containing an integer id and a pointer to
   a PtrList. The ListItem's constructors and destructor will manage the
   ref counts via calls to PtrList member functions. ListItem will offer
   an operator-> so it can be used as a smart pointer.

   In order to hide PtrList from clients, we can define the necessary
   functions out of line.

   At the expense of some size, we can cache a C* inside ListItem so that
   we don't have to call a PtrList member function every time ListItem is
   used. Basically, PtrList would keep a counter that is incremented
   every time the list is modified. ListItems would maintain a const* to
   this count, and would also store the value of the counter from the
   last time their C* was cached. Then checking that the cache is current
   just involves dereferencing the const* counter and comparing it to the
   stored counter value.

   Problem: how to handle derived classes with a ListItem?

** (10-May-2000) In lieu of true reference counting with PtrList's
   we could allow locks that clients could take that would temporarily
   prevent objects from being deleted.

** (5-Oct-2000) What do I want out of an improved memory management
   system?

     *) be able to associate C++ objects with unique integers, and
      retrieve the object from somewhere given the integer
     *) ensure that the object is not destroyed until all references to
      it and to its integer identifier are gone
     *) provide some way for Tcl to control which objects are referenced
      from Tcl and which are unreferenced... this probably requires a new
      Tcl_Obj type
     *) allow some of the conveniences of the current PtrList system,
      like being able to retrieve a list of all valid objects of a given
      type

   Is the current system fatally flawed with respect to these goals? The
   hardest part is controlling references from Tcl.

   One solution would just be to have the Tcl objects be typed, rather
   than just plain integers. The internal rep would be something that
   refers to the PtrList with an integer id, and disallows conversions to
   other Tcl_Obj types. However, then we wouldn't be able to do integer
   math with the id's, although we could view the id's as strings. This
   system requires a dependency on the Tcl ref-counting system.

   Another solution would be to require explicit control of a Tcl
   reference count from the Tcl side, with functions like
   PtrList::incrRef and PtrList::decrRef. This might require us to have
   two ref counts, one for the C++ side and one for the Tcl side, in
   order to keep things safe and sensible.

   ... I think the first option is more sound, although it is a bit less
   convenient in the sense that it will require some changes to existing
   scripts. If I had itcl up and running, I could build an equally safe
   solution out of itcl code using the second implementation.

   ... I tried a bit at implementing the first option, playing around
   with a new Tcl_ObjType. It seems like I don't have a good way to
   control exactly when objects are ref'd, unref'd, and when they switch
   types. So, I think I'm going to try for option two for now, by added
   two reference counts to the PtrList's, one for C++ and one for
   Tcl. Tcl scripts will have to manually control the reference counts
   for now.

   ... Need to focus on getting more behavior into the smart pointers,
   and less in the PtrList. The PtrList has two functions: one is to
   control how id's are doled out, and the other is to maintain knowledge
   of all existing pointers of a certain type.


* (19-Jan-2000, done 5-Oct-2000) Auto-detect gzipped files?
  This is done for the stringifycmd module.

* (16-Sep-1999, fixed) BUG: if somehow the current trial becomes
  invalid, it is impossible to show a new trial because the program
  always tries to undraw the current, invalid trial before drawing a
  new one. So there is no way to un-corrupt the program state.

* (9-Oct-2000, done 11-Oct-2000) Could refactor EventResponseHdlr
  and Trial by using a state pattern instead of an enum
  TrialState. Done for EventResponseHdlr, but I'm not sure this helped
  make things clearer.

* (28-Jun-1999, done 11-Oct-2000) Need way for TclCmd's to "own"
  TclEvalCmd's, so that the Tcl_Interp* management can be hidden from
  the client. [Later] OK, this is done fairly well by Tcl::Interp and
  Tcl::Code.

* (done 16-Oct-2000) NullablePtrHandle?
  Allows resources to be purged. Done.

* (note 18-Oct-2000) Ouch! I got bitten by a bug
  (? or my own problem) using MIPSpro. The call was

     C& p = dynamic_cast<C&>(*(itsList.getCheckedPtr(id)));

  in AbstractListItemPkg<C,List>::getCItemFromId(). The problem was
  that if the dynamic_cast threw an exception, the temporary SharedPtr
  created by getCheckedPtr() was not destroyed properly, meaning that
  the reference-counts got hosed. This is a Bad Thing. Who's right?
  Is the temporary supposed to be destroyed, or not? ... the standard
  says the temporary must be destroyed... maybe this was a bad
  interaction of virtual functions, templates, temporaries,
  exceptions, etc. in MIPSpro.

* (18-Oct-2000, done 20-Oct-2000) Migrate legacy data

** Should get rid of legacySrlz and legacyDesrlz once and for all.

** 1-done) fMRI data
   These are not likely to ever be needed. But... I was able to
   successfully convert all of this data to ASW format.

** 2-done) Psychophysics fall 1999
   These are readable by the current legacyDesrlz. Therefore, we can
   migrate these files to AsciiStreamWriter format in a batch process.

       human_ac human_em human_jl human_ne human_rl
       also human_ok human_rp human_fg

** 3-done) Psychophysics spring 1999
   These are not readable by the current legacyDesrlz, and have
   fundamental incompatibility due to the lack of RhList, ThList,
   BlockList. Therefore, I think it's best to orphan them right
   now. The file format is fairly straightforward if I needed to pull
   the data out at somepoint in the future. These files are also
   readable+writable by grsh.a1.2.2, grsh0.5a2, and grsh0.5a3. I'll
   freeze grsh0.8a2 as is, so that I could in principle restructure
   these files at some point to be readable by grsh0.8a2, and then
   re-write them in ASW format.

       human_ap human_aw human_cc human_ss

** 4-done) Copy all legacyDesrlz/legacySrlz functions
   into a text document as a quick way to be able to manually read
   older files.

** 5-done) The object definition files in faces_triads/
   Do we continue to support this format, or convert these to ASW
   somehow? Or define a "new" format for GrObj's only that allows them
   to be read in a similar way? Probably best to have a new format
   that is similar to the sparse format now used by LegacyReader. The
   question is, should the new format be implemented with
   readTo/writeFrom, or does it require a separate interface? Probably
   we can use readTo/writeFrom, especially since, this should be used
   mostly for GrObj's... this would allow us to collapse legacySrlz
   and legacyDesrlz back into readFrom/writeTo, since we wouldn't be
   trying to support an old format anymore. OK, the new format for
   LegacyWriter is stabilized, so I can go ahead and convert all of
   the object definition files. Done. Also, I now have testall.tcl
   file in the faces_triads directory that will use any version of
   grsh to make sure that all the files are readable.

   Ahhh... this is good. I've released the grip that the legacy IO
   format held over this project. So far it has cut out nearly 2000
   lines of source code... I expect I may find more in the future as
   well.


* (note 18-Oct-2000) I need to think a lot more carefully
  in the future if/when changing file formats. As a one-user system, I
  think it is reasonable to consider migrating all old data over to a
  new format rather than trying to support multiple formats. Hopefully
  this is less of a problem with ASW format than with the Legacy
  format. I need to add a bunch of test cases that ensure that various
  old files (e.g. from psychophysics, fMRI) are still readable with
  each version.

* (3-Jul-1999, done 24-Oct-2000) Tlist makeSingles, etc. could now
  take a sequence/list of objids as an optional argument utilizing
  TclCmd::getSequenceFromArg.

* (note 25-Oct-2000) Note to self. std::map is not actually
  such a slow compile, as long as neither of the types is
  std::string... only takes 10-15 sec to compile a file std::map, even
  if one of the types is not a builtin.

* (25-Oct-2000, done 26-Oct-2000) Try overloading operator new+delete
  in IoObject. OK, tried this, and found with profiling that these are
  definitely *NOT* a bottleneck. Combined, they took about 0.1% of the
  runtime in a test-suite run.

* (17-Oct-2000, done 27-Oct-2000) Resource management revisited

** (1-done) Generalize Factory
   so it can take a creation function. Make class constructors
   protected and add make() creation functions instead.

** (2-done) Aha! We can get rid of MasterPtr....
   IoObject itself should handle the reference counting. Then
   PtrHandle<T> of different types can be assigned to each other,
   DynamicCast'ed, etc., since the pointee's (IoObject*'s) will be
   related through inheritance.

       In detail
       (done) MasterPtrBase becomes RefCounted
       (done) IoObject inherits from RefCounted
       (done) VoidPtrHandle manages RefCounted
       (done) PtrListBase manages RefCounted
       (done) PtrHandle<T> holds T* (derived from RefCounted) directly
       (done) NullablePtrHandle<T> holds T* directly
       (done) get rid of masterptrt.cc

** (3-done) Make sure nobody is writing PtrList ids in writeTo().
       (done) Block
       (done) Trial ... this is tricky. Need to refactor the implementation
                 to store two vectors of GrObj's and Position's, I think. Only
                 client of beginIdPairs() is TlistUtils::writeMatlab(). That
                 can change to use an iterator over the GrObj's instead. Will
                 need to have a dummy IdPairSpoofer structure in the
                 implementation to allow us to read older files.
        (done) ExptDriver

** (4-done) Migrate all old experiment data-files
   over to this new format that will not include PtrList's. I'll make
   a snapshot of the system so that we can get back to the state that
   can convert between old+new format. Then I'll rev the project
   version and cut out the old format code so that the IO code doesn't
   get too messy.

** (5-done) Make sure there is a snapshot of the project
   that can read old files (i.e. with PtrList's) but also write new
   files (w/o PtrList's). OK, this is grsh0.8a3.

** (6-done) Make the IoMap
   When an IoObject is constructed, we put its id+address into the
   map, and when it is destroyed, we remove it from the map. We need
   functions to iterate through the map, to test if an id is valid, to
   return the count of objects.

** (7-done) A key step here is eliminating uses of insertAt()
   The main perpetrator here is TlistUtils, whose interface needs a
   major overhaul.

** (8-done) Make all PtrListBase functions virtual
   so we can try swapping implementations at the PtrList<T> level.

** (9-done) For debugging purposes, add a second ref-count to RefCounted
   so that Tcl clients can manipulate a separate reference count.

** (10-done) An important intermediate goal
   is the state where the PtrList's are still physically in place, but
   all of the id's in existence are just the plain IoId's. ... Maybe
   this is not really a useful stage. I think once we are at the point
   where this stage is feasible, we'll just be wanting to finally
   ditch the PtrList's.

** (11-done) Make the C++ side independent of PtrList's
   Block's need to store Trial*'s (or ItemWithId<TrialBase>'s), and
   ExptDriver needs to store ItemWithId<Block>'s.

       (done) block.cc      on tlist.h
       (done) exptdriver.cc on blocklist.h
       (done) eventresponsehdlr.cc on soundlist.h

       (done) tlistutils.cc on objlist.h
       (done) tlistutils.cc on poslist.h

** (12-done) Fix the read/write system
   so we don't have to work with temporary containers when
   reading/writing member containers. Done -- added
   WriteUtils::writeSmartPtrSeq, and added special insert iterators
   for IdItem and MaybeIdItem that can work with
   ReadUtils::readObjectSeq

** (13-done) Ditch the itsId member of IdItem
   since it would always be the same as itsHandle->id(). MaybeIdItem
   needs to keep itsId, since this is what allows us to implement lazy
   fetching.

** (14-done) Try to eliminate uses of MaybeIdItem
   in favor of IdItem. ... Yeahbut, in some cases we need to have some
   way to represent "no object". It's either this way, or generate
   NullObject classes for each base type that can fill in for a real
   object... this sounds more messy. In some cases I should be able to
   get rid of MaybeIdItem.

** (15-done) We might be able to do away PtrList templates
   in favor of one gigantic IoPtrList that stores everybody... with
   the new id system, there would be no id collision problem, and
   since most retrievals from a PtrList require a dynamic_cast anyway,
   there wouldn't be an extra performance hit for casting out of the
   IoPtrList. Then we could have IdItem's referring not just to the
   base-classes (i.e. GrObj, Position, TrialBase, etc.) but also to
   derived classes (e.g. Face, FixPt, Trial, etc.). What's the
   simplest possible step toward trying this? Maybe make
   getCheckedPtr() a member template function, so we can start
   specifying the type we're trying to retrieve. We'd need to have
   templated iterator types to provide different views of the
   IoPtrList. This could be a fairly simple template wrapper around
   the basic iterator.

** (22-Oct-2000) I see the elimination of PtrList's in the future
   Instead we can maintain a map of ioId()'s to IoObject*'s. This can
   be managed in the constructor+destructor for IoObject. This map
   could be purged of refcount-0 objects on command. The map would
   allow us to do similar operations to what the PtrList's provide
   now. For example, find all objects of a given type.

** (done, 18-Oct-2000) Aha! I have a vision...
   the PtrList's do not need to be serialized at all... they can
   become merely a runtime resource that expose C++ objects to
   Tcl. This will be possible if C++ objects serialize not
   object-id's, but rather actual object references. Then the id's
   will be automatically reconstructed when the objects are read back
   in.

** (done, 17-Oct-2000) Move ItemWithId<T> and NullableItemWithId<T>
   off into their own component. Most C++ clients should not have to
   rely on PtrList directly, or access any of the singletons.

** (done, 17-Oct-2000) Make C++ clients of getPtr() and getCheckedPtr()
   just store an ItemWithId<T> instead.

** (done 17-Oct-2000) ItemWithId<T> could store a static PtrList<T>&,
   which would allow us to construct an ItemWithId<T> from a MasterPtr
   only, and insert this MasterPtr into the PtrList from within the
   ItemWithId structure. Done.

** (done 17-Oct-2000) Make PtrList::insert() functions return
   an ItemWithId. This is a first step to eliminating reliance on the
   int id's in the C++ side of things. Done.

* (8-Jan-2000, done 27-Oct-2000) How to read/write CountedPtr's?
  This is the big barrier to establishing CountedPtr's as a better way
  to manage objects between C++ and Tcl. Probably Reader/Writer need a
  special method for CountedPtr's. The question is how to keep track
  of the pointers to the reference counts. Or... we could put the
  reference count right in IO... Aha! Instead of AsciiStreamReader
  maintaining a map<unsigned long, IO*> during deserialization, we
  could use a map<unsigned long, CountedPtr<IO> >. However, this
  introduces a split from the semantics of readOwnedObject()... this
  suggests that we need a separate map for owned objects. As this
  transition will require a nearly universal switch to CountedPtr's,
  we need to provide a feasible migration route, perhaps by providing
  the ability to short-circuit CountedPtr's ref-counting at
  first. ... This is not an issue anymore. Now IoObjects have a built
  in ref-count. Reader+Writer don't explicitly do anything with the
  refcount; instead, clients are responsible for grabbing the object
  if they need it.

* (10-Oct-2000, done 27-Oct-2000) Start reaping the benefits
  of my PtrList ref-counting refactoring by allowing clients to lock
  onto their resources using ItemWithId<T>. Done.

* (10-Oct-2000, done 27-Oct-2000) PtrList could do an "idiot check"
  on insert to make sure that we aren't storing the same pointer in
  two slots. If this happens with the same MasterPtr, we can just
  return the previous MasterPtr; however if it happens with two
  MasterPtr's pointing to the same object, then it is a bug which will
  result in memory corruption.

* (done 30-Oct-2000) iditem.h --> io/iditem.h & io/iditemutils.h

* (done 30-Oct-2000) ioptrlist.h+cc --> io/ioptrlist.h+cc

* (done 30-Oct-2000) Remove List template argument from ListItemPkg.

* (done 30-Oct-2000) Replace DefaultCreatorCmd
  with a single IO::new that uses IoFactory. Turn List::remove into
  IO::delete.

* (nix 30-Oct-2000, 24-Jun-1999) Would be nice
  to define some sort of appropriate inheritance semantics for
  CTclPkg's... so that CTclPkg<B> can inherit from CTclPkg<A> iff B
  inherits from A, and furthermore that this inheritance does "all the
  right things".

* (nix 30-Oct-2000, 30-Jun-1999) Really need to get an iterator working
  for PtrList's... and get rid of these pseudo-working Id's. OK, now
  have an iterator class implemented, but how to construct them?
  Specifically, I'll need to be able to construct iterators from int
  id's, but then what to do if the int is an invalid index? Throw an
  exception? Leave the iterator in a corrupted state? Also, basically
  all of the PtrList operations should use iterators... addPtr()
  should return an iterator, remove() should take an iterator.

* (nix 30-Oct-2000, 6-Oct-1999) Should Property's be Observable's?
  Is this worth the extra space? Perhaps only some properties should
  be Observable's. How would this be done?

* (nix 30-Oct-2000, 22-Nov-1999) Hey, I think I might be able to
  totally do away with PtrList's, at least in the public interface. I
  think that they could be wrapped into the base class, so that every
  GrObj created is automatically placed in the ObjList, and anytime a
  GrObj is destroyed it is removed from the PtrList. This would just
  entail overriding operator new + delete for that class. The class
  would have static operations that mimic the PtrList's operations.

* (done 30-Oct-2000, 1-Dec-1999) Unsavory dependencies:
    EventResponseHdlr on ObjTogl -- axed via Widget abstraction!
    EventResponseHdlr on SoundList
    ObjTogl on Tlist -- compilation dep gone, but still link dep
    Trial on ObjList, PosList?
    Block on Tlist?
    BitmapRep on GLCanvas::theCanvas()

  ... I see that this whole PtrList business introduces some wacky
    dependencies... I don't think C++ clients should be depending on the
    PtrList's directly. Instead, maybe the PtrList's should manage
    CountedPtr's or something similar, so that the integer indices are
    only visible in Tcl. [Later 30-Oct-2000] With the whole IoPtrList
    refactoring, we have now eliminated C++ client's dependencies on the
    item ids.

* (nix 30-Oct-2000) Goal: ExptDriver shouldn't have to know
  about any lists except maybe BlockList. As for serializing, the
  lists should register themselves with ExptDriver at application
  startup. Experiment base class should declare an abstract
  manageObject(const char* name, IO* object) function. The lists
  should call this in in their Tcl_PkgInitProc's. The problem with
  this approach is that we lose the ability to control the order in
  which the lists are read/written through the IO interface. This is
  not so much a problem for the readFrom()/writeTo() interface, as
  this is designed to be order-independent, but it is a problem for
  the serialize()/deserialize() interface. Perhaps we could use some
  ad hoc strategy to make sure that the managed objects are written in
  the same order every time (based on their ioTypename() for
  instance?). [Later] This is obsolete since we no longer depend on
  PtrList's in the serialization process.

* (done 1-Nov-2000) Got rid of all the unneeded io tcl commands...
  we don't need a separate stringify/destringify command for each
  subclass; instead, a single one in the IO:: tcl namespace will do
  just fine. This allowed us to get rid of TclIoItemPkg in favor of an
  addIoCommands() function in TclItemPkg, taking an IoFetcher* as an
  argument. This in turn allowed us to get rid of CTclIoItemPkg and
  the duplication that existed between it and CTclItemPkg.

* (3-Dec-1999, done 2-Nov-2000) I have a potential type-system loophole
  with TclItemPkg and TclItemCmd... TclItemPkg blindly casts
  TclItemCmd::getItemFromId() from void* to T*, without any guarantee
  that TclItemPkg is dealing with the correct type. Suggests we need a
  template wrapper around TclItemPkg? No... we can fix this by just
  having TclItemCmd<C> require a CTclItemPkg<C> in its constructor
  rather than a plain TclItemPkg.

* (24-Oct-2000, done 3-Nov-2000) Work on dlink_list... it's buggy.
  I think it needs an overhaul of the design of the head and
  tail... having these starting off at 0 is not working. OK, I did
  this, but it is still not working if I try to substitute dlink_list
  in gxtraversal.cc. ... OK, now I found this new problem -- it's with
  node::destroy(). If T was a pointer type (say, GxNode*), then
  calling val.~T() was causing the actual GxNode to be destroyed, not
  just the pointer to it. This seems to have been resolved by changing
  the call to (&val)->~T(). I tried substituting dlink_list everywhere
  slink_list was being used, and things still worked fine, so I think
  I'm going to sign off on dlink_list as passing muster for now.

* (24-Jan-2000, done 28-Nov-2000) GOAL #2 -- More flexible scene graph

  This is done, with possibilities for future development by way of
  implementing new GxNode subclasses, such as for colors, basic
  shapes, etc.

** (24-Jan-2000) Allow a more flexible description of the scene graph
   a la Open Inventor.

   This is now particularly important as Trial's take on more
   behavior... they shouldn't be used anymore as a way to store
   combinations of objects.

** (1-Nov-2000) borrowed from OpenInventor --

   class GxNode : public IO::IoObject {};
    |
    +-- class GrObj : public GxNode {}; --> GxShape
    |
    +-- class GxTransformation : public GxNode {};
    |    |
    |    +-- class GxTranslation : public GxTransformation {};
    |    |
    |    +-- class GxScale : public GxTransformation {};
    |
    |
    +-- class GxGroup : public GxNode {};
         |
         +-- class GxSeparator : public GxGroup {};

   Then Trial just holds one IdItem<GxNode>, and draws it on a
   DrawEvent. Or, Trial holds a number of IdItem<GxNode>'s, and DrawEvent
   holds an index indicating which one to draw.

   This is probably an incompatible change with the old Trial... or maybe
   not... we should be able to convert old Trial structures into new Gx
   hierarchies. And the old add() interface should still work, with a bit
   of translation.

*** (1-done) Put GxNode in place.

*** (2-done) Make GrObj derive from GxNode.

*** (3-done) Find former clients of GrObj
    who really only need to depend on GxNode. Trial and TlistTcl.

*** (4-done) Make Position derive from GxNode.

*** (5-done) Find Position clients who only need to depend on GxNode. Trial.

*** (6-done) Implement GxSeparator
    add a Tcl package for it, and write tests for the Tcl package.

*** (7-done) getCategory() --> category()

*** (8-done) Reimplement Trial
    using GxNode's instead of GrObj's and Position's.

*** (9-done) Add FieldContainer
    Where to put this in the inheritance hierarchy? Right now it is
    just a mixin class... eventually it could go before GrObj or even
    GxNode... this would require a coherent policy on how to handle
    inherited Field's.

*** (10-done) Change the semantics of Trial
    so that only one GxNode is drawn at a time... in the future we
    might allow different GxNode's to be drawn on subsequent calls to
    trDraw().

* (1-Nov-2000, done 28-Nov-2000) Make PropertyContainer or
  FieldContainer a base class; then Property's can be handled through
  inheritance rather than by templates. This should reduce some code
  bloat.

* (24-Jan-2000, done 28-Nov-2000) GOAL #4 -- Better screen-update model

** (24-Jan-2000) Develop a more coherent view
   of the screen-update model: Who gets to do it, and when?

** (28-Nov-2000) Aha! TlistWidget should change to be a GxNodeWidget,
   which stores a current GxNode to be drawn. Then Trial, in trDraw()
   and trUndraw(), can install the appropriate GxNode into the widget,
   and then request a draw or an undraw; Trial will not have to do any
   drawing/undrawing explicitly on its own. I think this would make
   GxNodeWidget the only place where the drawing is actually done in
   the application.

** (done) GxNodeWidget functionality
   should just go into the Widget base class with the function
   setDrawable(GxNode& node).

** (done) remove Block::drawTrialHook() and Experiment::edSetCurrentTrial().

** (done) trUndrawTrial is not needed
   since we can just call widget.undraw(). This would apply to
   UndrawEvent::invoke() as well as trHaltExpt(). This would mean
   Trial would need to store a GWT::Widget* rather than a
   GWT::Canvas*.

** (done) Aha! trDraw is not needed either
   since we can just trial.installSelf(widget) followed by
   widget.display()

** (done) ToglConfig::reconfigure() should be non-virtual and private.

** (2-Oct-2000) The first step in this is to eliminate
   any direct attempts to draw to the screen, other than by a Widget
   object (such as TlistWidget). Others who want the screen updated
   should do so indirectly by requesting the widget to redraw itself.

* (2-Oct-1999, done 15-Nov-2000) Should be able to call up
  a property info struct from a class by giving it a string name of a
  property. [Later] This is done now with FieldMap, which can be
  gotten from a class by the static function classFields(), and which
  has a member info() that retrieves a FieldInfo object given the
  attribute name.

* (28-Nov-2000, done 28-Nov-2000) Make Position use Vec3's
  Move translate(), scale(), and rotate() into Canvas, along with
  appropriate Vec3 arguments.

* (27-Oct-2000, done 30-Nov-2000) Should IoPtrList attempt to
  get objects out of the IoMap if the PtrList site is empty? No--some
  objects need to remain permanently hidden as implementation details.

* (note 4-Oct-2000) "Dynamic templates"

** (4-Oct-2000) I like the idea I saw in the CUJ
   that dealt with deferring the template nature of
   something. Basically a generic interface is provided in a derived
   class, like

   class Impl { public: virtual ~class Impl(); };

   template <class T> class TImpl : public Impl { public: T data; };

   class Interface {
   public:
     template <class T>
     T getT() {
       TImpl* tptr = dynamic_cast<TImpl<T>*>(itsImpl);
       if (tptr) return tptr->data;
       else { throw "..."; }
     }

     Impl* itsImpl;
   };

   This allows Interface to gain some of the benefits of templates,
   but doesn't require the entire class to be templated, only the
   getT() function. If there a long chain of templates involved, this
   technique might be able to defer the templated-ness to the last
   class in the chain, for example. This is a particular benefit if
   there are virtual functions involved, since it allows us to avoid
   having vtables laid down everywhere.

   As a practice before I move on to a more heavy use of this
   approach, I bet I can use this approach to eliminate the use of
   void*'s in the implentation of the TclPkg hierarchy. Ugh. I just
   realized that this is basically skirting around the idea of just
   using a mother-of-all-base classes approach, such as deriving
   everything from Object. The template idea is just a way of grafting
   on the MOAB to a preexisting object hierarchy. ... except that the
   template approach does allow non-objects to be included, such as
   native types, pointer-to-members, etc.

   I think I should be able to get some benefit of this in my TclPkg
   hierarchy. For example, PropertyInfo would not have to be a
   template class; instead, PropertyInfo::property() would just have
   to be a template member function, along with a template
   constructor.

   *) Turning PropertyInfo into a non-template class allows us to turn
      the get getPropertyInfos() interface from an ad-hoc interface to
      a dynamic, polymorphic interface.

   *) PropFriend would have an non-template base class that would
      define the functions set() and get(). These would be implemented
      in a template class that used dynamic casts to get the type
      information back out.

   *) CPropertiesCmd would not have to be a template.

** (30-Nov-2000) Time to move on... I don't think this technique will
   be too useful for me; the one possible area of use might be as a
   way to implement generic function pointers.

* (2-Oct-1999, nixed 30-Nov-2000) Property's could store
  a pointer to something like ValChecker, which has a virtual
  function, that could variously do 1) check whether new value is the
  same as the current value, 2) check whether the new value is in
  bounds/valid. If the ValChecker* is 0, then no check is done, and
  not much time is lost worrying about the check. This would avoid the
  problem of trying to maintain parallel hierarchies of Property,
  BoundedProperty, etc.

* (1-Dec-2000, done 2-Dec-2000) Need a better naming convention
  to distinguish between unadorned value types (like Vec3),
  field/value types (like GxVec3), and scene node types.

  OK, I'll use no prefix for unadorned basic types, use the prefix
  'Gb' for Field/Value types, and use 'Gx' for scene nodes.

  RgbaColor (unadorned) ---> GbRgbaColor (Field/Value) ---> GxRgbaColor (node)

  Vec3 (unadorned) ---> GbVec3 (Field/Value)

* (30-Oct-2000, done 2-Dec-2000) Use PtrHandle's in TimingHdlr
  implementation to avoid deleteAll().

* (22-Mar-2000) We could have a more compact reader/writer format
  by using a system that wrote class definitions to the file, and
  stored some sort of translator for each class in the
  reader/writer... this would allow us to just store the raw data for
  individual objects, without having to store the metadata over and
  over. [Later] the generic version of this is that each read/write
  requires a per-class translater, with the default being that the
  normal verbose translater is used, but if a different translater is
  present, then that one can be used instead. This idea might come
  around if I implement FormatWriter as suggested in a different note.

* (May-1999, obsolete 5-Dec-2000) An idea for a more generic way
  to describe Trial's: rather than explicitly storing objid/posid
  pairs, Trial's could store sequences of events (this overlaps my
  previous idea about using events to describe trial timing). One
  particular *type* of event then could be DisplayObjectAtPosition (or
  something less wordy). This event would store the objid and posid
  (or maybe GrObj* and Position*) and would know how to display
  itself. The events would have in common an action() function or
  something similar. Problem: who stores the references to ObjList and
  PosList that make posid's and objid's work?  Currently it is
  Trial's, but with this new scheme there would have to be one for
  each DisplayObjectAtPosition event, and with several of these per
  Trial, and perhaps thousands of Trials in an Expt, this means many
  thousands of references, all of which are pointing at just one or
  two ObjList's/PosList's. This seems somewhat excessive. What to do
  ...?  [Later] This latter problem has been solved by making ObjList
  and PosList singletons.

* (22-Jun-1999, done) Ugh. Spent all day tracking down idiotic pointer
  problems. Should really use vector<unsigned char> rather than
  C-style arrays to hold the info in Bitmap's and Pbm's, and use
  checked access through at() especially when algorithms are untested.

* (May-1999, obsolete 6-Dec-2000) Trial's should hold more info
  in particular, they should know their own correct response, or at
  least have a virtual function to determine if a particular response
  is correct/valid or not. The derived classes could be "BinaryTrial",
  "AnalogTrial", etc. This would avoid having to implement the
  feedback/correctness check at a high level. Also, Trial's might know
  their own timing info, although they may not necessarily implement
  the timing themselves.

* (14-Dec-1999, obsolete 11-Dec-2000) The implementation of GrObj
  should be moved into a separate component since it is fairly
  heavyweight. Subclasses would then be required to provide this
  implementation upon construction. This method would allow clients,
  but not subclasses, of GrObj to avoid dependencies on such
  components as bitmaprep, etc. But, how to avoid having to make all
  GrObj functions virtual? We'd like some to stay non-virtual. Aha!
  The new lightweight GrObj shouldn't even have the grRender(),
  grUnRender(), or grGetBoundingBox() functions... these will first be
  defined in GrObjImpl. [Later] ... ok, this is moot now because of
  the addition of GxNode, which is a lightweight abstract class that
  serves the needs of most clients.

* (11-Dec-2000) PtrList

** (29-Oct-2000, tabled 11-Dec-2000) We could make a lot of IoPtrList
   Tcl commands very generic, by allowing a predicate argument to
   determine which objects are to be acted upon. See batch.tcl. This
   could be called IoDb::batch. ... I'll table this idea for now; most
   of this can be more simply done by creating the relevant commands
   in each IoItemPkg (such as removeAll, countAll, findAll).

** (9-Dec-2000, done 11-Dec-2000) Replace all of the PtrList Tcl packages
   with a few commands that are added to each ItemPkg... these include
   findAll, countAll, removeAll. ObjList::save/loadObjects should move
   to IoDb.

** (1-Nov-2000, done 11-Dec-2000) IoPtrList --> IoDb.

** (29-Oct-2000, done 11-Dec-2000) ObjList::LoadObjectCmd can be replaced
   with something generic that works for all IoObject types. Maybe
   these should go in ReadUtils/WriteUtils? Templated on the
   Reader/Writer type? OK, this stuff is in the IoDb package now.

** (27-Oct-2000, done 11-Dec-2000) Do we still need separate Tcl packages
   for the different PtrList's? I think no. We should be able to have
   a single IoDb:: namespace in Tcl.

* (May-1999, obsolete 11-Dec-2000) Maybe Position should be migrated
  to an abstract base class, with the current Position class becoming
  StaticPosition or FixedPosition. What would a Position subclass for
  moving objects look like? This is mooted by the presence GxNode.

* (28-Sep-2000, nix 13-Dec-2000) fixed_block and dynamic_block should
  have release() members, so that we can use them for exception-safe
  storage, then transfer ownership of the buffer to someone else once
  the operations are safely completed. ... [Later] Forget this, since
  if someone else wants ownership, they should just use a fixed_block
  or dynamic_block themselves.

* 2001 STARTS HERE

* (9-Dec-2000, done 17-May-2001) IoDb does not need to be
  an IoObject anymore; instead, it should provide functionality for
  reading+writing object archives. The IoDb package should not have
  stringify/destringify or read/write.

* (4-Dec-2000, done 18-May-2001) Need to prevent resource leaks
  by making newIO() return a PtrHandle<IO::IoObject>. This will
  require Reader::readObject() to return a PtrHandle as well, and
  require Reader implementations to use PtrHandle's
  internally. Hmmm... need to make real sure that there is no way to
  create more than one PtrHandle for a given IoObject... oops, duh! I
  already have avoided this problem by making RefCount a base class of
  IoObject, so we can actually make multiple PtrHandle's without a
  problem. The way to get at this is to change the static make()
  functions to return a PtrHandle. Then CreatorFromFunc will store the
  appropriate type of function pointer, and its create() method will
  return a PtrHandle<Base>. The main drawback here is that we greatly
  increase the dependence on PtrHandle... Then again, this is probably
  a good thing, as it reduces the use of raw pointers.

  (done) change users of newIO() and make() to instantiate a PtrHandle
  rather than a raw pointer

  (done) newIO() to return a PtrHandle

  (done) change Factory to return IdItem's

* (19-Jan-2000, done 18-May-2001) GLBitmap should use auto_ptr
  for itsRenderer and fix initialization order (eliminate
  tempRenderer). Same for XBitmap.

* (8-Jul-1999, done 18-May-2001) Idea: have TclCmd's be able to
  return doc strings; then TclCmd or TclPkg would store a list of all
  registered commands, so that a special help command (like '?')
  followed by a command name could return its help string. This would
  be nice since the various intermediate command classes could provide
  default doc-strings. Subclasses could either append, or override,
  their superclass's doc-string.

* (19-May-2001, done 19-May-2001) IoProxy should still store
  its referand's as IdItem's. IdItem's no longer need to do IoDb
  insertion.

* (16-May-2001, done 19-May-2001) Don't need IoMap
  instead, IoObject's should just insert themselves into the IoDb
  automatically upon construction. Hmmm... the problem here is that
  this won't work for IoObject's that are constructed on the stack
  (such as IoProxy's). So do we somehow forbid any subclasses from
  being instantiated on the stack? Or just give up on automatic IoDb
  insertion? And the answer is... we can prohibit IoObject's from
  being instantiated on the stack at runtime, by Assert'ing in
  RefCounted's destructor that the ref-counts are zero. And we can
  allow subclasses (such as IoProxy) to choose not to be automatically
  inserted in the IoDb, by the addition of a "doInsert" argument to
  the IoObject constructor that defaults to true.

* (29-Oct-2000, done 27-May-2001) Add a template CastingIterator
  to IoPtrList that "sees" only objects of the template type. This can
  be a simple wrapper around the plain Iterator, needing to override
  operator++ and operator*(), and adding getTypedObject().

* (27-May-2001) Split IoObject into two parts
  (1) defines the concept of having a UID which can be used to
  communicate about C++ objects with Tcl, and (2) the actual concept
  of being serializable. Some classes would benefit from (1) (such as
  Canvas/Widget) but would not need (2). Part (1) would probably move
  into the Util package.

  OK, for better or worse I made a mother-of-all-base-classes
  Util::Object, which inherits from RefCounted and provides the UID
  functionality.

** (6-June-2001) The rest of this refactoring is now done, as
   IO::IoFactory has gone to Util::ObjFactory, IO::IoMgr to
   Util::ObjMgr, and IoDb now stores Util::Object*'s. IdItem is also
   moved to util/.

* (3-Jul-1999, 7-Jun-2001) Need to correctly handle
  widget destruction within the ObjTogl package. The problem is that
  if a new Togl widget is created and then destroyed, the "offical"
  Togl widget (the singleton) is no longer the current glX rendering
  context... perhaps there should be a line in both the create and
  destroy callbacks that resets the "official" widget as the
  glX-current context. [Later] This is handled now in
  Toglet::currentToglet Tcl command.

* (12-Jun-2001, done 13-Jun-2001) Can we get weak references going?
  This would solve the problem of the disappearing Togl widget. My
  idea:

** (done) get rid of PtrHandle and NullablePtrHandle
   these are basically used only in Ref and MaybeRef

** (done) Add a virtual function isVolatile() to RefCounted...
   this defaults to returning false, but classes like Toglet can
   override to return true.

** (done) Don't allow strong ref's to be made upon volatile objects.

** (done) Add a WeakRef class in parallel with Ref and MaybeRef
   Or perhaps MaybeRef can be merged into WeakRef, so that the new
   class allows a null pointee, and will take a weak ref if a strong
   ref is not available.

* (4-Jun-2001, done 15-Jun-2001) Should ditch the idea of singleton
  Expt and Togl objects... things would be easier without them.

** (done 6-Jun-2001) ExptDriver should own a GWT::Widget.

** (done 6-Jun-2001) OK, now I've renamed ToglConfig to Toglet
   and generally rearranged things so that we can have multiple
   Toglet's in existence at once.

** (done 6-Jun-2001) Hmm... there's is a bit of a problem with Togl,
   since we can't totally control the lifetime with ref-counting,
   since the widget can be destroyed at any time by closing the app's
   window. For now I can decouple the lifetime of the Toglet from the
   lifetime of the actual X Window... window creation could still be
   done with a Togl::init, and when the X Window is destroyed, we call
   back to Toglet to let it set itsTogl* to 0.

** (done 11-Jun-2001) Removed the global dependence
   on a singleton experiment by removing Application::getExperiment()
   (although it was replaced by Application::getCanvas(), mostly for
   the benefit of Bitmap's who need access to a Canvas to do
   screen/world translation).

* (6-Jun-2001, done 15-Jun-2001) Allow name aliasing in Factory?
  This would help to allow backward compatibility for the
  serialization system...

* (28-Mar-2000, done 15-Jun-2001) The Togl widget can take over
  its own event dispatching by calling Tk_CreateEventHandler; then we
  can add event bindings to the widget using C++ only, without having
  to use Tcl script code.

* (9-Jul-2001) Big issue: finding a workable computing environment
  to get going with new models. Main question: which high-level
  language(s) to use?

  Choices:

** Tcl:

       + I already have a lot of time invested here, and a good
         framework for interfacing Tcl with C++.

       - poor support for numerics -- I could implement my own
         objects, but even then the syntax is very clumsy (no infix
         operaters, no slices, etc.)

       - unfamiliar interface for visualization

** Matlab:

       + Good visualization tools

       + Huge numerical library already available

       - Slow

       - Programming language lacks facilities for modularity

       - Clunky C-interface

** Python:

       + Dynamic object-oriented language

       + Excellent facilities for modular programming

       - Unfamiliar C-interface (but C++ interface is in boost::python)

       + NumPy package

       - May not work as an experiment scripter (no event loop)

** (done 10-Jul-2001) OK, I have a plan!
   I tried using the MATLAB engine API, and found it was very easy to
   set up an embedded MATLAB engine in Tcl, so that we can exchange
   arrays with the MATLAB workspace, and can run arbitrary MATLAB
   commands in the engine (including visualization, etc.).

   So, for now, I can keep using the Tcl interface as I have been, and
   now introduce the classification models there.

   In the future, I can switch over to Python/C++/MATLAB, but this is not
   urgent now.

* (10-Jul-2001, done 11-Jul-2001) Refactor all the Tcl_Obj* conversions:
  we should have one set of template free functions
  Tcl::getValFromObj<>, which do not require a Tcl_Interp*. These can
  be used in TclCmd and in TclValue. Then TclValue will not need a
  Tcl_Interp*.

* (4-Jun-2001, done 11-Jul-2001) Could have a CmdContext class
  that represents the arguments and return value of a Tcl command
  invocation, and change the interface of TclCmd::invoke() to
  TcmCmd::invoke(CmdInvocation& inv). Right now the CmdInvocation
  stuff is just rolled right into TclCmd.

* (10-Jul-2001, done 12-Jul-2001) Implement VecCmd.

* (27-Jun-1999, done 13-Jul-2001) could perhaps use TclCmd again
  in KbdResponseHandler to wrap up the event binding... this would
  allow for exceptions during the event handling.

* (2-Nov-2000, done 16-Jul-2001) Can replace void*'s in tclitempkg.h
  with something safer?  [16-Jul-2001] Yes... finally this is done,
  with all-generic functor approach to building TclCmd's.

* (24-May-2001, done 16-Jul-2001) Should enable objects to be passed
  to/from Tcl by specializing declareGetter(), declareSetter(), etc.,
  so that IdItem's are converted to/from IO::UID's as necessary. OK,
  this was done with partial specializations of CGetter and
  CSetter. But, now, is there some way to unify this mechanism with
  the one that extracts the object from the first argument of Tcl
  commands?  [16-Jul-2001] OK, this is done now with specializations
  of the static functions in the Tcl::Convert<> template.

* (15-Jul-2001, done 18-Jul-2001) Who still uses addCommand?
  ... after a bunch of whittling, I've got it down to just
  TclItemPkg... so now, we can make addCommand() protected in
  TclPkg. Then, all public clients can just use TclItemPkg, so we can
  rename TclPkg to Tcl::PkgBase, and rename TclItemPkg to Tcl::Pkg.

* (17-Jan-2000, done 18-Jul-2001) We should have a TclVecItemCmd<C>
  template that parallels TclItemCmd<C> but can handle vectors of
  items. Mainly it would need a getItems() member that returns a
  reference to a vector<C*>. ... no, better would be to have getItems()
  take an insert iterator. Actually, there ought to be some way to get
  the base class to take care of most of the iteration, so that the
  subclasses just need to define what to do for each element. This would
  be similar to the way VecSetterBaseCmd provides a partial
  implementation for TVecSetterCmd. [Later] This need is taken care of
  with the new template-functor approach to Tcl commands.

* (10-Nov-1999, done 18-Jul-2001) Had an idea
  for allowing TclCmd's to be more generic... define abstract classes
  of extractors, which provide ways to get C++ types out of
  Tcl_Obj*'s. The native types would be straightforward, but more
  interesting would be to define extractors for STL
  containers... actually, would this give me anything more than I have
  now with the various getXxxFromArg() methods in TclCmd? Answer: Yes
  -- it would provide a bit more modularity, since the extractors
  would be separate from the commands, and new extractors could be
  introduced without having to add a method to TclCmd by subclassing
  it. [Later] Interesting... this is just about exactly what I have
  implemented with the Tcl::Convert<>::toTcl() and
  Tcl::Convert<>::fromTcl() functions, which work along with a
  Tcl::Context to set up a command invocation.

* (18-Jul-2001, done 18-Jul-2001) GrObjImpl is a mess
  because we don't always have a bounding box... why not split off a
  base class of GrObj which doesn't require a bounding box, so that
  the implementation of GrObj can be more demanding and require a
  bounding box.

* (5-Oct-2000, done 20-Jul-2001) Add zstream to Pbm.

* (21-Jul-2001, done 6-Aug-2001) Clean up Trial
  by getting rid of GxSeparator's there. Get rid of add(). Then
  itsGxNodes can be actually GxNode's and not GxSeparator's.

* (done 8-Aug-2001) Rename fixed_string to fstring or dstring.

* (done 8-Aug-2001) Make Error hold a fixed_string by value.

* (8-Aug-2001, done 9-Aug-2001) Dump Error template constructors
  and template append()'s.

* (8-Aug-2001, done 9-Aug-2001) Dump string_literal.

* (19-Jan-2000, done Jul-2001) Does BitmapRep really need
  to implement grUnRender(), or can we just use GrObj's
  GROBJ_CLEAR_BOUNDING_BOX mode? ... the latter.

* (10-Aug-2001, done 10-Aug-2001) GrObj:

** make GLCacheNode (extract it out of GrObjRenderer)

   and put it on top of the GrObjNode

   this will handle GLCOMPILE, SWAP_FORE_BACK and CLEAR_BOUNDING_BOX

** make BitmapCache (what is left of GrObjRenderer)

   and put it on top of the hierarchy

  this will handle GL_BITMAP_CACHE and X11_BITMAP_CACHE

* (14-Aug-2001, done 15-Aug-2001) Migration path for Field:

** make Field class unnecessary (or at least trivial)

** real functionality should go into
   FieldContainer, FieldInfo, and FieldMemberPtr

* (done 15-Aug-2001) Rename FieldInfo to Field.

* (8-Oct-1999, 15-Aug-2001) GrObj should use Property's
  so that GrObj attributes can be added to the list of a subclass's
  attributes. [Later] OK, made GrObj a FieldContainer.

* (5-Jun-2001, done 20-Aug-2001) Use a virtual iterator
  w/ envelope/letter pattern for my custom iterators that wrap STL
  iterators (such as IoDb::Iterator).  [Later] This would come in
  quite handy in allowing read/write sequences to be virtual functions
  of Reader+Writer rather than external templates in
  Read/WriteUtils. [Later still] OK, implemented Util::FwdIter<>,
  Util::BidirIter<>, and Util::RxsIter<>, which are all implemented as
  handles to an appropriate interface. Adapters are provided which
  implement these interfaces from STL-style iterators or raw pointers.

* (14-Oct-1999, done 21-Aug-2001) Gabor should have
  a patchWidth/patchHeight attribute, that controls not the size of
  the object inside the patch, but the size of the patch itself
  (i.e. how big the window onto the Gabor patch is). [Later] This is
  accomplished with the resolution and pointSize fields.

* (15-Oct-1999, nixed 21-Aug-2001) There's a unifying force
  behind two things: 1) Tcl's idea of dual representation-- native
  rep/string rep; and 2) idea of serializing objects to a stream by
  converting them into a string format. I don't know exactly what to
  make of it at this point, but it seems like it could be
  useful... This is parallel to the duality of makeIoList and
  getProperties()... these should really be merged. Dual-rep objects
  (perhaps a new DynamicValue subclass of Value) could be used in the
  implementation of AsciiStreamReader. [Later] Unfortunately this
  scheme won't work, since in a round-trip conversion to+from string,
  objects lose their identity--i.e., if we have two identical
  string-reps, do they refer to the same object, or to different but
  identical objects?

* (15-Jan-2000, done 7-Jun-2001) ExptDriver should really own
  the widget... Then we can eventually have multiple Experiment's at
  once, each with its own widget??? is this right? Eventually, we'd
  like to have a list of Widget's, with ExptDriver maintaining the
  current one for an experiment, so that experiment participants can
  request it from ExptDriver (or it passes the Widget to
  them). [Later] OK, now we can have multiple experiments AND multipl
  Toglet's.

* (27-Nov-1999, obsolete 18-Jun-2001) Who uses theToglet()?
  EventResponseHdlr uses the Widget part in the attend() and ignore()
  methods ExptDriver uses the Canvas part it in swapBuffers().
  ExptTcl uses the Widget part in BeginCmd, SetStartCommand, ObjTogl
  uses the Widget Part in DestroyCmd.  ObjToglPkg uses it in
  getCItemFromId().  xbitmap.cc uses a special X11Widget subclass in
  init_class().

* (27-Nov-1999, done 18-Jun-2001) One important reason for refactoring
  all this Togl stuff is so that we can have more than one active Togl
  widget... then we can improve user interface, e.g. bring up a dialog
  box to edit a GrObj, etc.

* (17-Aug-2001, done 22-Aug-2001) Get rid of Util::Observer
  use templated callbacks instead. OK, I've got Signal+Slot going now,
  but only with no-arg callbacks.

** (done) Rename Observable to Signal.

** (done) Rename send/receiveStateChangeMsg() to send/receiveSignal().

** (done) No one should inherit from Util::Signal
   Instead, they should be contain a Util::Signal.

** (done) No one should inherit from Util::Observer.

* (25-Jun-1999, done 22-Aug-2001) Need a coherent way
  of handling colors... [Earlier] Who should own foreground/background
  information?  Seems like it could belong to either or both of GrObj
  and Position. Maybe best idea is to use ColoredObj and
  ColoredPosition as derived classes, if necessary. Default behavior
  of non-colored classes would be to use whatever color was active,
  while colored classes would set their own color when they do their
  action. Useful scenarios would be ColoredPosition with regular
  GrObj, or ColoredObj with regular Position. [Later] Maybe new
  subclasses aren't needed, since this would create a dual hierarchy
  for all other subclasses (i.e. there would have to be a regular
  FixPt and a ColoredFixPt). Part of the state of both GrObj and
  Position could be whether they have a color preference; if so, they
  use it, and if not, they use the current color when they are
  drawn. [15-Jul] Aha! I think I've got it... there should be a class
  GLAttributes that can specify things like foreground/background
  color, line width, etc. and one subclass could be a null subclass
  that just does nothing; a virtual method setAttribs() would arrange
  to set all of the attribs controlled by the class (but how to unset
  them?  would be nice to use constructor/destructor via lexical
  scope). Then both GrObj and Position could contain a GLAttributes
  member which would control the appropriate attributes, if
  any. [3-Aug] What is needed is a good abstraction to model what
  happens when a trial is rendered. In particular, how to represent,
  say, that we should go to a Position, then draw a GrObj, then un-go
  from that Position, then go to a new Position... We need some kind
  of a GraphicParticipant class, that has begin() and end() functions,
  that is able to capture at once the current Position and GrObj
  classes, as well as the forthcoming GlAttributes class. I guess this
  is the composite pattern-- which we can use to build an arbitrarily
  nested list, or tree. [Later 30-Nov-2000] This will all be real
  slick now with GxNode/GxSeparator, with possible subclasses
  GxColorIndex and GxRgbaColor. Then colors can go into the scene
  graph. [Later 22-Aug-2001] OK, I've implemented GxColor, a GxNode
  for rgba colors.

* (12-Dec-1999, done 23-Aug-2001) Could have an abstract class
  for timer callbacks, one subclass of which could use a Tcl_Interp*
  to register timer callbacks. [Later] OK, now I've got Tcl::Timer,
  which exposes a Util::Signal that can be connect()'ed to, by clients
  who want to receive timer callbacks.

* (24-Jun-2001, 2-Sep-2001) Allow other kinds of Field's
  besides numeric ones: string fields, sequences, and enums. These can
  then be manipulated by appropriate widgets: entries (strings),
  trees?  (sequences), and list boxes (enums). OK, we're on our way on
  this one now; I've added various flags that can be specified for
  Field's, including STRING, MULTI, TRANSIENT, NO_GET, NO_SET,
  NEW_GROUP; and this architecture is extensible enough for now.

* (31-Aug-2001, done 3-Sep-2001) Need to merge Value and Tcl::ObjPtr
  somehow, since Tcl::ObjPtr is much more expressive. OK, I didn't
  merge the two, but instead I made the whole Field system rely on
  Tcl::ObjPtr's instead of Value's. This allowed for sweeping cutbacks
  in the responsibilities of Value: first, we could eliminated
  TValue<>, TValuePtr<>, and TclValue, and second, the Value interface
  was cut back to just get/set for strings, plus printTo() and
  scanFrom().

* (2-Dec-2000, obsolete 3-Sep-2001) Should Value be implemented
  using Coplien's envelope/letter idiom? Value's could then be passed
  around as stack objects, and they could contain ref-counted smart
  pointers to different value implementations. The implementation
  would be the same interface, but a separate inheritance
  hierarchy... in effect we'd rename the current Value hierarchy to
  ValueType. Or... maybe we should just be passing around
  shared_ptr<Value>'s, making Value a ref-counted type.

* (29-Aug-2001, done 3-Sep-2001) Hmmm... got a problem with Signal
  connecting... in the Fish constructor, we try to connect "this,
  updatePtrs" to a signal. But, since nobody has ref'ed "this" yet, it
  appears to be a dead object to the SoftRef constructor, which then
  neglects to actually form a reference. How to fix? (1) keep a flag
  in RefCounts indicating if the object is live or dead, (2) make
  SoftRef's less hasty to release their reference. Actually, this
  would be an even worse problem if we were trying to construct strong
  Ref's from "this" in a constructor, since if the Ref went out of
  scope before the constructor completed, the object would be deleted
  prematurely. [3-Sep-2001] OK, I added
  RefCounts::releaseStrongNoDelete() and
  RefCounted::decrRefCountNoDelete(), which I used to implement
  Util::FloatingRef<>. FloatingRef is now in use in the Fish
  constructor... seems to work OK. Still need some discipline to make
  sure that FloatingRef is used where necessary... basically anywhere
  that can be called from a constructor.

* (3-Sep-2001, done 4-Sep-2001) A memory leak
  seems to have popped up... noticeable when running the batch file
  conversion job, especially with the fMRI data files. OK, fixed it --
  problem was that I wasn't disconnect()'ing in the GrObjBBox dtor
  from the Signal that was connect()'ed to in the ctor. Will try to
  get a Connection object set up to manage these things properly.

* (3-Sep-2001, done 4-Sep-2001) Change GrObj I/O to use the FieldMap.

* (3-Sep-2001, done 4-Sep-2001) Eliminate GrObj unrender mode.

* (4-Sep-2001, done 4-Sep-2001) I've semi-broken GrObjScaler
  along the way of changing GrObj IO to use width/height rather than
  widthFactor/heightFactor.  Need to roll back those changes and start
  again.

    ---> put the old asw files back in place

    ---> roll back GrObj scaler

    ---> reconvert the asw files to strip the "GrObj::" prefixes

    ---> implement Field::PRIVATE, so we can use width/heightFactor for
         IO, but not for the GUI

* (9-Sep-2001, done 9-Sep-2001) Make Tcl::Command ctor take fstring
  not const char*, args. Well, instead I made Tcl::Command::Impl hold
  fstring's internally; this is good enough.

* (9-Sep-2001, done 9-Sep-2001) Move dlist_... commands
  to dlist::... Add dlist::slice.

* (10-Sep-2001, done 12-Sep-2001) OK, here's my bright idea
  for how to run unit tests of C++ code: put all the test cases into a
  Tcl package which can be dynamically loaded into the interpreter,
  and then the test cases can be run. This would help get my feet wet
  with dynamically-loadable extensions as well. [12-Sep-2001] I've got
  the first test done. The only problem is that I have to maintain
  things in several places in order to add a new test module: (1) add
  a src/tests/*.cc file, (2) add an entry in
  ~/local/$ARCH/lib/grsh/pkgIndex.tcl, (3) add a testing/*.tcl
  file. For now I'm just DSTTTCPW, and hoping that any necessary
  structure will fall out of refactoring as I push this forward a
  bit. Goals are: (1) any time a bug or crash occurs that was
  unrevealed by a test, add an appropriate test file that exposes the
  bug, then fix the bug, and (2) any new functionality that is added
  should be done in parallel with new unit tests.

* (13-Sep-2001, done 14-Sep-2001) OK, to get real packages working:
  there should be a "src/pkgs" directory, within which there would be
  one directory for each package (i.e., "src/pkgs/face",
  "src/pkgs/grobjs"), and all the source files in each subdirectory
  would be linked into one shared library containing a Tcl_PkgInit
  function, so that it could be loaded with 'package require' into
  Tcl. This unified structure would allow us to automatically generate
  the pkgIndex.tcl file using make. [14-Sep-2001] Cool! This is mostly
  working now. I'm able to have things be quite automated with this
  directory structure. We can build a .so --> .o dependency file for
  make, based on the directory structure. And, based on #include
  "pkgs/*/*.h", we can figure out which other packages are required by
  a given package.

* (note 20-Sep-2001) Compile times for including standard headers
  on 1GHz PIII, g++-3.0.1:

       <string>    0.440u  "util/strings.h"     0.090u
       <vector>    0.310u  "util/minivec.h"     0.180u
                           "util/arrays.h"      0.030u
       <valarray>  0.993u
       <list>      0.300u  "util/dlink_list.h"  0.080u
                           "util/slink_list.h"  0.030u
       <map>       0.460u
       <set>       0.447u
       <iostream>  1.505u  <cstdio>             0.046u
       <istream>   1.452u
       <fstream>   1.738u

       <memory>    0.217u
       <utility>   0.021u
       <algorithm> 0.253u

* 2002 STARTS HERE

* (done 25-Jan-2002) Logging
  OK, have a simple scope nesting and timing architecture in place for
  logging.

* (done 17-Jan-2002) More efficient bitmaps
  Improve (startup time, memory use) for eyetracking stimulus scripts?
  Things are speedier with queuePbmFile(), so that bitmaps are only
  loaded when needed, and with purgeable bitmaps, so that the memory
  is freed immediately after the bitmap is drawn. This is a reasonable
  tradeoff if each image is going to be displayed relatively few times
  compared to the overall number of images used.

* (done 28-Jan-2002) decode responses by a Tcl 'proc'
  Implemented a first attempt at allowing responses to be decoded by a
  "proc"-like Tcl code block, rather than by a regular expression
  mapping. Eventually the old regex approach can probably be
  encapsulated within the new more flexible approach.

* (done 28-Jan-2002) multiple responses within a single Trial run
  OK, added a "maxResponses" attribute to EventResponseHdlr so that we
  can specify an arbitrary number of responses (instead of the
  default, 1) to be allowed in each activation cycle, before the
  response handler goes quiet.

* (28-Jan-2002, done 30-Jan-2002) generic Tcl code wrapper
  Would be nice to have a reusable class that can wrap a Tcl procedure
  that can be serialized and deserialized. We are already doing this
  in practice in ExptDriver (with the doUponCompletion script) and in
  EventResponseHdlr (with the responseProc). Should be able to
  refactor out the common code. OK, I extracted TclProcWrapper from
  EventResponseHdlr's former ResponseProc class, and made it an
  IO::IoObject (all this after much painful debugging that was
  eventually solved by Electric Fence). Next step is to extract it
  physically, and then re-use it in ExptDrvier. This should eventually
  be a very useful and powerful class -- it's a nice interface to
  provide extensible hooks + callbacks. [30-Jan] OK, extracted out
  Tcl::ProcWrapper and put it into place in ExptDriver. This is
  looking like a nice powerful tool now.

* (24-Aug-2001, done 31-Jan-2002) infix member function calls in Tcl
  So we can do "$f eyeHeight 0.4" rather than "Face::eyeHeight $f
  0.4". I don't think I'll have a problem getting the mechanics of the
  function calls set up... but the problem is, how to get Tcl commands
  registered for all of the objects? Or just resort to using
  "unknown"? Or... just set up inheritance, so that for example, the
  "Face" namespace in Tcl inherits all the commands in "GrObj",
  "GxNode", and "IO", for example. [3-Sep-2001] Hmmm, no, the real
  problem is not how to get Tcl commands registered (this could be
  done in the Convert::toTcl functions), but rather how to allow easy
  vectorization of commands?  Maybe all my OO stuff could go under a
  Tcl cmd "with", so we can do "with $f eyeHeight 0.4", which would
  work whether $f was single- or multi-valued. [31-Jan-2001] Could get
  working notation using namespace eval in a special oo command,
  perhaps named "->". Need to provide a way for Tcl::Pkg's to
  inherit() the functions in other packages. The idea would be that a
  Pkg would first inherit() all the necessary functions, then it would
  define its own functions. That way in case of a name conflict, the
  new function would overwrite ("hide") the inherited function. We
  could still access the overwritten function with an explicit
  qualification. Done -- added a "->" command that provides infix
  syntax. Inheritance is managed through namespace importing/exporting
  via Tcl::Pkg::inherit().

* (31-Jan-2002, done 1-Feb-2002) Add fstring operator!=().

* (30-Jan-2002, done 2-Feb-2002) Segfault on "? new".
  Fixed: Re-fixed the local function lookupCmd(), so that it won't
  crash if it is passed a command name that refers to a
  non-Tcl::Command command (such as a tcl proc). Apparently my idiom
  of dynamic_cast<>(static_cast<>()) was not sufficient to test
  whether we actually had a valid Tcl::Command*; instead I now just
  manage a std::set<void*> holding the addresses of valid
  Tcl::Command's.

* (23-Feb-2002, done 23-Feb-2002) shared libraries on OS X?

  with SHLIB_CMD := cc -dynamiclib -flat_namespace -undefined suppress -o
    --> libraries build ok
    --> executable links ok
    --> executable fails at startup due to undefined c++ iostream symbols
    --> adding -lcc_dynamic to each of the link commands doesn't help

  Aha! need to use "c++" instead of "cc", with -lcc_dynamic, so we have:
    c++ -dynamiclib -flat_namespace -undefined suppress -o {name} -lcc_dynamic

* (23-Sep-2000, nix 14-June-2002) log-file?
  Should have a log-file that can catch non-essential messages (such
  as the timing info that is emitted by TrialEvent destructors). [nix
  this... logging is now improved somewhat with Util::log]

* (14-Jun-2002, done 17-Jun-2002) Fix dynamic loading
  so that we don't have to link in matlab stuff to the main
  executable, but just to the mtx package.

  Get this bogus crap:

  [hume 16:52 52]% testsh
  (1) testsh> package require Mtx
  couldn't load file "/cit/rjpeters/local/i686/lib/visx/mtx.so":
   /usr/local/matlab/extern/lib/glnx86/libut.so: undefined symbol: _start

  Aha. Have to use the linker option --export-dynamic, so that libut.so can
  find the _start symbol which is of course defined next to wherever main()
  is defined, which would be in the executable itself.

* (note 2-Jul-2002) OS X porting note: -install_name with ld
  Ran into problems with tk8.4a4; specifically, got "could not find
  dynamic library libtk8.4a4.dylib" at runtime when trying to run
  testsh. The problem was in the Tk makefile, which failed to set the
  -install_name option when ld'ing the dylib.

* (16-Aug-2001, done 5-July-2002) Bounding boxes for all GxNode objects?
  How do we allow a Position, for example, to return/transform a
  bounding box? ... OK, the GxNode function takes a Rect reference, so
  that subclasses can either transform or extend that Rect.

  [Later] OK, this was done by having all of the bounding box
  calculations take place actually with 3-D bounding cubes... that
  allows us to properly account for the effects of arbitrary
  coordinate transformations. Only at the final stage do we extract a
  2-D screen-aligned bounding "box" from the cube.

* (21-Jun-1999, done 26-Sep-2002) GL coordinates <--> visual angle
  This is basically already in place with Togl::setViewingDistance and
  Togl::setUnitAngle.

* (May-1999, nix 26-Sep-2002) Implement GLenums without STL maps
  Probably best to use Tcl_Index API's, to search for matching string
  in array, and retrieve its index. [Later] This issue is mostly moot
  now, since the problems with STL maps was just an issue of long
  compiles on old HP machines, but is not a significant problem now
  with linux/gcc.

* (5-Oct-1999, ok 26-Sep-2002) TimingHdlr response behavior?
  Maybe TimingHdlr should have a toggle switch to indicate what the
  behavior should be when a response is seen. (Whether to cancel
  StartEvents, etc.). [Later] I think we have a decent heuristic in
  place here now: namely, if the response-queue is non-empty, then we
  cancel the start events and schedule the response events, otherwise
  we do nothing.

* (14-Dec-1999, ok 26-Sep-2002) Need Canvas& argument to GrObj::grGetBoundingBox
  OK, this stuff has been in place for a while now.

* (1-Nov-2002, done 4-Nov-2002) Get all Value-subclasses to be Tcl::Convert'ed

  Maybe need to use function overloading instead of partial
  specialization?  Function overloading is more flexible, allowing
  subclasses to be passed via reference-to-base-class.

  Strategy: First add a set of template functions that just forward to
  the current Tcl::Convert functions. Then, hid the old template
  functions to force all clients to use the new interface. Then,
  gradually add overloads of the new template functions. Eventually,
  none of the old specializations will be needed, and then they can be
  phased out.

** Best names for functions?

   fromTcl()/toTcl() ?
   toNative()/fromNative() ?
   export()/import() ?

** How to specialize fromTcl() for Value types?

   The problem is that we can't return by value (no pun), but need to
   return through a reference, since we don't know in advance what
   type of Value object we're going to be dealing with. Would like to
   specify somehow that "all Value objects should be gotten from Tcl
   by assigning to them through an fstring". Aha... just needed a bit
   of template metaprogramming a la "Loki" here.

* (4-Nov-2002, done 5-Nov-2002) Dynamically-sized array-Value objects?
  OK, TArrayValue<T> fits the bill here, holding a minivec<T>.

* (9-Nov-2002, done 13-Nov-2002) GLUtil just has font functions
  Make a new font class? Or move this stuff into Gtext? Yes, yes,
  yes. OK, GLUtil is history. We have a GxFont class now, with
  raster-font and vector-font implementations, which is used by Gtext.

* (13-Nov-2002, done 20-Nov-2002) Cleanup GrObj once and for all
  OK, replaced Gnode with GxBin. Changed all of the Gnode subclasses
  into generic Gx* node subclasses. So now I feel better; all the
  stuff is generic. In principle GrObj could become a Gx* class now
  itself.

* (done 20-Nov-2002) Rename GrObj --> GxShapeKit

* (done 20-Nov-2002) Rename Position --> GxTransform

* (9-Nov-2002, done 20-Nov-2002) X11Util just has findColormap()
  Moved this back into Togl.
   GxText

* (done 20-Nov-2002) Merge GlxWrapper and GLCanvas functionality.

  [ok] Move glxwrapper.* and glxattribs.* and glxopts.* into src/gfx/.

  [ok] Rather than GlxWrapper owning a GLCanvas, it should be the
  other way around. Togl should own a GLCanvas then instead of a
  GlxWrapper.

  [ok] Tcl interface to GL should go through GLCanvas instead of Togl
  (i.e. functions like isRgba and isDoubleBuffered).

  [ok] Ultimately the only purpose of Togl should be to bind a
  GLCanvas to a "physical" X window.

* (done 21-Nov-2002) Put X11-rendering into GLCanvas.

* (done 21-Nov-2002) Get rid of GLBitmap/XBitmap
  OK, these are merged into bitmaptcl.cc... that's probably as far as
  I can go for now, since I still need at least a shell of class
  definitions for GLBitmap/XBitmap in order to be able to read old
  expt files.

* (done 21-Nov-2002) Rename Bitmap --> GxPixmap

* (done 21-Nov-2002) Rename Gtext --> GxText

* (done 21-Nov-2002) Merge Togl into Toglet
  visx/tkwidget --> gwt/tkwidget
  visx/toglet + togl/togl --> gwt/toglet

* (28-Nov-2000, OK 21-Nov-2002) GxShape base for GxLine, GxRect, GxDisk, etc.
  Looks like we've pretty much met the goal behind this one.

* (13-Sep-1999, done 22-Nov-2002) Refactor Toglet into Widget, Camera, Canvas

** (27-Nov-1999, done 22-Nov-2002) Widget class has a Camera and a Canvas
   Or does the Camera need to contain the Canvas? It seems like the
   Window will pass a redraw request on to its Camera, which would
   need to have a Canvas reference to pass to the graphic objects in
   order for them to redraw themselves. [22-Nov-2002] Cool. Finally
   got this exactly how it should be as above: we have GWT::Widget
   which has a canvas (via a virtual function which is implemented by
   Toglet) and holds a single drawable object (the "scene") and a
   single camera.

** (17-Nov-1999, done 22-Nov-2002) The Camera abstraction
   includes some of the Toglet functionality such as perspective or
   orthographic projection, viewing distance, viewport, and which will
   be used by a Window/Widget to handle redraws and reconfigures. A
   subclass of Camera can carry the Tlist functionality such as
   setVisible(), setCurTrial(), etc. Actually, it seems there are two
   different parts to camera: one is the object/scene that it is
   viewing, and the other defines the sort of projection that is
   used. [Later] Pfft... camera doesn't need to know anything about
   the object/scene it is viewing; all it needs to do is set up the
   viewport and projection matrix.

** (13-Sep-1999, done 22-Nov-2002) Change Toglet to a "Camera"-style interface
   a la Open Inventor. Then different types of camera's, such as
   orthographic or perspective projection, could be related by
   inheritance from an abstract base class Camera. Parameters include
   viewing volume, autoUpdate (determines if scene is automatically
   redrawn upon Expose or Resize events)... [Later] OK, now I have
   GxCamera, GxFixedScaleCamera, GxPerspectiveCamera, and
   GxPsyphyCamera, among others.

* (16-May-2000, nix 22-Nov-2002) Make bitmap caching more fluent

  Need to have a way to explicitly represent GrObj's with
  cached-bitmap-file representations... this way we can have access
  both to a GrObj's semantic properties (i.e. face width, nose length,
  etc.)  while still accessing it in a bitmap form. This would involve
  a command to cache a GrObj to file, given a filename, and then the
  object should automatically load that file when it is deserialized
  at a later time.

  [Later] OK, as of now it really looks like bitmap caching is not
  going to be much of an issue. It was mainly needed on really
  old+slow hp machines whose OpenGL implementations ran like molasses.

* (28-Sep-2000, nix 22-Nov-2002) irix core dump
  Why does irix occasionally core-dump during Face testing in
  GrObj::invalidateCaches()? [Later] Who knows? Who cares?

* (14-Dec-1999, nix 22-Nov-2002) Bitmap::grab{Screen,World}Rect needs a Canvas&?
  [Later] OK, this one sounds totally out of date.

* (3-Sep-2001, done 22-Nov-2002) class-based inheritance of Tcl commands
  We don't need multiple TclCmd objects, instead we just need to
  register the same TclCmd object under multiple names. [Later] OK, we
  can basically achieve this kind of inheritance by just making use of
  Tcl's ability to import/export commands from namespaces.

* (done 22-Nov-2002) Merge Tcl::PkgBase and Tcl::Pkg again?

  Actually, the stuff in tclpkg.h now should go to a new "objpkg.h".
  And I'll leave Tcl::Pkg in place since it introduces a lot of
  #include overhead beyond Tcl::PkgBase, so it's nice to keep that
  isolated.

* (22-Aug-2001, done 25-Nov-2002) Allow args in the Signal/Slot callbacks
  e.g. for event handlers

  Now I've got SlotBase <-- Slot0 <-- SlotAdapter0.

  But instead of Slot0 <-- SlotAdapter0, should just have the Slot0
  class hold an appropriate Util::Functor.

  OK, multi-arg Slot+Signal is off the ground now. Still might want to
  use Util::Functor there at some point.

* (done 23-Nov-2002) Rework GWT::Widget

  Need to rework the Widget inheritance hierarchy. Right now we have a
  bloated base class in GWT::Widget. That class should become much
  more lightweight and not have any Tk- or GL-specific stuff in it.

  Most of GWT::Widget should be like a "Gfx::Scene class", which
  should be similar to a GxNode.

  Clients that need the "Scene" interface shouldn't have to know that
  they're dealing with a Widget/TkWidget/Toglet... so right now that's
  why we have "Scene" functionality in the Widget base class. But that
  doesn't really make sense because not all Widgets should be Scenes.

  GWT::Widget's implementation has basically two parts: (1) stuff for
  Scene management, and (2) lists of Listeners. The Listeners should
  stay since those belong in a generic widget interface.

  For now we should just "tell it like it is", and move all the
  GL-related stuff into Toglet. Expt/Block/Trial should then deal with
  Toglet instead of GWT::Widget, since they're implicitly requiring
  that right now anyway. That gives us a starting point for
  refactoring.

* (24-May-2001, obsolete 25-Nov-2002 ) Maybe Togl should be a canvas

  or we should have a ToglCanvas, so that swapBuffers() can go in
  Canvas, where it seems to belong, rather than in Widget, where it
  sits now (basically to allow Toglet to implement swapBuffers by
  calling Togl something).

* (16-Mar-2000, obsolete 5-Dec-2002) what happens on Block::abortTrial()?
  Block should have a parameter (or virtual function) to control what
  happens on abortTrial()... i.e., should we reschedule the trial,
  ignore the trial, record an invalid response? [Later] OK, this
  responsibility is now in Trial itself, where it belongs, using the
  ChildStatus (CHILD_OK, CHILD_ABORTED, CHILD_REPEAT) parameter to
  vxNext().

* (20-Jan-2000, obsolete 5-Dec-2002) a Trial::prepare() function?
  We should set up a way for Trial's to have a prepare() function
  which would do things like update its GrObj's (and flush pending
  requests like loading bitmap data). Then Block's could have a
  prepareNextTrial() function which could be called during the
  preceding trial. [Later] Hmmm, if I ever were going to implement
  this, it would be better done generically with in implementation of
  idle callbacks.

* 2003 STARTS HERE

* (15-May-2003, done 22-May-2003) Premature destruction of VolatileObject's.

  OK: we have
      RefCounted->Object->GWT::Widget->TkWidget->Toglet

  TkWidget calls incrRefCount() in its constructor, to make sure that
  the ref count stays. But then Toglet's constructor does something
  that throws. This causes any fully-constructed subobjects (such as
  TkWidget) to have their destructors run. Eventually this leads to
  ~RefCounted() with refcount != 0. Where is the design flaw here?

  Seems like the problem is with TkWidget calling
  incrRefCount(). Ideally, we'd like the "last" constructor to call
  incrRefCount() just before it finishes. Hmmm... in fact it's not
  even TkWidget that is the "volatile" object -- it's really Toglet
  since that's where we override isNotShareable(). So (1) the solution
  is that Toglet should handle the incrRefCount() call, and (2) it
  probably makes more sense to put that incrRefCount() into
  Toglet::make() rather than directly into Toglet().

  OK, come to think of it, why do we need to have the true refcount >
  0 for volatile objects EVER? In principle we should make the
  refCount() function return 1 always for volatile objects. Maybe the
  problem is that we have isNotShareable() as a virtual
  function... it'd be better if it were a boolean flag inside
  RefCounts... then we could do more with it.

  * rename isNotShareable() to isVolatile()
  * should add a boolean isVolatile flag to RefCounts
  * should never call RefCounted::incr/decrRefCount() for volatile objects
  * RefCounts::getStrong() should just return 1 if isVolatile is true

  OK, all this is done... RefCounts+RefCounted now have really strict
  enforcement on what happens with the refcounts.

* (29-May-2003, done 20-June-2003) issues with icc 8.0 beta

  compiler error on anonymous namespace in gzstreambuf.cc:

    #include <iostream>
    namespace
    {
      struct X : public std::iostream
      {
        X() : std::iostream(0) {}
      };
    }

  this appears to be fixed with the 8.0.032 package (build 20030612Z)

* (29-May-2003, done 20-June-2003) issues with icc 8.0 beta

  dynamic_cast disaster

    #include <stdio.h>

    struct A { virtual ~A() {} };

    struct B : public A {};

    A* noop(A* a) { return a; }

    int main()
    {
      B b;

      A* a = &b;
      A* a2 = noop(a);

      // all of these succeed except the last, which causes a segfault

      B* b1 = dynamic_cast<B*>(a);        printf("1: %x\n", (void*)b1);
      B* b2 = dynamic_cast<B*>(a2);       printf("2: %x\n", (void*)b2);
      B* b3 = dynamic_cast<B*>(noop(a));  printf("3: %x\n", (void*)b3);
      B& b4 = dynamic_cast<B&>(*a);       printf("4: %x\n", (void*)&b4);
      B& b5 = dynamic_cast<B&>(*a2);      printf("5: %x\n", (void*)&b5);
      B& b6 = dynamic_cast<B&>(*noop(a)); printf("6: %x\n", (void*)&b6);
    }

  this appears to be fixed with the 8.0.032 package (build 20030612Z)

* (done 29-May-2003) workarounds for icc 8.0 beta

  * icc defines __GNUC__ in demangle.cc?

    OK, can work around this with a autoconf test for <cxxabi.h>
    instead.

  * premature failure of std::ofstream object in ~Prof()

    OK, can use C stdio (FILE*) instead.

* (23-Feb-2002, done 18-Jul-2003) OS X issues
  explicit template instantiation does not work
  (e.g. util/multivalue.cc) OK, the workaround hack is not needed with
  more recent OSX compilers

* 2004 STARTS HERE

* (17-Jul-2004, done 19-Jul-2004) Clean according to the way of UNIX!

  [DONE] remove util/dlink_list.h (not used anywhere in project)
  [DONE] remove util/hash.h (not used anywhere)
  [DONE] remove util/slink_list.h (use autoconf test for #include <ext/slist> and __gnu_cxx::slist<> instead)
  [DONE] remove util/randutils.h (use util/rand.h instead)

* (25-Nov-2002, done 2-Aug-2004) What is GWT::Widget's raison d'etre?

  OK, now I've got Widget cleaned out. But... now, what's its reason to
  exist? It barely has any abstract interface. Basically it's serving as a
  glorified mult-arg Signal.

  OK, eliminated GWT::Widget by rolling it into Tcl::TkWidget.

* (2-Jul-2002, done) new project name?

   OO framework

     hood
     loot
     ooze
     poof
     igloo
     roost
     scoop
     troop
     cooler
     noodle

   Psychophysics experiments -- groovx groovx groovx -- is this "the
   one"? yep

* (22-Nov-1999, canceled) Need to get rjp_subject working.
  1) Need to maintain a do_expt script in each subject's directory. 2)
  Need to make sure that autosave file is writable by rjp_subject, and
  if not, use a different filename. (Maybe use temp filename
  generating facility of OS?). Canceled... rjp_subject doesn't even
  exist anymore...

* (note 30-Oct-2000, done) scripts as callbacks?
  The fact that we now have good unique correspondence between objects
  and ids means that there are flexible possibilities for allowing
  scripts as callbacks. For example, a callback class could have an
  abstract function that takes an object, and an implementation could
  pass that object to a script as an id. Done... this is pretty well
  captured by Tcl::ProcWrapper.

* (12-Jun-2001, done) Refactor TogletTcl into separate Toglet/TkWidget/Widget groups

* (25-Jun-1999, obsolete) how dynamic loading should work for groovx
  all of the lists, plus all of the base classes that are held by the
  lists, need to be statically (or at least permanently dynamically-)
  linked into the groovx executable. These would be the so-called
  'core' modules. Any of the separate Tcl packages should contain the
  subclass (such as Face) and the TclPkg to work with that subclass
  (such as FaceTcl)... these units can then be loaded with the Tcl
  "load" command, and would be called 'extensions'. Dependencies
  between any of the extensions should be avoided. This hierarchy
  urges strongly for all the base classes handled on the lists to be
  abstract. The problem right now is the issue with bus errors due to
  OpenGL calls from dynamically-linked modules--most of the
  'extensions' will use OpenGL, so this probably makes them unable to
  be dynamically loaded.

  OK, later I've figured out that a problem with dynamic loading
  occurred on program shutdown. Apparently, shlib's loaded with Tcl's
  'load' are unloaded before C++ static shutdown occurs... this means
  that virtual destructors for IoObject's maybe missing when the
  IoPtrList tries to destroy them in its own destructor. Now, I've
  just figured out that a solution is to Tcl exit handlers; in fact I
  already had the framework in place via the TclPkg destructor, which
  is called from an exit handler that is registered for each
  TclPkg. So for now I just put calls to clear the ExptDriver and the
  IoPtrList inside the ExptPkg destructor; this ensures that we don't
  try to call any IoObject destructors after the libraries are
  unloaded.

  The final step is to come up with an organized build approach using
  these package files... we need to:
  1) manage the dependencies for the shlib's,
  2) make sure the pkgIndex.tcl files are updated,
  3) maintain separate debug/production trees for the shlib's

* (25-Oct-2000, obsolete) ReadUtils and WriteUtils use iterators?
  could/should really be implemented in terms of iterators that
  iterate over the elements in the stream. Then transferring elements
  to/from a local container is just a simple std::copy type of
  operation. Obsolete... this wouldn't really work now that extracting
  elements from the stream isn't so simple (since it requires looking
  up elements by name).

* (7-Jul-2000, 6-Oct-2004) Adding an 'itsCorrectVal' member to Response
  Should this value be serialized? We don't have a good way to do
  versioning of Value types that are written/read with printTo() and
  scanFrom(). [...Later] Probably if any versioning becomes necessary,
  it's a good sign that the thing should become an IoObject, rather
  than a plain Value.

  Hmmm... really the problem here is that 'correctVal' is maintained
  by Trial, rather than Response.

  Let's see who calls the Response functions that depend on
  itsCorrectVal:

    Response::isCorrect() is called by trProcessResponse()
    Response::correctVal() is called by trProcessResponse()
    Response::setCorrectVal() is called by trProcessResponse()

  Well, there you have it... Response::itsCorrectVal is really out of
  place and just belongs in Trial instead.

  OK, fixed now.

* (19-Jul-2004, done) port graphics stuff to Aqua for Darwin

  where are <GL/glx.h> and <X11/Xlib.h> used?

    glxwrapper.h
      OK - used only in glwindowinterface.cc for instantiation
    xbmaprenderer.h
      OK - not used anywhere
    glxrasterfont.h
      OK - used only in gxrasterfont.cc for instantiation

  where are GL_PLATFORM macros used?

    glcanvas.cc -- guards the <GL/gl.h> #includes
    gxvectorfont.cc -- guards the <GL/gl.h> #includes
    gltcl.cc -- guards the <GL/gl.h> #includes

    toglet.cc -- guards Tk_SetClassProcs
    tkwidget.cc -- selects implementation of WindowSystem portability layer
    gltcl.cc --	checks for GL_RESCALE_NORMAL_EXT

    gxrasterfont.cc -- selects between {Glx,Agl}Rasterfont
    glwindowinterface.cc -- selects between {Glx,Agl}Wrapper

* (22-Nov-2002, done) Cleaning out the src/visx tree.

  [ok] gtracetcl.cc --> src/tcl
  [ok] Subject class has never been used at all --> trash it

* (13-Sep-2002, obsolete) Hacks to work around broken MIPSpro compiler

** problems with template arg-dependent lookup:

   template <class F> struct Traits { enum { num = 1 }; };

   template <int N> struct Functor {};

   template <class F> struct Return
   { typedef Functor<Traits<F>::num> Type; };

   // template <class F> Functor<Traits<F>::num> buildTclFunctor(F f);
   template <class F> typename Return<F>::Type buildTclFunctor(F f);

   void bar(int) {}

   void test() { buildTclFunctor(bar); }

** return void not supported in templates

** overeager lookup of template arg-dependent names

** no <cheader> include files so e.g. size_t not in std:: namespace

* (done 14-Oct-2004) Pass a FilePosition to Tcl::Interp::handleLiveException

  --> Tcl::CommandGroup::rawInvoke
  --> Tcl::Pkg::~Pkg
  --> Tcl::Pkg::handleLiveException()
  --> Tcl::Pkg::namespaceAlias
  --> Tcl::Pkg::inherit
  --> Tcl::Pkg::eval
  --> tclpkg.h::PKG_RETURN
  --> TkWidgImpl::cEventCallback
  --> TkWidgImpl::cRenderCallback
  --> TkWidgImpl::cEventCallback
  --> Tcl::TimerScheduler::dummyCallback

  Good; now we can report three things:
  (1) from where an exception was thrown (created)
  (2) the stack state at the time the exception was thrown
  (3) the location where the exception was caught

* (done 14-Oct-2004) Lose some "eval"s in the test suite Tcl code

  Aha. This reveals a lot of tests that are run multiple times without
  any actual variation.

* (12-Oct-2004) Make it easier to debug+test timing sequences

  Need to generalize Tcl::Timer into something that includes a
  Scheduler interface. The usual Scheduler interface would just rely
  on Tcl_CreateTimerHandler, but we could have a DebugScheduler that
  would allow us to manually step through events.

  How to do this incrementally?

  (1-done) Just implement a Tcl::TimerScheduler, then have Tcl::Timer
	   rely on that.

  (2-done) Make a generic Util::Scheduler, and have Tcl::Timer depend
	   on that instead of the specific Tcl::TimerScheduler
	   implementation. OK, but who is going to feed the specific
	   Util::Scheduler object to Tcl::Timer? This depends on the
	   location in which we wish to inject a choice between
	   "normal" and "debug" scheduling. Is it another global
	   choice, where we just have a global "current scheduler"?
	   No, that's no good... we might want to have multiple
	   schedulers operating simultaneously (e.g. scene update
	   "normal", experiment progress in "debug" mode). So maybe
	   the scheduler is stored in ExptDriver, and passed along the
	   Element object hieararchy? Does that move ExptDriver too
	   much in the direction of a God class?

	   Essentially Util::Scheduler is doing the "Abstract Factory"
	   pattern, where it creates Util::TimerToken objects.

  (3-done) Now Tcl::Timer doesn't depend on Tcl, so move it elsewhere
	   (maybe down into Util?).

  (4-done) Change Tcl::TimerScheduler to hold a Tcl::Interp, to which
	   it can direct background errors; this way we don't need
	   Tcl::Main::interp() in Tcl::Timer. Maybe we get this by
	   having Tcl::Interp itself create the Tcl::TimerScheduler,
	   i.e. interp.getScheduler().

  (5-done) OK, now we have all the smarts in Util::Timer, but we still
	   have a Tcl::Timer class whose only purpose is to hook up a
	   Util::Timer object with a Tcl::TimerScheduler. Need to move
	   this logic elsewhere. First, need to get clients to rely on
	   Util::Timer instead of Tcl::Timer.

           Who uses Tcl::Timer?

           --> GxScene
           --> TrialEvent

           OK, now those guys just use a Util::Timer and do their own
           hooking up with a Tcl::TimerScheduler.

  (6-done) Hmmm... right now Util::Timer holds a
	   shared_ptr<Scheduler>, but only uses it in
	   Util::Timer::schedule(). Should we instead pass the
	   Scheduler object to schedule()?

           Just going by names, it seems like TimingHdlr should be the
           one to hold the Scheduler object, since that would also be
           the logical point of customization for the scheduling
           algorithm.

* (12-Oct-2004) sift through src/util

  move some stuff into rutz:: namespace and de-camel-case

  the idea that (rutz) is more fundamental than (Util) -- rutz would
  become the new zero-dependency library

  Probably for backward-compatibility and cvs sanity it would be best
  to keep all the rutz:: stuff in src/util, and then rename the Util::
  stuff to a new namespace and move it to a new src/ directory -- this
  is because there are multiple projects depending on src/util
  (classmodel and hmax), but only groovx depends on the Util:: stuff.

  OK, all the rutz stuff is now moved to the right namespace.

  [rutz] algo
  [rutz] arrays
  [rutz] arrayvalue
  [rutz] assocarray
  [rutz] backtrace
  [rutz] base64
  [rutz] bytearray
  [rutz] cstrstream
  [rutz] debug
  [rutz] demangle
  [rutz] demangle_cxxfilt
  [rutz] demangle_gcc_v2
  [rutz] demangle_gcc_v3
  [rutz] error
  [rutz] factory
  [rutz] fileposition
  [rutz] freelist
  [rutz] functors
  [rutz] gzstreambuf
  [rutz] iter
  [rutz] mappedfile
  [rutz] multivalue
  [rutz] pipe
  [rutz] pointers
  [rutz] rand
  [rutz] serialport
  [rutz] staticstack
  [rutz] stderror
  [rutz] stdiobuf
  [rutz] stopwatch
  [rutz] strings
  [rutz] time
  [rutz] trace
  [rutz] tracer (rename to rutz::toggle?)
  [rutz] traits
  [rutz] value

* (12-Oct-2004, done 18-Oct-2004) sift through src/util

  How to rename Util::? Ark. Cog. Cue. Gel. Hub. Ion. Rho. Rio.
  Aloe. Onyx. Nub. Opal. Opus.

  [Nub] log (depends on Object)     Nub::Log::log()
  [Nub] objdb                       Nub::ObjDb
  [Nub] object                      Nub::Object
  [Nub] objfactory                  Nub::ObjFactory
  [Nub] objmgr                      Nub::ObjMgr
  [Nub] ref                         Nub::Ref, Nub::SoftRef
  [Nub] refcounted                  Nub::RefCounted
  [Nub] scheduler                   Nub::Scheduler
  [Nub] signal (depends on object)  Nub::Signal
  [Nub] timer (depends on signal)   Nub::Timer
  [Nub] uid                         Nub::UID
  [Nub] volatileobject              Nub::VolatileObject

  OK, moved all this stuff into a new src/nub/ subdirectory.


* (18-Oct-2004, done 20-Oct-2004) sift through src/gfx and src/gx

  [geom] src/geom/bezier
  [geom] src/geom/bezier4
  [geom] src/geom/box
  [geom] src/geom/geom
  [geom] src/geom/rect
  [geom] src/geom/txform
  [geom] src/geom/vec2
  [geom] src/geom/vec3

  [media] src/gx/bmapdata   (depends on rutz and geom)
  [media] src/gx/imgfile    (depends on rutz and geom; XXX also Nub::log)
  [media] src/gx/jpegparser (depends on rutz and geom)
  [media] src/gx/pngparser  (depends on rutz and geom)
  [media] src/gx/pnmparser  (depends on rutz and geom)

  gb:
  src/gfx/gbcolor
  src/gfx/gbvec
  src/gfx/rgbacolor (used in Canvas, GbColor, GxBounds, Toglet)

  gxnode:
  src/gfx/gxnode
    src/gfx/gxbin
      src/gfx/gxaligner
      src/gfx/gxbounds
      src/gfx/gxcache
      src/gfx/gxscaler
    src/gfx/gxshapekit
      src/gfx/gxpixmap
      src/gfx/gxtext
    src/gfx/gxcamera
    src/gfx/gxcolor
    src/gfx/gxcylinder
    src/gfx/gxdisk
    src/gfx/gxdrawstyle
    src/gfx/gxemptynode
    src/gfx/gxlighting
    src/gfx/gxline
    src/gfx/gxmaterial
    src/gfx/gxpointset
    src/gfx/gxseparator
    src/gfx/gxsphere
    src/gfx/gxtransform
  src/gfx/gxtcl

  canvas:
  src/gfx/bbox (depends on Canvas)
  src/gfx/canvas
    src/gfx/glcanvas
    src/gfx/pscanvas
  src/gfx/glwindowinterface (depends on Tk in header)
    src/gfx/aglwrapper
    src/gfx/glxwrapper
  src/gfx/glxopts
  src/gfx/gxfont
    src/gfx/gxrasterfont
      src/gfx/aglrasterfont
      src/gfx/glxrasterfont
    src/gfx/gxvectorfont
  src/gfx/toglet (depends on Tk stuff)
  src/gfx/toglettcl
  src/gfx/linestrip (depends on Canvas)
  src/gfx/xbmaprenderer (dead code, should go in glcanvas or glxwrapper)

  src/gfx/gxscene

  src/gfx/pointtcl
  src/gfx/recttcl

* (done 20-Oct-2004) move sound stuff into src/media/

* (23-Oct-2004) fix problem with invalid rect in Tlist::createPreview

  e.g. set f [newarr Face 25]
  set p [Tlist::createPreview $f {-1.5 1.5 -1.5 1.5}]
  see $p

  OK... this invalid rect caused bogus arithmetic in
  doCreatePreview(), causing us to try glScale()'ing with a singular
  scale factor. Fixed that problem with arg-checking; now trying to
  robustify geom::rect.

* (13-Oct-2004) try to minimize global data masquerading as singletons

** (done 25-Oct-2004) Gfx::Canvas  (from Gfx::Canvas::current())
   OK, fixed most of the cases, and in the others, passed the buck on
   to Toglet::getCurrent().

   [x] used in GxScaler::setWidth (passed to getBoundingBox())
   [x] used in GxScaler::setHeight (passed to getBoundingBox())
   [x] used in GxScaler::scaledWidth (passed to getBoundingBox())
   [x] used in GxScaler::scaledHeight (passed to getBoundingBox())

   [x] used in GxPixmap::grabScreenRect (passed to grabPixels())
   [x] used in GxPixmap::grabScreen (passed to getScreenViewport())
   [x] used in GxPixmap::grabWorldRect (passed to screenFromWorld())

   [x] used in gxtcl.cc::boundingBox (passed to GxNode::getBoundingBox())
   [x] used in gltcl.cc::checkGL (passed to throwIfError())
   [x] used in gltcl.cc::loadMatrix (passed to throwIfError())
   [x] used in gltcl.cc::pixelCheckSum (passed to grabPixels())
   [x] used in TlistUtils::createPreview (passed to doCreatePreview())
       called from pkg->def (tlisttcl.cc)

* (25-Oct-2004, done 26-Oct-2004) fix problem with rasterPos()
  This required a lengthy series of changes to make things more
  robust... ultimately we need to watch out for rounding problems and
  floating-point inaccuracies when converting between screen and world
  coordinates.

* (26-Oct-2004, done 27-Oct-2004) fix rasterPos() for 3-D

* 2005 STARTS HERE

* (2005-03-17, not-a-bug) Bugs with GLCanvas.

  this shows the gabor patch correctly positioned, but the bounding
  box is drawn in the wrong location:

  set g [new Gabor]
  -> $g resolution 256
  -> $g alignmentMode $GxShapeKit::CENTER_ON_CENTER
  -> $g bbVisibility 1
  see $g

  Turns out this was a bug in the nvidia driver that was fixed by
  upgrading from version 6629 to 7167.
