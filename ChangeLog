* -*- outline -*-

* ChangeLog file
  $Id$

* Rob Peters <rjpeters@klab.caltech.edu>


* (done 25-Jan-2002) Logging
OK, have a simple scope nesting and timing architecture in place for
logging.

* (done 17-Jan-2002) More efficient bitmaps
Improve (startup time, memory use) for eyetracking stimulus scripts?
Things are speedier with queuePbmFile(), so that bitmaps are only loaded
when needed, and with purgeable bitmaps, so that the memory is freed
immediately after the bitmap is drawn. This is a reasonable tradeoff if
each image is going to be displayed relatively few times compared to the
overall number of images used.

* (done 28-Jan-2002) decode responses by a Tcl 'proc'
Implemented a first attempt at allowing responses to be decoded by a
"proc"-like Tcl code block, rather than by a regular expression
mapping. Eventually the old regex approach can probably be encapsulated
within the new more flexible approach.

* (done 28-Jan-2002) multiple responses within a single Trial run
OK, added a "maxResponses" attribute to EventResponseHdlr so that we can
specify an arbitrary number of responses (instead of the default, 1) to be
allowed in each activation cycle, before the response handler goes quiet.

* (28-Jan-2002, done 30-Jan-2002) generic Tcl code wrapper
Would be nice to have a reusable class that can wrap a Tcl procedure that
can be serialized and deserialized. We are already doing this in practice
in ExptDriver (with the doUponCompletion script) and in EventResponseHdlr
(with the responseProc). Should be able to refactor out the common
code. OK, I extracted TclProcWrapper from EventResponseHdlr's former
ResponseProc class, and made it an IO::IoObject (all this after much
painful debugging that was eventually solved by Electric Fence). Next step
is to extract it physically, and then re-use it in ExptDrvier. This should
eventually be a very useful and powerful class -- it's a nice interface to
provide extensible hooks + callbacks. [30-Jan] OK, extracted out
Tcl::ProcWrapper and put it into place in ExptDriver. This is looking like
a nice powerful tool now.

* (24-Aug-2001, done 31-Jan-2002) infix member function calls in Tcl
So we can do "$f eyeHeight 0.4" rather than "Face::eyeHeight $f 0.4". I
don't think I'll have a problem getting the mechanics of the function calls
set up... but the problem is, how to get Tcl commands registered for all of
the objects? Or just resort to using "unknown"? Or... just set up
inheritance, so that for example, the "Face" namespace in Tcl inherits all
the commands in "GrObj", "GxNode", and "IO", for example. [3-Sep-2001]
Hmmm, no, the real problem is not how to get Tcl commands registered (this
could be done in the Convert::toTcl functions), but rather how to allow
easy vectorization of commands?  Maybe all my OO stuff could go under a Tcl
cmd "with", so we can do "with $f eyeHeight 0.4", which would work whether
$f was single- or multi-valued. [31-Jan-2001] Could get working notation
using namespace eval in a special oo command, perhaps named "->". Need to
provide a way for Tcl::Pkg's to inherit() the functions in other
packages. The idea would be that a Pkg would first inherit() all the
necessary functions, then it would define its own functions. That way in
case of a name conflict, the new function would overwrite ("hide") the
inherited function. We could still access the overwritten function with an
explicit qualification. Done -- added a "->" command that provides infix
syntax. Inheritance is managed through namespace importing/exporting via
Tcl::Pkg::inherit().

* (31-Jan-2002, done 1-Feb-2002) Add fstring operator!=().

* (30-Jan-2002, done 2-Feb-2002) Segfault on "? new".
Fixed: Re-fixed the local function lookupCmd(), so that it won't crash if
it is passed a command name that refers to a non-Tcl::Command command (such
as a tcl proc). Apparently my idiom of dynamic_cast<>(static_cast<>()) was
not sufficient to test whether we actually had a valid Tcl::Command*;
instead I now just manage a std::set<void*> holding the addresses of valid
Tcl::Command's.

* (23-Feb-2002, done 23-Feb-2002) shared libraries on OS X?

  with SHLIB_CMD := cc -dynamiclib -flat_namespace -undefined suppress -o
    --> libraries build ok
    --> executable links ok
    --> executable fails at startup due to undefined c++ iostream symbols
    --> adding -lcc_dynamic to each of the link commands doesn't help

  Aha! need to use "c++" instead of "cc", with -lcc_dynamic, so we have:
    c++ -dynamiclib -flat_namespace -undefined suppress -o {name} -lcc_dynamic

* (23-Sep-2000, nix 14-June-2002) log-file?
Should have a log-file that can catch non-essential messages (such as the
timing info that is emitted by TrialEvent destructors). [nix
this... logging is now improved somewhat with Util::log]

* (14-Jun-2002, done 17-Jun-2002) Fix dynamic loading
so that we don't have to link in matlab stuff to the main executable, but
just to the mtx package.

Get this bogus crap:

[hume 16:52 52]% testsh
(1) testsh> package require Mtx
couldn't load file "/cit/rjpeters/local/i686/lib/visx/mtx.so":
 /usr/local/matlab/extern/lib/glnx86/libut.so: undefined symbol: _start

Aha. Have to use the linker option --export-dynamic, so that libut.so can
find the _start symbol which is of course defined next to wherever main()
is defined, which would be in the executable itself.

* (note 2-Jul-2002) OS X porting note: -install_name with ld
Ran into problems with tk8.4a4; specifically, got "could not find dynamic
library libtk8.4a4.dylib" at runtime when trying to run testsh. The problem
was in the Tk makefile, which failed to set the -install_name option when
ld'ing the dylib.

* (16-Aug-2001, done 5-July-2002) Bounding boxes for all GxNode objects?
How do we allow a Position, for example, to return/transform a
bounding box? ... OK, the GxNode function takes a Rect reference, so
that subclasses can either transform or extend that Rect.

[Later] OK, this was done by having all of the bounding box calculations
take place actually with 3-D bounding cubes... that allows us to properly
account for the effects of arbitrary coordinate transformations. Only at
the final stage do we extract a 2-D screen-aligned bounding "box" from the
cube.

* (21-Jun-1999, done 26-Sep-2002) GL coordinates <--> visual angle
This is basically already in place with Togl::setViewingDistance
and Togl::setUnitAngle.

* (May-1999, nix 26-Sep-2002) Implement GLenums without STL maps
Probably best to use Tcl_Index API's, to search for matching string in
array, and retrieve its index. [Later] This issue is mostly moot now, since
the problems with STL maps was just an issue of long compiles on old HP
machines, but is not a significant problem now with linux/gcc.

* (5-Oct-1999, ok 26-Sep-2002) TimingHdlr response behavior?
Maybe TimingHdlr should have a toggle switch to indicate
what the behavior should be when a response is seen. (Whether to
cancel StartEvents, etc.). [Later] I think we have a decent heuristic in
place here now: namely, if the response-queue is non-empty, then we cancel
the start events and schedule the response events, otherwise we do nothing.

* (14-Dec-1999, ok 26-Sep-2002) Need Canvas& argument to GrObj::grGetBoundingBox
OK, this stuff has been in place for a while now.

* (1-Nov-2002, done 4-Nov-2002) Get all Value-subclasses to be Tcl::Convert'ed

Maybe need to use function overloading instead of partial specialization?
Function overloading is more flexible, allowing subclasses to be passed via
reference-to-base-class.

Strategy: First add a set of template functions that just forward to the
current Tcl::Convert functions. Then, hid the old template functions to
force all clients to use the new interface. Then, gradually add overloads
of the new template functions. Eventually, none of the old specializations
will be needed, and then they can be phased out.

** Best names for functions?

   fromTcl()/toTcl() ?
   toNative()/fromNative() ?
   export()/import() ?

** How to specialize fromTcl() for Value types?

   The problem is that we can't return by value (no pun), but need to
   return through a reference, since we don't know in advance what type of
   Value object we're going to be dealing with. Would like to specify
   somehow that "all Value objects should be gotten from Tcl by assigning
   to them through an fstring". Aha... just needed a bit of template
   metaprogramming a la "Loki" here.

* (4-Nov-2002, done 5-Nov-2002) Dynamically-sized array-Value objects?
  OK, TArrayValue<T> fits the bill here, holding a minivec<T>.

* (9-Nov-2002, done 13-Nov-2002) GLUtil just has font functions
  Make a new font class? Or move this stuff into Gtext? Yes, yes, yes. OK,
  GLUtil is history. We have a GxFont class now, with raster-font and
  vector-font implementations, which is used by Gtext.

* (13-Nov-2002, done 20-Nov-2002) Cleanup GrObj once and for all
  OK, replaced Gnode with GxBin. Changed all of the Gnode subclasses into
  generic Gx* node subclasses. So now I feel better; all the stuff is
  generic. In principle GrObj could become a Gx* class now itself.

* (done 20-Nov-2002) Rename GrObj --> GxShapeKit

* (done 20-Nov-2002) Rename Position --> GxTransform

* (9-Nov-2002, done 20-Nov-2002) X11Util just has findColormap()
  Moved this back into Togl.
   GxText

* (done 20-Nov-2002) Merge GlxWrapper and GLCanvas functionality.

  [ok] Move glxwrapper.* and glxattribs.* and glxopts.* into src/gfx/.

  [ok] Rather than GlxWrapper owning a GLCanvas, it should be the other way
  around. Togl should own a GLCanvas then instead of a GlxWrapper.

  [ok] Tcl interface to GL should go through GLCanvas instead of Togl
  (i.e. functions like isRgba and isDoubleBuffered).

  [ok] Ultimately the only purpose of Togl should be to bind a GLCanvas to a
  "physical" X window.

* (done 21-Nov-2002) Put X11-rendering into GLCanvas.

* (done 21-Nov-2002) Get rid of GLBitmap/XBitmap
  OK, these are merged into bitmaptcl.cc... that's probably as far as I can
  go for now, since I still need at least a shell of class definitions for
  GLBitmap/XBitmap in order to be able to read old expt files.

* (done 21-Nov-2002) Rename Bitmap --> GxPixmap

* (done 21-Nov-2002) Rename Gtext --> GxText

* (done 21-Nov-2002) Merge Togl into Toglet
  visx/tkwidget --> gwt/tkwidget
  visx/toglet + togl/togl --> gwt/toglet

* (28-Nov-2000, OK 21-Nov-2002) GxShape base for GxLine, GxRect, GxDisk, etc.
  Looks like we've pretty much met the goal behind this one.

* (13-Sep-1999, done 22-Nov-2002) Refactor Toglet into Widget, Camera, Canvas

** (27-Nov-1999, done 22-Nov-2002) Widget class has a Camera and a Canvas
   Or does the Camera need to contain the Canvas? It seems like the Window
   will pass a redraw request on to its Camera, which would need to have a
   Canvas reference to pass to the graphic objects in order for them to
   redraw themselves. [22-Nov-2002] Cool. Finally got this exactly how it
   should be as above: we have GWT::Widget which has a canvas (via a
   virtual function which is implemented by Toglet) and holds a single
   drawable object (the "scene") and a single camera.

** (17-Nov-1999, done 22-Nov-2002) The Camera abstraction
   includes some of the Toglet functionality such as perspective or
   orthographic projection, viewing distance, viewport, and which will be
   used by a Window/Widget to handle redraws and reconfigures. A subclass
   of Camera can carry the Tlist functionality such as setVisible(),
   setCurTrial(), etc. Actually, it seems there are two different parts to
   camera: one is the object/scene that it is viewing, and the other
   defines the sort of projection that is used. [Later] Pfft... camera
   doesn't need to know anything about the object/scene it is viewing; all
   it needs to do is set up the viewport and projection matrix.

** (13-Sep-1999, done 22-Nov-2002) Change Toglet to a "Camera"-style interface
   a la Open Inventor. Then different types of camera's, such as
   orthographic or perspective projection, could be related by inheritance
   from an abstract base class Camera. Parameters include viewing volume,
   autoUpdate (determines if scene is automatically redrawn upon Expose or
   Resize events)... [Later] OK, now I have GxCamera, GxFixedScaleCamera,
   GxPerspectiveCamera, and GxPsyphyCamera, among others.

* (16-May-2000, nix 22-Nov-2002) Make bitmap caching more fluent

  Need to have a way to explicitly represent GrObj's with
  cached-bitmap-file representations... this way we can have access both to
  a GrObj's semantic properties (i.e. face width, nose length, etc.)  while
  still accessing it in a bitmap form. This would involve a command to
  cache a GrObj to file, given a filename, and then the object should
  automatically load that file when it is deserialized at a later time.

  [Later] OK, as of now it really looks like bitmap caching is not going to
  be much of an issue. It was mainly needed on really old+slow hp machines
  whose OpenGL implementations ran like molasses.

* (28-Sep-2000, nix 22-Nov-2002) irix core dump
  Why does irix occasionally core-dump during Face testing in
  GrObj::invalidateCaches()? [Later] Who knows? Who cares?

* (14-Dec-1999, nix 22-Nov-2002) Bitmap::grab{Screen,World}Rect needs a Canvas&?
  [Later] OK, this one sounds totally out of date.

* (3-Sep-2001, done 22-Nov-2002) class-based inheritance of Tcl commands
  We don't need multiple TclCmd objects, instead we just need to register
  the same TclCmd object under multiple names. [Later] OK, we can basically
  achieve this kind of inheritance by just making use of Tcl's ability to
  import/export commands from namespaces.

* (done 22-Nov-2002) Merge Tcl::PkgBase and Tcl::Pkg again?

  Actually, the stuff in tclpkg.h now should go to a new "objpkg.h".
  And I'll leave Tcl::Pkg in place since it introduces a lot of #include
  overhead beyond Tcl::PkgBase, so it's nice to keep that isolated.

* (22-Aug-2001, done 25-Nov-2002) Allow args in the Signal/Slot callbacks
  e.g. for event handlers

  Now I've got SlotBase <-- Slot0 <-- SlotAdapter0.

  But instead of Slot0 <-- SlotAdapter0, should just have the Slot0 class
  hold an appropriate Util::Functor.

  OK, multi-arg Slot+Signal is off the ground now. Still might want to use
  Util::Functor there at some point.

* (done 23-Nov-2002) Rework GWT::Widget

  Need to rework the Widget inheritance hierarchy. Right now we have a
  bloated base class in GWT::Widget. That class should become much more
  lightweight and not have any Tk- or GL-specific stuff in it.

  Most of GWT::Widget should be like a "Gfx::Scene class", which should be
  similar to a GxNode.

  Clients that need the "Scene" interface shouldn't have to know that
  they're dealing with a Widget/TkWidget/Toglet... so right now that's why
  we have "Scene" functionality in the Widget base class. But that doesn't
  really make sense because not all Widgets should be Scenes.

  GWT::Widget's implementation has basically two parts: (1) stuff for Scene
  management, and (2) lists of Listeners. The Listeners should stay since
  those belong in a generic widget interface.

  For now we should just "tell it like it is", and move all the GL-related
  stuff into Toglet. Expt/Block/Trial should then deal with Toglet instead
  of GWT::Widget, since they're implicitly requiring that right now
  anyway. That gives us a starting point for refactoring.

* (24-May-2001, obsolete 25-Nov-2002 ) Maybe Togl should be a canvas

  or we should have a ToglCanvas, so that swapBuffers() can go in Canvas,
  where it seems to belong, rather than in Widget, where it sits now
  (basically to allow Toglet to implement swapBuffers by calling Togl
  something).

* (16-Mar-2000, obsolete 5-Dec-2002) what happens on Block::abortTrial()?
  Block should have a parameter (or virtual function) to control what
  happens on abortTrial()... i.e., should we reschedule the trial, ignore
  the trial, record an invalid response? [Later] OK, this responsibility is
  now in Trial itself, where it belongs, using the ChildStatus (CHILD_OK,
  CHILD_ABORTED, CHILD_REPEAT) parameter to vxNext().

* (20-Jan-2000, obsolete 5-Dec-2002) a Trial::prepare() function?
  We should set up a way for Trial's to have a prepare() function which
  would do things like update its GrObj's (and flush pending requests like
  loading bitmap data). Then Block's could have a prepareNextTrial()
  function which could be called during the preceding trial. [Later] Hmmm,
  if I ever were going to implement this, it would be better done
  generically with in implementation of idle callbacks.
