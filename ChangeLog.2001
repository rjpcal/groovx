###################### -*- text -*- ######################################
#
# ChangeLog 2001
# 
# Rob Peters <rjpeters at klab dot caltech dot edu>
#
# $Id$
#
#############################################3############################

(9-Dec-2000, done 17-May-2001) IoDb does not need to be an IoObject
anymore; instead, it should provide functionality for reading+writing
object archives. The IoDb package should not have
stringify/destringify or read/write.

+-----
|
| (4-Dec-2000, done 18-May-2001) Need to prevent resource leaks by
| making newIO() return a PtrHandle<IO::IoObject>. This will require
| Reader::readObject() to return a PtrHandle as well, and require Reader
| implementations to use PtrHandle's internally. Hmmm... need to make
| real sure that there is no way to create more than one PtrHandle for a
| given IoObject... oops, duh! I already have avoided this problem by
| making RefCount a base class of IoObject, so we can actually make
| multiple PtrHandle's without a problem. The way to get at this is to
| change the static make() functions to return a PtrHandle. Then
| CreatorFromFunc will store the appropriate type of function pointer,
| and its create() method will return a PtrHandle<Base>. The main
| drawback here is that we greatly increase the dependence on
| PtrHandle... Then again, this is probably a good thing, as it reduces
| the use of raw pointers.
| 
| (done) change users of newIO() and make() to instantiate a PtrHandle
| rather than a raw pointer
| 
| (done) newIO() to return a PtrHandle
| 
| (done) change Factory to return IdItem's
|
+-----

(19-Jan-2000, done 18-May-2001) GLBitmap should use auto_ptr for
itsRenderer and fix initialization order (eliminate
tempRenderer). Same for XBitmap.

(8-Jul-1999, done 18-May-2001) Idea: have TclCmd's be able to return
doc strings; then TclCmd or TclPkg would store a list of all
registered commands, so that a special help command (like '?')
followed by a command name could return its help string. This would be
nice since the various intermediate command classes could provide
default doc-strings. Subclasses could either append, or override,
their superclass's doc-string.

(19-May-2001, done 19-May-2001) IoProxy should still store its
referand's as IdItem's. IdItem's no longer need to do IoDb insertion.

(16-May-2001, done 19-May-2001) Don't need IoMap; instead, IoObject's
should just insert themselves into the IoDb automatically upon
construction. Hmmm... the problem here is that this won't work for
IoObject's that are constructed on the stack (such as IoProxy's). So
do we somehow forbid any subclasses from being instantiated on the
stack? Or just give up on automatic IoDb insertion? And the answer
is... we can prohibit IoObject's from being instantiated on the stack
at runtime, by Assert'ing in RefCounted's destructor that the
ref-counts are zero. And we can allow subclasses (such as IoProxy) to
choose not to be automatically inserted in the IoDb, by the addition
of a "doInsert" argument to the IoObject constructor that defaults to
true.

(29-Oct-2000, done 27-May-2001) Add a template CastingIterator to
IoPtrList that "sees" only objects of the template type. This can be a
simple wrapper around the plain Iterator, needing to override
operator++ and operator*(), and adding getTypedObject().

+-----
|
| (27-May-2001) Split IoObject into two parts: (1) defines the concept
| of having a UID which can be used to communicate about C++ objects
| with Tcl, and (2) the actual concept of being serializable. Some
| classes would benefit from (1) (such as Canvas/Widget) but would not
| need (2). Part (1) would probably move into the Util package.
| 
| OK, for better or worse I made a mother-of-all-base-classes
| Util::Object, which inherits from RefCounted and provides the UID
| functionality.
| 
| (6-June-2001) The rest of this refactoring is now done, as
| IO::IoFactory has gone to Util::ObjFactory, IO::IoMgr to Util::ObjMgr,
| and IoDb now stores Util::Object*'s. IdItem is also moved to util/.
|
+-----

(3-Jul-1999, 7-Jun-2001) Need to correctly handle widget destruction
within the ObjTogl package. The problem is that if a new Togl widget
is created and then destroyed, the "offical" Togl widget (the
singleton) is no longer the current glX rendering context... perhaps
there should be a line in both the create and destroy callbacks that
resets the "official" widget as the glX-current context. [Later] This
is handled now in Toglet::currentToglet Tcl command.

+-----
|
| (12-Jun-2001, done 13-Jun-2001) Can we get weak references going? This
| would solve the problem of the disappearing Togl widget. My idea:
| 
|   (done) get rid of PtrHandle and NullablePtrHandle; these are
| 			basically used only in Ref and MaybeRef
| 
|   (done) Add a virtual function isVolatile() to RefCounted... this
| 			defaults to returning false, but classes like Toglet can
| 			override to return true.
| 
|   (done) Don't allow strong ref's to be made upon volatile objects.
| 
|   (done) Add a WeakRef class in parallel with Ref and MaybeRef. Or
| 			perhaps MaybeRef can be merged into WeakRef, so that the new
| 			class allows a null pointee, and will take a weak ref if a
| 			strong ref is not available.
|
+-----

+-----
|
| (4-Jun-2001, done 15-Jun-2001) Should ditch the idea of singleton Expt
| and Togl objects... things would be easier without them.
| 
| (done 6-Jun-2001) ExptDriver should own a GWT::Widget.
| 
| (done 6-Jun-2001) OK, now I've renamed ToglConfig to Toglet, and
| generally rearranged things so that we can have multiple Toglet's in
| existence at once.
| 
| (done 6-Jun-2001) Hmm... there's is a bit of a problem with Togl,
| since we can't totally control the lifetime with ref-counting, since
| the widget can be destroyed at any time by closing the app's
| window. For now I can decouple the lifetime of the Toglet from the
| lifetime of the actual X Window... window creation could still be done
| with a Togl::init, and when the X Window is destroyed, we call back to
| Toglet to let it set itsTogl* to 0.
| 
| (done 11-Jun-2001) Removed the global dependence on a singleton
| experiment by removing Application::getExperiment() (although it was
| replaced by Application::getCanvas(), mostly for the benefit of
| Bitmap's who need access to a Canvas to do screen/world translation).
|
+-----

(6-Jun-2001, done 15-Jun-2001) Allow name aliasing in Factory? This
would help to allow backward compatibility for the serialization
system...

(28-Mar-2000, done 15-Jun-2001) The Togl widget can take over its own
event dispatching by calling Tk_CreateEventHandler; then we can add
event bindings to the widget using C++ only, without having to use Tcl
script code.

+-----
|
| 
| (9-Jul-2001) Big issue: finding a workable computing environment to
| get going with new models. Main question: which high-level language(s)
| to use?
| 
| Choices:
| 
|   Tcl:
| 
|     + I already have a lot of time invested here, and a good framework
| 		for interfacing Tcl with C++.
| 
| 	 - poor support for numerics -- I could implement my own objects,
| 		but even then the syntax is very clumsy (no infix operaters, no
| 		slices, etc.)
| 
| 	 - unfamiliar interface for visualization
| 
|   Matlab:
| 
|     + Good visualization tools
| 
| 	 + Huge numerical library already available
| 
| 	 - Slow
| 
| 	 - Programming language lacks facilities for modularity
| 
| 	 - Clunky C-interface
| 
|   Python:
| 
|     + Dynamic object-oriented language
| 
| 	 + Excellent facilities for modular programming
| 
| 	 - Unfamiliar C-interface (but C++ interface is in boost::python)
| 
| 	 + NumPy package
| 
| 	 - May not work as an experiment scripter (no event loop)
| 
| 
| (done 10-Jul-2001) OK, I have a plan! I tried using the MATLAB engine
| API, and found it was very easy to set up an embedded MATLAB engine in
| Tcl, so that we can exchange arrays with the MATLAB workspace, and can
| run arbitrary MATLAB commands in the engine (including visualization,
| etc.).
| 
| So, for now, I can keep using the Tcl interface as I have been, and
| now introduce the classification models there.
| 
| In the future, I can switch over to Python/C++/MATLAB, but this is not
| urgent now.
| 
|
+-----

(10-Jul-2001, done 11-Jul-2001) Refactor all the Tcl_Obj* conversions:
we should have one set of template free functions
Tcl::getValFromObj<>, which do not require a Tcl_Interp*. These can be
used in TclCmd and in TclValue. Then TclValue will not need a
Tcl_Interp*.

(4-Jun-2001, done 11-Jul-2001) Could have a CmdContext class that
represents the arguments and return value of a Tcl command invocation,
and change the interface of TclCmd::invoke() to
TcmCmd::invoke(CmdInvocation& inv). Right now the CmdInvocation stuff
is just rolled right into TclCmd.

(10-Jul-2001, done 12-Jul-2001) Implement VecCmd.

(27-Jun-1999, done 13-Jul-2001) could perhaps use TclCmd again in
KbdResponseHandler to wrap up the event binding... this would allow
for exceptions during the event handling.

(2-Nov-2000, done 16-Jul-2001) Can replace void*'s in tclitempkg.h
with something safer?  [16-Jul-2001] Yes... finally this is done, with
all-generic functor approach to building TclCmd's.

(24-May-2001, done 16-Jul-2001) Should enable objects to be passed
to/from Tcl by specializing declareGetter(), declareSetter(), etc., so
that IdItem's are converted to/from IO::UID's as necessary. OK, this
was done with partial specializations of CGetter and CSetter. But,
now, is there some way to unify this mechanism with the one that
extracts the object from the first argument of Tcl commands?
[16-Jul-2001] OK, this is done now with specializations of the static
functions in the Tcl::Convert<> template.

(15-Jul-2001, done 18-Jul-2001) Who still uses addCommand? ... after a
bunch of whittling, I've got it down to just TclItemPkg... so now, we
can make addCommand() protected in TclPkg. Then, all public clients
can just use TclItemPkg, so we can rename TclPkg to Tcl::PkgBase, and
rename TclItemPkg to Tcl::Pkg.

(17-Jan-2000, done 18-Jul-2001) We should have a TclVecItemCmd<C>
template that parallels TclItemCmd<C> but can handle vectors of
items. Mainly it would need a getItems() member that returns a
reference to a vector<C*>. ... no, better would be to have getItems()
take an insert iterator. Actually, there ought to be some way to get
the base class to take care of most of the iteration, so that the
subclasses just need to define what to do for each element. This would
be similar to the way VecSetterBaseCmd provides a partial
implementation for TVecSetterCmd. [Later] This need is taken care of
with the new template-functor approach to Tcl commands.

(10-Nov-1999, done 18-Jul-2001) Had an idea for allowing TclCmd's to
be more generic... define abstract classes of extractors, which
provide ways to get C++ types out of Tcl_Obj*'s. The native types
would be straightforward, but more interesting would be to define
extractors for STL containers... actually, would this give me anything
more than I have now with the various getXxxFromArg() methods in
TclCmd? Answer: Yes -- it would provide a bit more modularity, since
the extractors would be separate from the commands, and new extractors
could be introduced without having to add a method to TclCmd by
subclassing it. [Later] Interesting... this is just about exactly what
I have implemented with the Tcl::Convert<>::toTcl() and
Tcl::Convert<>::fromTcl() functions, which work along with a
Tcl::Context to set up a command invocation.

(18-Jul-2001, done 18-Jul-2001) GrObjImpl is a mess because we don't
always have a bounding box... why not split off a base class of GrObj
which doesn't require a bounding box, so that the implementation of
GrObj can be more demanding and require a bounding box.

(5-Oct-2000, done 20-Jul-2001) Add zstream to Pbm.

(21-Jul-2001, done 6-Aug-2001) Clean up Trial by getting rid of
GxSeparator's there. Get rid of add(). Then itsGxNodes can be actually
GxNode's and not GxSeparator's.

(done 8-Aug-2001) Rename fixed_string to fstring or dstring.

(done 8-Aug-2001) Make Error hold a fixed_string by value.

(8-Aug-2001, done 9-Aug-2001) Dump Error template constructors and
template append()'s.

(8-Aug-2001, done 9-Aug-2001) Dump string_literal.

(19-Jan-2000, done Jul-2001) Does BitmapRep really need to implement
grUnRender(), or can we just use GrObj's GROBJ_CLEAR_BOUNDING_BOX
mode? ... the latter.

(10-Aug-2001, done 10-Aug-2001) GrObj:

-- make GLCacheNode (extract it out of GrObjRenderer), and put it on
	top of the GrObjNode

	this will handle GLCOMPILE, SWAP_FORE_BACK and CLEAR_BOUNDING_BOX

-- make BitmapCache (what is left of GrObjRenderer), and put it on top
   of the hierarchy

	this will handle GL_BITMAP_CACHE and X11_BITMAP_CACHE

(14-Aug-2001, done 15-Aug-2001) Migration path for Field:

-- make Field class unnecessary (or at least trivial)

-- real functionality should go into FieldContainer, FieldInfo, and
   FieldMemberPtr

(done 15-Aug-2001) Rename FieldInfo to Field.

(8-Oct-1999, 15-Aug-2001) GrObj should use Property's, so that GrObj
attributes can be added to the list of a subclass's
attributes. [Later] OK, made GrObj a FieldContainer.

(5-Jun-2001, done 20-Aug-2001) Use a virtual iterator w/
envelope/letter pattern for my custom iterators that wrap STL
iterators (such as IoDb::Iterator).  [Later] This would come in quite
handy in allowing read/write sequences to be virtual functions of
Reader+Writer rather than external templates in
Read/WriteUtils. [Later still] OK, implemented Util::FwdIter<>,
Util::BidirIter<>, and Util::RxsIter<>, which are all implemented as
handles to an appropriate interface. Adapters are provided which
implement these interfaces from STL-style iterators or raw pointers.

(14-Oct-1999, done 21-Aug-2001) Gabor should have a
patchWidth/patchHeight attribute, that controls not the size of the
object inside the patch, but the size of the patch itself (i.e. how
big the window onto the Gabor patch is). [Later] This is accomplished
with the resolution and pointSize fields.

(15-Oct-1999, nixed 21-Aug-2001) There's a unifying force behind two
things: 1) Tcl's idea of dual representation-- native rep/string rep;
and 2) idea of serializing objects to a stream by converting them into
a string format. I don't know exactly what to make of it at this
point, but it seems like it could be useful... This is parallel to the
duality of makeIoList and getProperties()... these should really be
merged. Dual-rep objects (perhaps a new DynamicValue subclass of
Value) could be used in the implementation of
AsciiStreamReader. [Later] Unfortunately this scheme won't work, since
in a round-trip conversion to+from string, objects lose their
identity--i.e., if we have two identical string-reps, do they refer to
the same object, or to different but identical objects?

(15-Jan-2000, done 7-Jun-2001) ExptDriver should really own the
widget... Then we can eventually have multiple Experiment's at once,
each with its own widget??? is this right? Eventually, we'd like to
have a list of Widget's, with ExptDriver maintaining the current one
for an experiment, so that experiment participants can request it from
ExptDriver (or it passes the Widget to them). [Later] OK, now we can
have multiple experiments AND multipl Toglet's.

(27-Nov-1999, obsolete 18-Jun-2001) Who uses theToglet()?
EventResponseHdlr uses the Widget part in the attend() and ignore() methods
ExptDriver uses the Canvas part it in swapBuffers().
ExptTcl uses the Widget part in BeginCmd, SetStartCommand,
ObjTogl uses the Widget Part in DestroyCmd.
ObjToglPkg uses it in getCItemFromId().
xbitmap.cc uses a special X11Widget subclass in init_class().

(27-Nov-1999, done 18-Jun-2001) One important reason for refactoring
all this Togl stuff is so that we can have more than one active Togl
widget... then we can improve user interface, e.g. bring up a dialog
box to edit a GrObj, etc.

+-----
|
| (17-Aug-2001, done 22-Aug-2001) Get rid of Util::Observer; use
| templated callbacks instead. OK, I've got Signal+Slot going now, but
| only with no-arg callbacks.
| 
| (done) Rename Observable to Signal.
| 
| (done) Rename send/receiveStateChangeMsg() to send/receiveSignal().
| 
| (done) No one should inherit from Util::Signal. Instead, they should
| be contain a Util::Signal.
| 
| (done) No one should inherit from Util::Observer.
|
+-----

(25-Jun-1999, done 22-Aug-2001) Need a coherent way of handling
colors... [Earlier] Who should own foreground/background information?
Seems like it could belong to either or both of GrObj and
Position. Maybe best idea is to use ColoredObj and ColoredPosition as
derived classes, if necessary. Default behavior of non-colored classes
would be to use whatever color was active, while colored classes would
set their own color when they do their action. Useful scenarios would
be ColoredPosition with regular GrObj, or ColoredObj with regular
Position. [Later] Maybe new subclasses aren't needed, since this would
create a dual hierarchy for all other subclasses (i.e. there would
have to be a regular FixPt and a ColoredFixPt). Part of the state of
both GrObj and Position could be whether they have a color preference;
if so, they use it, and if not, they use the current color when they
are drawn. [15-Jul] Aha! I think I've got it... there should be a
class GLAttributes that can specify things like foreground/background
color, line width, etc. and one subclass could be a null subclass that
just does nothing; a virtual method setAttribs() would arrange to set
all of the attribs controlled by the class (but how to unset them?
would be nice to use constructor/destructor via lexical scope). Then
both GrObj and Position could contain a GLAttributes member which
would control the appropriate attributes, if any. [3-Aug] What is
needed is a good abstraction to model what happens when a trial is
rendered. In particular, how to represent, say, that we should go to a
Position, then draw a GrObj, then un-go from that Position, then go to
a new Position... We need some kind of a GraphicParticipant class,
that has begin() and end() functions, that is able to capture at once
the current Position and GrObj classes, as well as the forthcoming
GlAttributes class. I guess this is the composite pattern-- which we
can use to build an arbitrarily nested list, or tree. [Later
30-Nov-2000] This will all be real slick now with GxNode/GxSeparator,
with possible subclasses GxColorIndex and GxRgbaColor. Then colors can
go into the scene graph. [Later 22-Aug-2001] OK, I've implemented
GxColor, a GxNode for rgba colors.

(12-Dec-1999, done 23-Aug-2001) Could have an abstract class for timer
callbacks, one subclass of which could use a Tcl_Interp* to register
timer callbacks. [Later] OK, now I've got Tcl::Timer, which exposes a
Util::Signal that can be connect()'ed to, by clients who want to
receive timer callbacks.

(24-Jun-2001, 2-Sep-2001) Allow other kinds of Field's besides numeric
ones: string fields, sequences, and enums. These can then be
manipulated by appropriate widgets: entries (strings), trees?
(sequences), and list boxes (enums). OK, we're on our way on this one
now; I've added various flags that can be specified for Field's,
including STRING, MULTI, TRANSIENT, NO_GET, NO_SET, NEW_GROUP; and
this architecture is extensible enough for now.

(31-Aug-2001, done 3-Sep-2001) Need to merge Value and Tcl::ObjPtr
somehow, since Tcl::ObjPtr is much more expressive. OK, I didn't merge
the two, but instead I made the whole Field system rely on
Tcl::ObjPtr's instead of Value's. This allowed for sweeping cutbacks
in the responsibilities of Value: first, we could eliminated TValue<>,
TValuePtr<>, and TclValue, and second, the Value interface was cut
back to just get/set for strings, plus printTo() and scanFrom().

(2-Dec-2000, obsolete 3-Sep-2001) Should Value be implemented using
Coplien's envelope/letter idiom? Value's could then be passed around
as stack objects, and they could contain ref-counted smart pointers to
different value implementations. The implementation would be the same
interface, but a separate inheritance hierarchy... in effect we'd
rename the current Value hierarchy to ValueType. Or... maybe we should
just be passing around shared_ptr<Value>'s, making Value a ref-counted
type.

(29-Aug-2001, done 3-Sep-2001) Hmmm... got a problem with Signal
connecting... in the Fish constructor, we try to connect "this,
updatePtrs" to a signal. But, since nobody has ref'ed "this" yet, it
appears to be a dead object to the SoftRef constructor, which then
neglects to actually form a reference. How to fix? (1) keep a flag in
RefCounts indicating if the object is live or dead, (2) make SoftRef's
less hasty to release their reference. Actually, this would be an even
worse problem if we were trying to construct strong Ref's from "this"
in a constructor, since if the Ref went out of scope before the
constructor completed, the object would be deleted
prematurely. [3-Sep-2001] OK, I added
RefCounts::releaseStrongNoDelete() and
RefCounted::decrRefCountNoDelete(), which I used to implement
Util::FloatingRef<>. FloatingRef is now in use in the Fish
constructor... seems to work OK. Still need some discipline to make
sure that FloatingRef is used where necessary... basically anywhere
that can be called from a constructor.

(3-Sep-2001, done 4-Sep-2001) A memory leak seems to have popped
up... noticeable when running the batch file conversion job,
especially with the fMRI data files. OK, fixed it -- problem was that
I wasn't disconnect()'ing in the GrObjBBox dtor from the Signal that
was connect()'ed to in the ctor. Will try to get a Connection object
set up to manage these things properly.

(3-Sep-2001, done 4-Sep-2001) Change GrObj I/O to use the FieldMap.

(3-Sep-2001, done 4-Sep-2001) Eliminate GrObj unrender mode.

(4-Sep-2001, done 4-Sep-2001) I've semi-broken GrObjScaler along the
way of changing GrObj IO to use width/height rather than
widthFactor/heightFactor.  Need to roll back those changes and start
again.

  ---> put the old asw files back in place

  ---> roll back GrObj scaler

  ---> reconvert the asw files to strip the "GrObj::" prefixes

  ---> implement Field::PRIVATE, so we can use width/heightFactor for
       IO, but not for the GUI

(9-Sep-2001, done 9-Sep-2001) Make Tcl::Command ctor take fstring, not
const char*, args. Well, instead I made Tcl::Command::Impl hold
fstring's internally; this is good enough.

(9-Sep-2001, done 9-Sep-2001) Move dlist_... commands to
dlist::... Add dlist::slice.

(10-Sep-2001, done 12-Sep-2001) OK, here's my bright idea for how to
run unit tests of C++ code: put all the test cases into a Tcl package
which can be dynamically loaded into the interpreter, and then the
test cases can be run. This would help get my feet wet with
dynamically-loadable extensions as well. [12-Sep-2001] I've got the
first test done. The only problem is that I have to maintain things in
several places in order to add a new test module: (1) add a
src/tests/*.cc file, (2) add an entry in
~/local/$ARCH/lib/grsh/pkgIndex.tcl, (3) add a testing/*.tcl file. For
now I'm just DSTTTCPW, and hoping that any necessary structure will
fall out of refactoring as I push this forward a bit. Goals are: (1)
any time a bug or crash occurs that was unrevealed by a test, add an
appropriate test file that exposes the bug, then fix the bug, and (2)
any new functionality that is added should be done in parallel with
new unit tests.

(13-Sep-2001, done 14-Sep-2001) OK, to get real packages working:
there should be a "src/pkgs" directory, within which there would be
one directory for each package (i.e., "src/pkgs/face",
"src/pkgs/grobjs"), and all the source files in each subdirectory
would be linked into one shared library containing a Tcl_PkgInit
function, so that it could be loaded with 'package require' into
Tcl. This unified structure would allow us to automatically generate
the pkgIndex.tcl file using make. [14-Sep-2001] Cool! This is mostly
working now. I'm able to have things be quite automated with this
directory structure. We can build a .so --> .o dependency file for
make, based on the directory structure. And, based on #include
"pkgs/*/*.h", we can figure out which other packages are required by a
given package.

(note 20-Sep-2001) Compile times for including standard headers, on
1GHz PIII, g++-3.0.1:

     <string>    0.440u  "util/strings.h"     0.090u
     <vector>    0.310u  "util/minivec.h"     0.180u
                         "util/arrays.h"      0.030u
     <valarray>  0.993u
     <list>      0.300u  "util/dlink_list.h"  0.080u
                         "util/slink_list.h"  0.030u
     <map>       0.460u
     <set>       0.447u
     <iostream>  1.505u  <cstdio>             0.046u
     <istream>   1.452u
     <fstream>   1.738u

     <memory>    0.217u
     <utility>   0.021u
     <algorithm> 0.253u
