###################### -*- text -*- ######################################
#
# ChangeLog 1999
# 
# Rob Peters <rjpeters@klab.caltech.edu>
#
# $Id$
#
#############################################3############################

need to have a way to initialize the appropriate data structures for
an experiment (probably ObjList, Glist, and RealExpt) from Tcl, based
on a simple file description of the experiment

would like to avoid having to manipulate/store Tcl data structures,
preferring C++ STL structures instead

who should own the ObjList, Glist, Expt data structures? when do they
come into existence?

problem: don't want to have to have default constructors for ObjList +
Glist, yet they are necessary for ToglConfig and togl widgets
shouldn't be dependent on having a valid glist constructed already

solution? hold references to pointers in the relevant locations, so
that the actual objects can come in and out of existence as necessary

--> problem with this is that this requires constant testing for null
pointers to see if the objects actually exist



problem: it should be easy to do something simple, like create one
face and display it

solution? some derived class of Expt or Glist could manage these
special situations


what are necessary steps to start experiment?
1) create GrObj's (Faces) and ObjList, knowing the size of the groups
in Glist (how?)-- this requires some temporary data structure to store
the ids of the objects in the different locations

... createObjs function returns a vector of objids giving the objids
for the list of objects that were specified

... would like to be able to have a way to create a set of GrObj's
that it is independent of their exact type, yet that involves a
straightforward file format (maybe give each type a constructor that
takes a string, which in turn contains the obj-specific parameters?)

... how is the number of objects in each group determined? more
fundamental problem: how are the groups stored-- in terms of face
class id (as in STIMDG(groups)) or in terms of actual objid's, where
the objid depends on the position in the group. Is there a way to
avoid having to store both forms of information?

2) create Glist (list of stimulus groups) from input file, or from
(???) that describes special ways to initialize (all pairs, or all
triads...)

3) create an Expt object based on Glist and on the number of repeats


radical idea??? have multiple ObjList's, one for each position in
which a GrObj will be displayed?


solution to big problem??? have Glist own an/the ObjList, so that they
are constructed at the same time, from two files; maybe the Glist is
also owned by the Expt object



**********
Friday, 5 Mar 1999

started moving the stimdg implementation out of Tcl

first goal: remove direct access to Tcl array fields by providing
interface in class Stimdg. Stimdg's are currently initialized with a
Tcl_Interp and a Tcl_Obj holding the name of a Tcl array that has the
relevant fields. But, no one should directly access those
fields. Eventually, a global Stimdg object will be used, whose
implementation can then be something other than a Tcl array.

next steps:
1) must port remaining Tcl files to C++
init_stimdg.tcl : this will eventually become the Stimdg constructor

load_face_data.tcl : straightforward, must read file data into the NL,
MH, etc. fields of the Tcl array

trial.tcl (mostly done) : just need to write recordResponse

parse_stimdg.tcl : actually doesn't need to be ported, since it
doesn't require a Stimdg structure in particular

2) develop some token other than an array name to be passed to C++
from a Tcl script -- this is the final modification necessary for the
encapsulation into C++

***********
Saturday, 6 Mar 1999

1) ported replace_response to C++. This requires using
Tcl_ListObjReplace to exchange the curstim'th element in the remaining
and responses fields. However, the function prototype in the man page
is a little misleading, since the prototype itself shows the range of
indices into the list specified by 'first, count', but the argument
declaration list shows the indices as 'first, last'. Turns out 'first,
count' is correct, but this seems redundant with the objc... aha! you
don't necessarily have to replace a range with the same number of
elements that were there before; thus both 'count' and 'objc'.

2) ported init_stimdg to C++, splitting into a Tcl Cmd proc
init_stimg, which in turn calls the Stimdg member function init (which
should later be moved into a constructor). But ugh; still have to port
the init_triad_stimdg and init_pair_stimdg procedures.

3) had an awful time porting load_face_data to C++. Problem was the
procedure that tried to append an element to one of Stimdg's fields,
by way of Tcl_ListAppendElement. If the field didn't exist before,
there wasn't a problem creating it when it was asked for; however, it
didn't behave very nicely as a list, generating some error about not
converting a string to type. (?) So, had to create an 'initFaceFields'
procedure for Stimdg to first create all of the related fields before
calling the append procedures.

4) ugh. trying to port write_array and read_array to C++. Getting that
same error message:

UpdateStringProc should not be invoked for type 
IOT trap

This time my problem was I was trying to call Tcl_GetsObj to read into
an object from the file, but I was trying to read into a null pointer,
rather than an object that had been initialized with
Tcl_NewObj(). Dumb mistake, but still, the error message could
certainly have been more helpful. 

Also, I can't make read_array work the way I want using C++ strings,
file streams, and string streams, since this lame implementation on
the HP's can't do a getline into a C++ string.

5) There is now one global Stimdg in the StimdgTcl namespace that is
created at startup in Stimdg_Init. This means that the dg_name
arguments being passed to stimdg Tcl functions are just dummy
arguments at the present time; the global Stimdg is always used. 

Should the Tcl array that implements the Stimdg be isolated by putting
it in its own Tcl_Interp? Would this prevent access to the other Tcl
commands that are necessary in the implementation? Duh--no, it
wouldn't since the CmdProc's can be called from C just like any other
function--it's only in Tcl that they must be registered with the
running Tcl_Interp. 

6) There. I made Stimdg use its own Tcl_Interp separate from the one
running the interactive Tcl application.


************
7-8 Mar 1999

Ugh. Very late last night, and today, I implemented a *much* improved
version of the functionality necessary to control an experiment,
through the interface class Expt, and the concrete class
RealExpt. Unfortunately, I also tossed out completely the ~1000 line
of code I had written for Stimdg and StimdgTcl. But, I think things
are much better off now. I realized that there was too much
duplication of data between Stimdg and the other data structures such
as Glist and ObjList and the various GrObj's. Instead of duplicating
data, the Expt class merely provides an interface to the other data
structures, and allows everything to be written to and read from a
single file. As another bonus, this implementation is even more
efficient-- now takes only ~0.84u to start up a triad experiment.

A few loose ends:

1) need to make the object specification truly polymorphic. Who should
control when and where the type strings get written to files? Want to
be able to read files both ways:
		  a) assuming a fixed type all the way through
		  b) polymorphic--determine the type one line/obj at a time

2) need another c'tor or two to be able to generate the different
types of experiments such as pairs and singles--just have to pass
these options to the Glist constructor

NOTE: must change makePairs, makeTriads, so that the objid's take into
account their position in the group

3) need to use symbolic constant to determine how StimClass is set


*************
10 Mar 1999

Things are mostly nice now, but, as always, I have many possible
revisions in mind.

1) There are too many 'little fixes' that I have to keep on
remembering to apply in new code. For example:
	
	- Glist stores objid's-- indexes into ObjList, which do not 
	necessarily reflect the object 'type', since the same 'type'
	of Face, say, may be created at multiple locations, giving
	multiple objid's. In order to check if two objects are the
	'same', I have to adjust for this factor. This is sure to lead
	to trouble at some point

	- within RealExpt, there is a discrepancy between trial type (an
	index into Glist) and trial number (which reflects how many times a
	type is repeated). This also requires many conversions back and
	forth, sure to cause eventual problems.


2) Perhaps I am missing some underlying datatypes that are really
needed, such as Trial, Position, etc. Then 

3) Ugh. Too much of this design has been designed for the sake of
Tcl. I'm starting not to like that language much.

4) Gee, now I have a really nice design for Trials that I should have
switched to months ago. I guess this is what they mean by "be prepared
to throw your first draft (or four) away". 

Wait--Trials should hold id's, not pointers to, GrObjs and
Scaleables. This will make things much easier when we have to
serialize-- in fact, an Expt is starting to look quite nice:

class Expt {
	vec<Trial *> itsTrials; // each is unique
	vec<int> itsTrialList; // randomly ordered list of indexes into itsTrials
	                       // (may contain repeats)

	int itsCurstim;        // index into itsTrialList
	void beginNextTrial();
	void recordResponse(int resp);
	int lastResponse() { 
	  return itsTrials[itsTrialList[itsCurstim-1]]->lastResponse();
	}
}

To achieve better backward compatibility with Glist functionality
(which must interact with ToglConfig), perhaps define Tlist class,
which can exist outside an Expt, but which is controlled by the Expt
while the Expt is in progress.

The only duplication of data here would be Curstim (and
Tlist::itsCurTrial). During an expt these would normally line up, but
Tlist::itsCurTrial could be controlled independently from Tcl.


5) Back to the concrete (i.e. currently existing) software. Grsh
crashed in the 'train' experiment, using repeat of 1, after all 10
trials were completed, and I entered a response anyway. This points
out that we need a good way to know when the experiment is over.

************
11 Mar 1999

1) started using RCS via Emacs' vc utilities. I hope this will reduce
some of the confusion surrounding versions.

****************
13 Mar 1999

1) had very good progress implementing Position, PosList, Trial,
TrialExpt. Spent a lot of time on the serialization/deserialization
functions. This new design is far superior to the old plan--it's
really nice to have the GrObj separated from the Position objects, to
be able to be controlled independently. This fact greatly simplifies
the process of reading and writing expt files.

2) What is left?

* implement functions to read into a TrialExpt from simpler file
formats (such as nos_faces_sel and tr_nossel)

* reimplement the expttcl package for TrialExpt instead of
* RealExpt. Fortunately, except for the constructors this won't be too
* much work since both classes implement the Expt interface. (A real
* instance of OO design at work!)

* figure out a more elegant way to do STL input and output. I can use
* ostream_iterators and istream_iterators, but I'm not too familiar
* with them at this point, and most importantly I'd like to be able to
* control the spacing of the container elements in the output file.

* implement derived classes from Trial to get the right trialType()
* for singles, pairs, triads, etc.

* think about a really robust way to do the file formatting. Perhaps
* some file format descriptor classes?

* some rigorous testing/debugging. Need to add in Assert() statements
* throughout old code, and design Tcl packages to allow for easy testing.

**************
14 Mar 1999

1) need a good way to enforce proper order of initialization of Tcl
packages, such as ObjlistTcl, PoslistTcl, TlistTcl, and
ExptTcl. Actually, the problem is the use of the pointers. Maybe I
don't even need the pointers anymore, since most of the objects don't
ever need to be deleted--they can be adjusted at will using member
functions. In fact, I think the only object that might need to be
reallocated is TrialExpt, and this is at the highest level so
everything is peachy. Still it would be nice to know why
Tcl_PkgRequire isn't working.

2) Don't need to have derived classes of Trial. Instead, should
provide some (non-member) utility functions to go through and set the
types appropriately. Such as findside(const Trial&).


***************
15 Mar 1999

my stack:

-> make ObjlistTcl::theObjList a static object, not a pointer, since
no one ever needs to delete it. same for Poslist.
move the makeTriads, makePairs etc. to Tlist instead of TlistTcl

(done) add test_objects to Makefile that includes test versions of each of
the object modules. These should be compiled with appropriate macros
defined, such as LOCAL_PROF, INVARIANT, LOCAL_ASSERT, etc. Need to
macroize Makefile so that debugging object dependencies are generated
automatically.

(done) Need better way to clear screen in between Trials. glClear is
responsible most of the graphics time. Could either clear a bounding
region, or redraw the Trial with foreground/background swapped. The
latter is easy, except Jitter's don't currently know how to re-do
their previous operation.

(nix) Try implementing GrObj's with stored pixmaps rather than direct
rendering to see if display speed is improved. --> This would probably
interact poorly with Position's. e.g. rotating...

(done) Implement reaction time measurements directly in Expt class rather
than through Tcl.

(done) Add auto save to expt.tcl--save the experiment in a temp file every
100 trials or so.

(done) Add ioTag() method to classes to return whatever name they want to
use as their official typename in serialize/deserialize. This is
better than using typeid(class).name() since this may not be portable
across systems. Also, using ioTag() avoids having to rewrite
typeid... all the time, and minimizes the chance of mucking things up.

(done) Bug: with "pause"--if pause is hit immediately after a
previous pause is released, there is a problem with overlapping faces
being displayed. Fix --> hold an id for the resume timer, so that the
resume can be cancelled if the experiment is re-paused again before
the timer would go into effect. OK, that was a problem, but the real
problem was: Tlist's visibility was not being set to false when trials
were undrawn; thus when the pause window was destroyed, part of the
Togl widget was revealed, invoking a redraw callback, invoking
drawCurTrial(), which redrew the trial that had been undrawn before
the pause. Fix --> Tlist's visibility is now set to false whenever a
trial is undrawn.

(done) move Tcl scripts for Expt:: proc's to C++. ... Everything is
ported to C++ now, but there are still a fair number of Tcl_Eval
call's, so there is still a bit more work to be done.

(note) The problem with the current design(?)/implementation is that
most of the Hard Work is still going on inside the expttcl.cc
implementation (of course it didn't appear that way when it was
implemented in Tcl-- this is why I'm afraid that Tcl can be conducive
to poor designs -- it promotes the use of C++ classes as just
data-holders that expose everything publicly to Tcl). The goal now is
to distribute that work amongst the other objects in the system. I
don't really need to create any new major types; it's just a matter of
getting each of the existing types to take on a little more
work. ...this also means that I'll have to be using some Tcl API's in
the implementation (but not the interface, hopefully) of the
components that were previously isolated from Tcl. But I think this is
not a problem, since the use of Tcl in the implementation is not done
in a way that provides access from Tcl scripts. Actually, Tcl should
only have to be used to implement Expt, which it is practically doing
now anyway in the guise of the ExptTcl package.

(done) Need to store *all* exp't variables somewhere, probably in Expt
class, so that they can be serialized. Get rid of the -global- data in
ExptTcl such as inter_trial_interval, autosave file, etc. Change to
functions in Expt class, and accessor/manipulator functions in
Tcl. OK, moved most things into experiment class-- some will still
need to be moved down further to the Trial level eventually. Much old
ExptTcl functionality is now encapsulated in ExptDriver class -- a
temporary solution (?) until things are rolled back into Expt...

(done) Add virtual method to IO for classes to say how many chars they
need to write themselves. --> Done. Need to test it as part of
generalizing the IO system.

(done 27-May-1999) I'm seeing that PtrList is really used more as an
object database than as an ordinary collection. This seems to cement
the idea that ObjList and PosList should be bonafide singletons,
rather than the pseudo-singletons that are provided now via ObjlistTcl
and PoslistTcl namespaces. Good.  ==> Done. ObjList and PosList are
singletons.

(note) I see... the real advantage of changing ObjList and PosList to
singleton classes is that I no longer need to store references to them
all over the place; instead, classes can just include the headers and
then access the singleton instance.

(done) The ObjId class should contain 1) an int index, and 2) a
reference to its ObjList.  !! Scratch #2-- ObjList is now a singleton,
so we don't need to worry about it! Thus there is no space overhead in
making ObjId a dedicated class. Goal: clients should not have to know
about ObjList + PosList; instead they only know about ObjId and
PosId. Should ObjId's be flyweight objects? This would make keeping
reference counts easy. Should ObjId's act like pointers to GrObj's, or
like pointers to pointers to GrObj's (as a typical iterator)?

(done) TrialTiming -- generic trial/experiment description.
Ding, ding, ding! Bells are ringing. Need a new structure, called
TrialTiming, or EventSequence, or some such, that holds information
about stimulus display time, trial timeout time, inter trial time,
etc. Then each Trial can hold a pointer to a TrialTiming, and the
TrialTiming's can be held in a list. (Maybe I can reuse
PtrList???). Let me just try to scratch some ideas down quickly. Need
to think carefully about the name for this thing-a-ma-jobber. --> This
is done, but right now TimingHandler is attached to ExptDriver,
eventually it should be migrated to be held by Trial.

(done 27-May-1999) I'm still stuck on how to interpret the role of the
ObjList and PosList classes. These are not supposed to be playing a
huge role... they're just a way to identify objects with an objid
rather than with a memory address, which facilitates manipulating them
in Tcl as well as reading/writing them from file. Maybe what needs to
be a first class object is the "objid" or "posid", or some kind of
iterator... The iterator should skip over NULL sites in the
list/vector, and it should match end() when there are only NULL sites
remaining. The outer appearance of ObjList and PosList is that they
are associative arrays between int's (objid's?) and GrObj*'s, but
internally they are implemented with a vector for more efficient
access times than with a map. --> Implemented ObjId and PosId classes
(although they still need better iteration).

(note Jun-1999) What should the requirements be on reading in to a
Trial by ObjId's only? Should we require that the proper ObjId's
already exist, or do we assume they will be created later? Right now
we assume they will be created later, and do not check for their
validity as they are read in.

(Jun-1999, done) Need to make major modifications to prepare for fMRI
work.
--need to make different types of trials, mainly varying according to
how they collect responses, if at all, and how they give
feedback. Most of this stuff could be wrapped in ResponseHandler and
TimingHandler objects; it's just a matter of moving those from
ExptDriver into Trial's. How to do a FeedbackPolicy within C++ rather
than from Tcl?
--Order dependency should be removed from serialize/deserialize
methods: members should be requested by name. Need capability for
versioning in serialize/deserialize.
--need to look seriously at some industrial-strength creational
patterns: I've got a lot of functionality implemented, but it the
various objects need to be able to be assembled in the right
ways. E.g., set the TimingHandler for a whole bunch of Trial's, vary
one parameter along a set of Trial's, etc. Most of this will probably
be helped by having some good iterators for PtrList's.

(fixed Jun-1999) Buggy behavior: if Expt::begin is called on an empty
experiment, the message "expt is complete" comes up but the Expt keeps
on running empty trials, then aborting them.

(fixed Jun-1999) Damn. another bug -- if a GrObj is changed while it
is onscreen, it cannot be properly undrawn since its old state is not
remembered...

(done 9-Jun-1999) Same thing with Tlist [should it be a singleton] ???
Ah-hah!  Tlist is different -- it's more like a Block in an Expt,
because an Expt should conceivable be able to have several blocks. So
a Tlist is a more typical container. (Later) No... the first thing was
correct: Tlist *should* be a singleton. Trial's are an
application-global resource. It is "Expt"'s (to be renamed Block's)
that might exist in multiples.

(done 13-Jun-1999) Need to find some way for reuse in the Tcl
packages. There's just too much copy-and-past going on here. Need to
think about ways to encapsulate the functioning of a Tcl command in a
template or abstract base class, that can be parameterized by certain
things like object count, return type, type of list used, etc...
--how to control the proliferation of Tcl packages needed to wrap each
class that comes up? Or at least simplify these files... maybe with a
generic way to get/set attributes.  --Cool! I've implemented the
TclObjCommand class. This does all sorts of fun stuff. Now I just have
to *use* it everywhere!

(done 13-Jun-1999) Damn. How can we serialize/deserialize
ResponseHandler's and TimingHandler's when they require an ExptDriver
reference? Maybe the RhList and ThList can store the references that
they need? No, this only postpones the problem. It'd be nice to have
the ExptDriver be a global resource, but it in turn requires a
Tcl_Interp*, so it can't be initialized until Expt_Init is called. I
guess I could just give up on multi-interpreter capability, create a
global ExptDriver first with its Tcl_Interp* set to NULL, then
initialize its Tcl_Interp* when Expt_Init is called. Or... could
switch from ExptDriver& to ExptDriver*, but this loses some
saftey. --> OK, ExptDriver has now (like just about everything
else...) become a singleton. However, its Tcl_Interp* is not set until
the Expt package is initialized. This way, ResponseHandler's and
TimingHandler's can get a reference to theExptDriver. Also,
ResponseHandler's no longer depend on ExptDriver for their
Tcl_Interp*; instead, theRhList contains a Tcl_Interp*, and ensures
that any ResponseHandler's added to theRhList have their Tcl_Interp*
set correctly. In addition, any ResponseHandler's that are on
theRhList when the Rh package is initialized will have their
Tcl_Interp*'s set correctly.

(done 13-Jun-1999) Need to write Tcl packages for RHList, THList, and
BlockList. Ugh. --> Actually, not 'ugh' ! I've implemented a TclPkg
class, which controls and contains TclCmd's. I've subclassed this with
TclListPkg, which contains the common xxList TclCmd's, and arranges
for them to forward their operations to virtual functions in
TclListPkg. This way, the RhList, ThList, etc. packages are very easy
to implement: just sublcass TclListPkg, override a few operations, and
presto-change-o you're done!

(done 13-Jun-1999) This is low down on the list, but would be
intersting... Generate an object-based C++ wrapper for the Tcl C
API's. This would be something as straightforward as possible-- not
trying to change the *design* of the API, but just making things more
C++-friendly. Could start off by wrapping up the Tcl_Interp and
Tcl_Obj classes, then add member functions as I need them. --> I think
I'm well on the way to accomplishing this sort of thing with the
recently-added TclCmd's and TclPkg's... these hide most of the
low-level Tcl API calls and provided simpler/shorter ways to
accomplish the common things, but in general don't prevent low-level
calls from being mixed in as well.

(done 13-Jun-1999) Try Tcl packages as static instances of classes
declared within Tcl_AppInit. --> This requires more code in the pkg.h
files (such as the package class declaration). OK? maybe, but I need a
while for the ramifications of this to simmer. This may be too far out
of line with Tcl coding standards... --> No: the way to do this is the
way I've accomplished it now with TclPkg's. The package is defined as
a sublcass of TclPkg, and the Pkg_Init function simply calls 'new
PkgName(interp)'. (This does not call a memory leak since TclPkg sets
up an exit handler to delete itself when Tcl is exited). This way we
can do Tcl packages as classes, yet still conform to the method of
calling the Pkg_Init functions from the AppInit.cc file.

(nix 13-Jun-1999) fix the object hierarchy so that Expt contains Tlist
by value, which contains ObjList and PosList by value ... is this a
good idea?  It seems to break some aspects of encapsulation, since it
requires ObjList/PosList declarations to be visible wherever Tlist is
used. Maybe can get around this with containment by reference, but
also ownership. Or containment by * const. Yes, this would work. Never
mind, it wouldn't make sense, since still clients of ObjList would
have to have Tlist and Expt visible in order to retrieve the current
ObjList. That is the real problem. No...... the real problem is---
Expt, Tlist, ObjList, PosList, etc... should all be top level
objects. But Expt needs to use Tlist, etc., so maybe these all should
be contained in a higher level object-- TheApp??? This could serve up
the current Expt, ObjList, etc. ---> [Later] This has taken care of
itself by way of most of these classes becoming singletons. Perhaps I
will still add a top-level class which is in charge of serializing all
of the singleton's, but this isn't too great of an issue.

(done 13-Jun-1999) Implement multiple deserialize protocols so that
old objects can be deserialized. Just need to add some sort of version
byte/code in the file to map to the appropriate deserialize
function. --> OK, I've implemented this for Face, but... this is
really more of a mess than it sounds like, since whenever a class
definition changes, not only the current deserialize protocol must
change, but also ALL of the previous supported protocols. This is a
true mess if the underlying object representation changes
dramatically. Need to think about this some more... see if I really
want to muck with multiple versions throughout the object hierarchy.

(nix 13-Jun-1999) Error handling.  Get rid of TCL_ERROR as return
status from procedures that handle Tcl, but aren't
Tcl_CmdProc's. Instead, throw TclError(useful_info_string) and then
catch these exceptions in high-level callers-- i.e.,
Tcl_CmdProc's. ---> [Later] The above was all wrong. The correct way:
in asynchronously-called procedures, Tcl errors are raised with
Tcl_Background error. And, in the new TclCmd class hierarchy, errors
are generated by throwing exceptions of class TclError; these are
caught and converted back to a 'return TCL_ERROR' before control
returns to Tcl.

(15-Jun-1999, done) Clean up some old Tcl package files by converting
them to TclCmd/TclPkg format. ... in progress ... I'll skip misctcl,
tcldlist. But still need to do subjecttcl.

(done 16-Jun-1999) figure out how to make !@#$^& shared libraries
work! [Later -->] Well, they're !@#$^ing working now, but they're
still a pain in the @$$. For some reason, objtogl doesn't like to be
linked in as a shared library, but instead as an ordinary .do file
(although the .do file can be compiled with the +Z option). If it is
linked as a shared library, everything grinds to a halt in
toglDisplayCallback, apparently on the call to glClear()... why is
this? A likely candidate would be the fact that objtogl is the only
package besides grshAppInit that uses <togl.h>, but yet it appears the
crash is occurring on the call to OpenGL... maybe this happens to be
the first call to GL?

(done 16-Jun-1999) Bitmap's are not undrawn in the same way as all
other GrObj's. In particular, it is certainly quicker to clear the
pixels rather than recopy to the framebuffer... This will entail
adding an undraw() operation to GrObj. Done --> basically, use
gluProject to find out in window coordinates where its beginning
raster position falls, then use glScissor to define a rectangle
beginning from this point and having the correct height/width.

(done 16-Jun-1999) Issues with Bitmap's:
--how to get the correct contrast? OK, added a flipContrast command.
--should implement Pbm modes 5 + 6? OK, just 'is.read(itsBytes, itsNumBytes)'
--need to optimize for bitmap operation. OK, done.

(done 16-Jun-1999) Move timing handler Tcl commands from expttcl to
thtcl. --> Done. It was a lot of fun to remove all of those pointless
accessor/manipulator functions from ExptDriver that were just
forwarding to TimingHandler or ResponseHandler.

(16-Jun-1999, done 17-Jun-1999) make a class TclEvalCmd or similar, to
serve as a wrapper for this repeated 'static Tcl_Obj*, static
TclObjLock' junk. --> Done ... but ... could extend this to make
TclEvalCmd's that declare themselves to return given types? Or is that
just too much?

(16-Jun-1999, done 17-Jun-1999) Would like to add declareIntSetter,
declareIntGetter, etc. to TclItemPkg, but first I'm going to have to
figure out how to avoid the proliferation of duplicate code that
occurs for each of the basic types that are supported. Should be able
to do this with templates, but how??? I think it comes down to the
necessity for member templates, which I'm not sure if aCC has... maybe
I should find out! [Later -->] Doh! This is what operator overloading
is for... all I have to do is overload returnVal() for the basic types
in class TclCmd, and then elsewhere in the program I can use templates
on the basic types, which will compile correctly iff the template type
is supported by a returnVal overload in TclCmd. So, now I have a
generic TclGetterCmd template working-- it's templatized on the type
of object to get from, and on the type of value to get. Also just
noticed that it's fairly expensive in compile-time to modify
tclcmd.h--this file is very heavily depended-on.

(17-Jun-1999) Looks like TlistTcl could also use some de-bloating via
conversion to TclCmd/TclPkg. --> This is under way: TlistPkg now
implements the TcllListPkg interface, so stringify, destringify,
reset, and count are now handled automagically. Actually most of the
bloat in TlistTcl is due to the creational functions makeSingles, etc
that really belong elsewhere (where?) Should all this creational code
go toether in one area, or does Tlist need a separate creational
packaged from Expt, for example? [Later] ... this stuff has moved to
TlistUtils.

(note 18-Jun-1999) Got another core dump with a "missing symbol during
dynamic loading". The dynamic linker couldn't find TclError() for a
call inside a function defined inside an unnamed namespace. The
solution (workaround) is to put the function inside a named namespace
and follow with a using namespace directive.

(15-Jun-1999, done 18-Jun-1999) Bitmap serialization: need mainly to
record the filename. Done --> but, do I want to have an option as to
whether to record the graphics filename, or to actually write the
graphics data??? I think no, since writing the graphics data would
hugely bloat all of the expt files that are saved for subjects.

(18-Jun-1999, done 18-Jun-1999) Better find a place to 'catch' the
PbmError's that occur on an invalid filename. OK, Bitmap catches any
PbmError's that occur during loading. Should Bitmap also rethrow an
IoError, perhaps?

(17-Jun-1999, done 18-Jun-1999) Should have declareGetter,
declareSetter, declareAction in TclItemPkg along with
declareAttrib. --> OK, now I have getter/setter working, but still
need to implement declareAction. --> OK, declareAction is done too.

(19-Jun-1999, done) Big Bug #2. There seems to be a problem with
exceptions: in TclCmd::getDoubleFromArg, when an exception is thrown,
the Trace object is not properly destructed... maybe this is
underneath the problems that have popped up with exceptions elsewhere?
[Later] I think this was a problem with having multiple versions of
the Trace objects floating around (i.e. some compiled with tracing on,
others with tracing off)... this led to multiple definitions of
~Trace()... a "bad thing".

(16-Jun-1999, done 20-Jun-1999) Now that shared libraries are
pseudo-working, it is definitely a worthy goal to try to get Tcl's
'load' command for shared libraries working. However, this will entail
working out the various dependencies between Tcl packages (such as
that of Face on ObjList)-- these will not the same as C++ compile-time
dependencies. ... --> OK, I have this working in principle
now. Package init procedures need to be taken out of namespaces and
put in the global namespace with an 'extern "C"' declaration so that
Tcl is able to find the init procedure from a package name. Then
packages are available via 'load filename', or I can set up a Tcl
config script with a bunch of "package ifneeded"s to specify which
files to load for a filename. Now it's just a matter of working out
the dependencies between files.

(16-Jun-1999, done 20-Jun-1999) Need more generic way to do
getItemFromId() inside TclItemPkg. Would like to allow for this to
work for ExptDriver as well, which doesn't actually require an ID,
since it's a singleton... so we need to specify within TclItemPkg
which Tcl command argument, if any, should be taken to be an item
ID. Also, it would be nice for TclListPkg's to also be able to
declareAttrib, declareSetter, etc. I think this calls for a base
interface that declares and defines the declareAttrib, etc. functions,
but which forwards the retrieving of an item to a virtual function
getItem(). Then in subclasses of this interface, getItem() could be
defined to call getItemFromId(), or in the case of TclListPkg, it
could be defined to just retrieve the list singleton. How to define
the underlying TclCmd's so that they work correctly in all cases?
Right now they all call itsPkg->getItemFromId(). ... --> OK, I have a
sort of hackish way of getting this all working... TclItemPkg takes an
argument specifiying which Tcl command argument contains the item_id;
if this number is 0, then it is assumed that an id is not needed to
retrieve the item, and therefore an id of -1 is passed to the virtual
function getItemFromId. The commands that are created by TclItemPkg
also know how to do the right thing with regard to the presenc/absence
of an item_id argument. Now we should have TclListPkg inherit from
TclItemPkg so that we can add attribs, etc. to lists. ... Actually,
this would hardly be even necessary once I have declareAction working,
because then a ListPkg can just declareAction("reset") and
declareGetter("count") and we can do away with a separate TclListPkg.

(18-Jun-1999, done 20-June-1999) Question: does putting forward class
declarations in a .cc inside an unnamed namespace actually cause the
class definitions to remain locally visible only? --> NO. The way to
do this is to use a named namespace, put forward declarations inside
namespace block, then define the classes out-of-line by using an
explicit namespace qualifier when defining the class; i.e. 'class
mynamespace::my class {};'

(16-Jun-1999, done 20-Jun-1999) Move Block-related commands out of
expttcl and into blocktcl. Along the way, morph expttcl and blocktcl
into TclCmd/AttribCmd/TclPkg-compliant packages. Done. It's nice that
after "blind refactoring" with no specific goal in mind, the
underlying abstractions come out crystal clear--better than I could
have stated on my own a priori. ExptTcl now has exactly the commands
that you'd think it should: begin, stop, pause, read, and
write. (Although autosaveFile is a bit of a wart...)

(21-Jun-1999, done 21-June-1999) I think TimingHandler's really need
to be expressed more generically, in terms of TrialEvent's, whose
timing should be specified either relative to immediate, Trial start,
or response seen. This can all go in a base class; then we can
recreate the interface of the current TimingHandler in a derived
class. --> Done.

(21-Jun-1999) Can get seg-fault by closing Tk-Togl window while tcl
shell is still running, then calling exit. Problem is: who 'owns' the
ToglConfig, and who 'owns' the Togl widget that it contains? I would
like ToglConfig to own its widget, and for ObjTogl to own the
ToglConfig singleton. But the problem is that the ToglConfig doesn't
have total control over the destruction of its widget, since the
widget can be destroyed by dismissing the top-level application window
or by exiting the application. If the ToglConfig handled the widget's
destruction, it could arrange to delete itself when the widget was
destroyed, but then it would have no way of informing ObjTogl that it
had gone away... Right now I've patched the problem by having ObjTogl
own the widget, in the sense of creating and destroying it. There is a
static destroyCallback that is registered through the Togl API as a
destroy callback; this callback will be invoked in one of several ways...

(22-Jun-1999, done 22-Jun-1999) Should add a
"mother-of-all-base-classes" base error class from which to derive all
client errors so that TclCmd can catch all errors (somehow catch(...)
is failing to work). ... Done.

(22-Jun-1999) How to improve Bitmap performance ?
-- use glBitmap --> ding, ding, ding, we have a winner! This disallows
using glZoom, though, so I'll have to manually flip the image
vertically. What a pain. Adding a flipVertical command to
Bitmap... this will require a flag to be serialized a la
itsContrastFlip. <-- Done. Got a nice performance boost out of all
this... rendering times for the 280x296 bitmaps were ~500 msec before,
and are now ~85 msec. Not bad for a day's work...

(22-Jun-1999, nix 22-Jun-1999) Maybe can also Bitmap improve
performance by using 4-byte chunks? --> Nope.

(21-Jun-1999, done 22-Jun-1999) Need to migrate base ResponseHandler
and TimingHandler code into abstract base classes, then create
subclasses for the current incarnations, such as KbdResponseHdlr and
BasicTimingHdlr (?). Need to add these classes to the IoMgr
package. Then can also add a NullResponseHdlr (which should do
nothing). Actually, the NullResponseHdlr needs to trivially generate a
response upon beginning the trial, so that no matter what happens with
the trial, it has seen a response and so can be considered complete.

(20-Jun-1999, done 22-Jun-1999) Realized the objType and posType
commands should belong to the GrObj:: and Pos:: namespaces, *not* the
ObjList:: and PosList:: namespaces.

(21-Jun-1999, done 23-Jun-1999) Going to have to go to
double-buffering in order to achieve reliable timing. How to implement
this??? Maybe with a new event type RenderNextTrial. This would
involve adding a flag to Trial (or somewhere else?) to indicate if a
Trial has already been rendered into the other buffer. Then when
Trial::draw is called, it checks the flag, and either renders the
Trial, or swaps the buffers, as appropriate. --> Blah blah
blah. Didn't need any of that fancy stuff. Just added a
SwapBuffersEvent to invoke ExptDriver::edSwapBuffers. Then the timing
handler runs the swap buffers event when appropriate. For the fMRI
experiment, one buffer is always the stim buffer, and one is always
the blank buffer. This is nice since it avoids any expensive screen
clears. The swapping is pretty fast, only about 3 msec for a large
window (1000x1000). Thus there is plenty of time in the 167 msec of
blank time to 1) swap to blank buffer (3.5 msec), 2) undraw the
current trial (4.5 msec), 3) draw the next trial (85 msec), and 4)
swap back to the stim buffer (3.5 msec).

(22-Jun-1999, done 23-Jun-1999) member template instantiation? I guess
I can somewhat get around this problem by defining an inline member
template that calls a private templatized class-static function that
does the actual work. Then that static function can be instantiated
for the basic types. Is this really better than just overloading the
function?  Errors that would have previously been compile-time errors
when the overloaded function is not present now become link-time
errors when the template instantiation is not present. On the flip
side, adding support for a new type involves only changing a .cc file
rather than a .h file. Actually, I can't even use the explicit
instantion syntax to do the instantiation; instead I have make calls
to all of the functions that I want to use--this is done inside a
dummy member function 'instantiate()' that should never actually be
called.

(note 23-Jun-1999) My TclItemPkg's are becoming sort of like
metaclasses, I think... They make the environment more like that of a
"dynamic" language, although there is still strong type checking
through use of templates and limited use of casts.

(23-Jun-1999, done 24-Jun-1999) Make Error subclass that includes a
message, such as ErrorMsg or MsgError. IoError and TclError should
then derive from this intermediate subclass. This allows for a generic
catch clause in TclCmd::dummyInvoke that catches ErrorWithMsg's and
prints their message. Done.

(23-Jun-1999, done 24-Jun-1999) Need some sort of wrapper for OpenGL
calls that seem to crash when they coexist with <tcl.h>. This is a
hack. --> Instead of this, I've just decided to link in any
GL-dependent files statically rather than dynamically... this appears
to get around the problem, which is about the best I can hope for
since I can't seem to actually pinpoint the problem.

(24-Jun-1999, done 24-Jun-1999) Need to make Bitmap::flipVertical work
correctly for 8-bit and 24-bit images. --> OK, I guess I also had to
make it work correctly for 1-bit images. But now it's a lot faster all
around. I didn't know that the images were always aligned so that each
row begins at the start of a byte. This makes flipVertical very easy,
since its just a matter of memcpy'ing a whole row's worth of bytes at
a time from the old location to the new location.

(17-Jun-1999, done 24-Jun-1999) It would be nice to get charCount()
working, even if the estimates are way-over-the-top... this would
avoid having to override getBufSize() functions in packages that make
stringify/destringify commands. ...The Problem is that charCount()
basically has to duplicate the entire logic of serialize(), which may
be very involved and tedious, so duplicating it is also tedious and
error-prone. Maybe it's best to have charCount just give a worst-case
estimate. Actually, there are two reasonable alternatives that I can
see, with opposing benefits: 1) charCount returns a maximum possible
value--this makes the estimation of number of char's very fast, but
probably wastes a lot of space, and 2) charCount actually serializes
its object into a local buffer to determine the exact char count--this
will effectively double the stringification time, but will ensure the
right count and won't waste any space. Question: can these two
strategies be mixed?  Maybe the solution is to get a good template
gCharCount<vector<T> > working, where T is of type IO*. This is a
big-ass pain. Still need to fix TimingHdlr::charCount, but that
requires more freakin' vector serialization... maybe it's time I
derived Vector from vector and IO, hmmm? But for now things are
working well enough that I can remove the getBufSize from
TclIoItemPackage... this was just a hack to get around broken
charCount implementations. Now I have few enough of those that I can
retreat any hacks back into one or two charCount's.

(23-Jun-1999, done 24-Jun-1999) Add way for Getter's/Setter's to
override the default usage string--this allows them to also be used as
generic one-argument functions/value-returning functions.

(done 24-Jun-1999) OK, now I have 6 lists: ObjList, PosList, Tlist,
RHList, THList, and BlockList. Who should serialize these? A toplevel
object, maybe whose purpose is only to read/write. Whoever it is will
have a really lengthy dependency list. OK, for now this can all be
taken care of by ExptDriver.

(19-Jun-1999, workaround 24-Jun-1999) Big Bug #1. Potential problem
with compiler or OpenGL library? Having segmentation fault problems
again in tlisttcl that occur only when the package is dynamically
linked, but not statically linked. This is maybe similar to the
problems with grshAppInit and objtogl, that also didn't like to be
dynamically linked? All three packages use OpenGL, but other packages
using OpenGL aren't crashing... This really odd-- I can work around
the problem by moving the OpenGL code out of a TclCmd virtual invoke()
procedure, either to a Tcl_ObjCmdProc (as it was before), or to a
non-virtual function in Tlist. ? Ugh. Could it be a preprocessor
problem, like the OpenGL header is getting mangled somehow? But this
wouldn't explain why the code *does* work in a Tcl_ObjCmdProc. The
problem does seem to depend on both <GL/gl.h> and <tcl.h> being
included... I wonder if there is any issue with order of
inclusion. None of the packages that use GL but not Tcl (i.e. the
GrObj subclasses, Position subclasses, Trial, Tlist) are having
problems. --> Can't seem to get anywhere... even using the debugger,
things just crash on the calls to OpenGL. For now it's easiest just to
link in statically everything that calls OpenGL.

(24-Jun-1999, done) Now that we have a standard location for catching
run-time errors in TclCmd, I should be able to remove many catch
blocks from within current TclCmd's, particularly those doing
I/O. Also, IoError probably no longer needs the semantics of adding
its own type to the beginning of the error message; this could be done
instead in the TclCmd's catch block.

(23-Jun-1999, done 25-Jun-1999) ExptDriver needs to be able to run
multiple blocks.  --When a block is done, see if there are more
blocks; if so, start the next one, otherwise stop. --> Done

(23-Jun-1999, done 25-Jun-1999) Need a better way to control the end
of trials. In particular, end-of-trial should not be tied to
recordResponse or abortTrial in Expt/Block's. This makes it difficult
to do expt's that have no responses. Making this fix would also
simplify NullResponseHandler (it could actually generate no
response). --> Done.

(21-Jun-1999, done 25-Jun-1999) What are the different ways we'd like
to make Blocks?  --put trialid's in numerical order, for a given range
of trialids.  --put trialid's in a randomized order, for a given range
of trialids.  Done. There are two operations, addTrials(), which puts
a range of ids into the Block in straight order, and shuffle(), which
can optionally be used after addTrials() to randomize the order of the
trialids.

(20-Jun-1999, done 25-Jun-1999) The next step in having good
genericity with TclPkg's is to allow an easy way for client errors to
be transformed into TclError's. Somehow either TclPkg's or TclCmd's
need to be parameterized with an error type... then they can catch
this type. Or... all client error classes could derive from a base
type (perhaps the standard library 'exception'), then TclCmd could
just catch the base class. Done--> added Error and ErrorWithMsg base
types that can be caught be TclCmd. All client errors should derive
from one of these bases, preferably ErrorWithMsg.

(16-Jun-1999, done 25-Jun-1999) In Expt/ExptDriver, do away with
monolithic 'init' command, and make several creational commands, such
as shuffle_init, straight_init, etc., and each command should take a
range of trial_id's as an argument. Done. (or at least started). Now
no longer need init() for ExptDriver, and Expt/Block's have
addTrials() and shuffle().

(note 25-Jun-1999) Perhaps a good way to think about the future of
grsh is to consider what would be necessary to handle other sorts of
experiments... such as dual-task expt's, staircase expt's, motion
expt's. Not that I need to implement the functionality for those, but
do I have the right abstractions in my framework so that it wouldn't
be exceedingly difficult to implement them? Which part of my framework
would handle the new functionality? I think a subclass of Block could
do a staircase. A subclass of Position could probably handle motion,
but this would require constant rescheduling of idle callbacks to
handle the redraws. Dual-task exp't, especially if the tasks appear at
different times, would be tricky. Maybe? Perhaps a subclass of Trial
could handle this, although it would require a bit of trickery on the
part of TimingHdlr's in order to get the Trial to do the right thing.

(25-Jun-1999, done 26-Jun-1999) Stop messing around and just rename
Expt to Block and ExptDriver to Expt, dammit! OK, I renamed Expt to
Block but I think I'll leave ExptDriver as is for now, partly because
renaming ExptDriver to Expt could wreak havoc in my RCS files with the
old expt.h/expt.cc files.

(25-Jun-1999, nix 26-Jun-1999) ExptDriver should be able to do
arbitrary ordering of blocks? Or should it just run through blocks in
sequence... Yes, just in sequence is fine. Just need to create enough
blocks as necessary, then address the individual blocks by id.

(26-Jun-1999, under way) OpenGL crash problems raise issue of who
should really be allowed to call OpenGL? Best to keep all graphics
calls as localized as possible... this still needs some work. [Later
16-May-2000] This is a slow migration, but the necessary architecture
is now in place with GWT::Canvas.

(27-Jun-1999, done 27-Jun-1999) Moved the decision to abort a trial
based on response value from ExptDriver back into
ResponseHandler... this makes more sense since this way ExptDriver
doesn't have to care about valid/invalid responses; it just does what
it's told. KbdResponeHdlr now either sends ExptDriver a
processResponse or abortTrial message depending on what keysym it
receives.

(21-Jun-1999, done 27-Jun-1999) Need to remove certain implicit
dependencies that remain in ExptDriver upon KbdResponseHdlr instead of
generic ResponseHandler. Also, there are some icky order dependencies
in ExptDriver relating to who of Block/ResponseHdlr/TimingHdlr is
first to receive certain messages. OK, I think there are no order
dependencies now that I've removed the requirement that every trial
must have a response-- now there are three valid ways for a trial to
end: 1) with a response), 2) with an abort, or 3) with neither a
response or abort. The only tacit dependency remaining on
ResponseHandler is the convention of using -1 for an invalid response;
this is probably fine, but should be stated more explicity
somewhere. (Maybe as a static constant in ResponseHandler?) Yes, I
think that's a good idea. Done.

(25-Jun-1999, done 28-Jun-1999) TclCmd's should be able to get and
return lists. Just need some translators from Tcl list's to C++ STL
lists. --> Easy! Just added set of functions appendVal() to append the
basic types as list elements to the Tcl result, then added a template
function returnSequence() which works with a sequence like the STL
algorithms, by incrementing and using one iterator until it matches
another iterator.

(28-Jun-1999, done 28-Jun-1999) The semantics of loadFaces are a
little bit wacky now... need to dump the first_id argument since it
now does nothing and is unnecessary anyway. --> Done.

(27-Jun-1999, done 28-Jun-1999) I've got some fairly dangerous
overloading in Tlist-- where getTrial may or may not create a new
Trial depending on whether the calling Tlist is const or not. This is
not the kind of think I'd like to have happen implicitly... should
change name of one of the functions. --> OK, changed the const version
of getTrial() to getTrialConst() so at least there are no implicit
catastrophes now.

(25-Jun-1999, done 28-Jun-1999) Must test timing issues. Add stopwatch
to ExptDriver. Add requestedTime to Trials? to Blocks? Then ExptDriver
can check actual time vs. requestedTime and make up the differences
between Trials? between Blocks? --> OK, have a stopwatch in timer now
that clocks each trial. Gee, maybe the TimingHandler should do what it
says? I.e., it should handle time, and therefore be the sole source of
timing info during the expt... if the ExptDriver needs to know the
time, it asks the TimingHandler, and the ExptDriver should feed this
info to Block in order to record the response time. This functionality
must be part of the TimingHdlr base class. OK, added clock to
TimingHdlr, and added public getElapsedMsec function to retrieve the
elapsed time at any point in the Expt. Added clock to ExptDriver to
measure the total time of the Expt.

(25-Jun-1999, done 29-Jun-1999) [Earlier] Who owns the ".togl"
widget. Is it another aspect of ExptDriver?  This is a glaring
outstanding implicit dependency among different files in the
project... again I think this is an unfortunate consequence of Tcl's
'feature' of gluing unrelated code together. The ".togl" is basically
mischievously disguised global data. This is what happens when
variables are untyped, declarations are not required, etc.-- design
flaws can creep in and lurk. [Later] Need to get rid of the ugly
implicit dependency everywhere on the presence of a widget named
".togl". Need to basically make the widget a singleton... 1) ensure
that only one Togl widget can exist at a time, and 2) provide global
accessibility to this widget, either through its Tk pathname, or
through a 'struct Togl*' (or both?)  ... fixed.

(28-Jun-1999, done 29-Jun-1999) Idea: all ObjTogl functionality is
provided in Togl:: namespace in Tcl; no direct calls through widget
command are needed (or allowed; the widget pathname should is private
in theory)... this allows only one widget to be created. OK, I think
there really isn't any way from preventing extra togl widgets from
being created via the 'togl' command, but it is possible to ensure
that only the first widget becomes the priveleged singleton through
the rest of the C++ program. OK, now I've removed all the nasty
dependencies on '.togl' throughout the C++ program, but still need to
convert the Togl procedures over to TclCmd-style.

(29-Jun-1999, done 29-Jun-1999) Need to convert the Togl procedures
over to TclCmd-style. Done.

(16-Jun-1999, done 29-Jun-1999) Would be nice to have a typeless
interface that the from which the lists could inherit their non-typed
commands (such as count(), reset(), getValidIds(), etc.). This way,
generating TclListPkg's would be totally idiot-proof... [Later]
Actually, using templates there is no need for a base
class... templates provide ad-hoc polymorphism, where the types to be
used only have to share member functions with the same signature. This
allows the functions to be non-virtual, giving better performance, at
the expense of run-time polymorphism (which is not needed in this case
anyway). Templates are cool!

(21-Jun-1999, done 29-Jun-1999) What are the different ways we'd like
to make Trials?  --make one Trial per GrObj, with trialid == posid,
for a given range of GrObj's, and using a specified posid. --> This is
exactly done by makeSingles.

(note 30-Jun-1999) OK, so templates are great for code sharing, and
are very expressive, but they aren't so great for rapid development...
code sharing through templates tends to cause lots of recompilation.

(21-Jun-1999, done 30-Jun-1999) Probably need to think about a way to
split up the duties of IoMgr into several smaller factories...
probably need to create factories and then somehow register them with
IoMgr? Let's see... each class hierarchy should have a factory, each
class in the hierarchy should override some function to return a new
instance of it (like newGrObj), and the factory should provide
functions to obtain an object by name. The bindings between names and
creational functions should be able to be generated at run-time (at
initialization). How will this interact with the PtrList's? Currently
they all use IoMgr to create new objects from a stream... if each
object hierarchy has its own factory, then the PtrList's will also
have to be parameterized by a type of factory. Hey this Factory thing
is pretty cool, all because of templates. How to ensure that all types
are registered with a factory before it is used?  IoMgr depends on
static knowledge of all the types it might have to instantiate... this
could be fixed by switching over to a Factor that allows types to
register themselves... the types could all register themselves in the
Tcl package init procedures, but this introduces a somewhat unsightly
dependence between the core of the C++ app (namely the IO factory) and
the specifics of the Tcl app (namely the package init proc's). Well,
actually I guess it's not so bad-- *somebody* is going to have to do
the intializations of the factory, and there is no reason that it
couldn't be someone other than the Tcl init proc's if necessary. OK,
this is all done. But still might want to split IoMgr into separate
categories?

(28-Jun-1999, done 30-Jun-1999) Need algorithm in Bitmap to center
Bitmap's on a point in GL coordinates. --> Done.

(1-Jul-1999, done 1-Jul-1999) Could change GrObj organization so that
subclasses don't have to deal with grNewList, glNewList, etc. Instead,
use the method template pattern so that a GrObj method does the
grNewList etc., then calls a virtual function to do the actual GL
work, then calls grPostUpdated at the end. This would also allow
GrObj's to be toggled between compiled- and direct- mode
rendering. Virtual function should be called grRender(), and
grRecompile becomes the template method. Done.

(25-Jun-1999, done 1-Jul-1999) Need a TextString subclass of
GrObj. This will require fonts--> this will require using
Togl_LoadBitmapFont --> this will require a struct Togl* --> this will
require global access to a Togl* --> this will require making the Togl
widget a singleton somehow. OK, now have global access to Togl
widget... but now, who should control loading/unloading of fonts? Each
TextString certainly doesn't need its own copy of each font... OK,
I've implemented Gtext class. There is only one font loaded at a time
for the entire class; each time time a Gtext is drawn, it checks to
see if the currently loaded font is the one it used last time it
compiled its display list and recompiles itself if necessary before
drawing.


(1-Jul-1999) Time to get back to testing...........................
OK, I have a bit more flexible framework for testing now; each Tcl
package gets its own XXX_test.tcl file, and all of these files are
sourced in the main grshtest.tcl file. The idea, though, is that any
of the individual test files should be able to stand on its own-- it
should acquire and release any resources that it might need
locally. Now that I have generic TclCmd's etc. working, it would be
nice to make the testing process a little generic as well, such that
tests that are repeatedly testing the same C++ code (such as the arg
check for a TVecAttribCmd, for example) can be a bit more automated.

[Earlier] I squashed a bug that was basically a result of having
written less-than-accurate function names. ExptDriver::stopTime was
used to cancel all timer callbacks, but it also aborted the current
trial, which is not necessarily implied by its name. Aborting the
trial in the middle of ExptDriver::handleResponse then had a
disastrous effect. Better rename these functions quick. Also, there
should have been a test in place to identify this bug... better write
those ExptDriver tests quick.

(29-Jun-1999, done 2-Jul-1999) Analogously to TclCmd::returnSequence,
it would be great to be able to extract from a Tcl list arg into an
STL back_inserter iterator. For one thing, this would allow ItemCmd's
to be vectorized, applying the same operations to multiple items at
once. OK, I have the necessary functionality in TclCmd now, but still
need to add the appropriate stuff to TclItemPkg. Need to define some
TclCmd subclasses in the .cc file that handle vectors of
items. Clients will probably create these with something like
declareVecAction, declareVecGetter, declareVecSetter, etc. OK,
actually don't need special declareXXX functions, since I think all
commands can be vectorized by default; there is negligible run-time
cost even in the case when the vector is only one item long, and for
looping, this method is definitely faster (20%?) than doing the
iteration within Tcl. But, how to deal with VecSetter's? Do they set a
bunch of items to one value, or do the set a bunch of items to a bunch
of different values? And if the command takes two lists as input, then
what happens if the lists are not the same size? Clearly, if there are
more values than items we can probably just silently throw away the
extra values. But what if there are more items than values? Maybe the
best thing is to match values one-for-one with items until we run out
of values, then use the last value to set the remaining items. ... Now
why in heck doesn't the compiler want to generate a specialization for
'const string&' of TVecGetterCmd? Should be able to derive TVecAttrib
command from TVecSetterCmd and TVecGetterCmd somehow in order to avoid
duplication. OK, did the multiple inheritance thing. Everything is
working... this is awesome? I have all this cool template stuff and
multiple virtual inheritance going on in the same package... yes,
people are right when they say it's very complicated (MI + templates)
but it's also amazingly expressive.

(2-Jul-1999, done 2-Jul-1999) Now that vectorized commands are
working, we can change the semantics of Block::addTrials so that
rather than taking a first/last id pair, it can just take a sequence
of ids. Actually, the C++ class just needs a function addTrial() that
adds one trial at a time, and BlockTcl::addTrialsCmd can actually do
the iteration through the sequence. OK, added Block::addTrial to C++
class, added BlockTcl::addTrialIdsCmd to Tcl interface that takes a
sequence of trialids (kept the old addTrials command around just in
case...)

(3-Jul-1999, done 3-Jul-1999) Need a way to distinguish between Tcl
package name and the namespace name that is used with the package
(since the two may require different capitalization). OK, this is
fixed by just having TclPkg enforce the correct capitalization when it
calls Tcl_PkgProvide. This way, packages can use whatever
capitalization they like for their namespace prefix.

(3-Jul-1999) Maybe that weird extra stuff in Tlist should be split off
into its own class, since now it is isolated from the internals of the
list via the derivation from PtrList. This is of one of those
heuristics where a class shouldn't contain disjoint areas of
functionality. Now, I think the extra Tlist stuff could probably fit
in with that amorphous ObjTogl/ToglConfig/Togl* abstraction that is
beginning to take shape, since ObjTogl was the primary client of the
Tlist's extra functionality in the first place anyway.  [Earlier] I
think in the larger picture, the singleton Togl wants to be a new
class, which encapsulates the Togl*, the ToglConfig*, and the
GfxAttribs info, and makes all of the important info publicly
accessible. Yes, this would definitely fit in with the TclItemPkg
picture... it would allow a lot of the code to be moved out of ObjTogl
command functions and into some other abstraction. OK, these things
are coalescing into Toglet right now. But some remaining
questions... the widget should be a singleton, but conceivable we
might want to change some functionality at runtime, such as how it
handles reshapes, redraws, etc. Do these things still need to be
wrapped in a polymorphic ToglConfig-like subobject that can be
replaced with a different subobject at runtime? Right now I'm
gradually migrating existing functionality into the ToglConfig
class... need to move in the error-handling code that used to be in
ObjTogl. OK, error-handling code for setters has been moved. Next: (1
reconsider) remove project dependencies on GfxAttribs (it can be
replaced with ToglConfig now), (2 done) get rid of toglDisplayFunc and
toglReshapeFunc in ObjTogl, replace them with virtual functions in
ToglConfig, (3 done) remove loadFont from Gtext (it's replaced with
Togl::loadFont). OK, this is all done except I'm going to reconsider
whether to get rid of GfxAttribs...

(3-Jul-1999, done 3-Jul-1999) Maybe PtrList<T>::iterator should return
a pair<int, T*>?  This makes PtrList look suspiciously like a
map... which I guess is really how I am using it. The ids are just
used as tags... I'm just wary of using an STL map for implementation
since they tend to be quite sluggish... wish I had a hash_map. At
least PtrList's interface is reasonably well encapsulated so I could
try new implementations. I guess I could even try an implementation
using Tcl's hash map API... Trying the Tcl_HashMap implementation
now. Maybe need to provide two kinds of iterators: one for fast but
non-sequential access using Tcl_HashSearch, and one for slower but
sequential (sorted) access through the keys. ... OK, I see now that
the idea of the elements being ordered sequentially *was* an important
part of the interface provided by the old implementation (I think), so
for now I'll stick with the old implementation.

(5-Jul-1999) I could improve the efficiency of id-list manipulations
in Tcl by adding a new Tcl object type that stored an STL vector or
list as its internal rep. Then there would be no translations between
Tcl lists and STL vectors/sequences required... Also I could make a
Tcl_ObjType for the ids themselves, where the internal rep is a
PtrList::iterator, and the Obj is able to provide an Item* from the
list when asked. But... how to avoid having to put functions for this
stuff all in the TclCmd base class? Maybe TclCmd subclasses could add
the necessary functionality through getVectorFromArg, getGrObjFromArg,
etc. Probably I would want to wrap up Tcl_Obj in a C++ class TclObj
before doing any of this... this would actually be a great chance to
use reference-counted proxy semantics... the C++ class would be a
proxy for the Tcl_Obj, so the TclObj objects could be passed around by
value if their constructors called Tcl_IncrRefCount and the
destructors called Tcl_DecrRefCount (but how likely is aCC to ensure
that all the destructors are called in the face of
exceptions?). ... Hold on, maybe this is all too much-- it's pretty
complicated, since Tcl_ObjType is like a metaclass (the class of a
class), and Tcl_Obj is like a polymorphic class. [Later] The need for
a vector Tcl_Obj is eliminated by the introduction of STL-style
iterators than can retrieve elements of a template type from
Tcl_Obj's.

(5-Jul-1999) To trash or not to trash GfxAttribs? It's functionality
is superfluous at the moment, since all the information it provides is
available in ToglConfig, but switching dependencies from GfxAttribs to
ToglConfig will tend to introduce coupling as well as recompiling,
since ToglConfig is probably more volatile than GfxAttribs... 
Something to think about. [Later] GfxAttribs is gone bye-bye...

(7-Jul-1999, done 7-Jul-1999) Cut out ~300 lines of code by
introducing a new template TclPkg, ListItemPkg<class C, class List>,
derived from CTclIoItemPkg. This class takes a List& argument in its
constructor; this allows the class to implement getCItemFromId and
getIoFromId automatically without having to forward these operations
on to derived classes (all of whose overrides were pretty much
duplicates anyway). In addition, ListItemPkg provides a default
"constructor" or creator for its items, since again, all of these
implementations were virtually identical. Also, I improved ListPkg in
the same way so that it takes a List& argument in its constructor,
allowing it to implement getCItemFromId and getIoFromId itself.

(3-Jul-1999, done 8-Jul-1999) Tlist should inherit from PtrList so
that it can share functionality, in particular iterators. The PtrList
iterators should eliminate the need for getValidIds... OK, Tlist now
inherits from PtrList like the rest of the lists.

(8-Jul-1999, done 9-Jul-1999) There is almost certainly still a bug in
the block(), responseHdlr(), and timingHdlr() members of
ExptDriver... they catch internally an InvalidIdException that might
be generated by a failed list access attempt, but then they are still
unable to return a reference; I think they must instead allow the
exception to propogate and force the callers to deal with the
exception. Actually, easier than this would be for callers to simply
call isValidId() before they try to retrieve an item reference. OK,
set up a method assertIds() that is called at the beginning of all of
ExptDriver's event handlers; it checks if there are any invalid id's,
and if so generates an error message and halt's the experiment.

(7-Jul-1999, done 12-Jul-1999) Should make SoundTcl into a
now-standard list/item package combo. Need to define a SoundList, and
this will help other areas of the application since I won't have to
export playProc from SoundTcl namespace anymore. Also this might
facilitate writing c++-side beedback procedures for response
handlers. Sound class should be an abstract class that (in theory) can
read a variety of sound formats, and play the sounds on a variety of
audio servers. OK, this is underway. Still need to change
KbdResponseHdlr to use the new format (in fact, now KbdResponseHdlr
can "own" the sound that it wants to use...). Perhaps should add
symbolic constants in Tcl such as Sound::OK and Sound::ERR to index
the default sounds in the SoundList. --> For this, should add
linkVar() functionality to TclPkg. Also linkConstVar(). All done.

(9-Jul-1999, done 12-Jul-1999) Should rewrite Sound tests for new
Sound package implementation. Done.

(21-Jun-1999, fixed 22-Jun-1999) Bugs! Mostly in Block: 1) abortTrial
is called when the experiment is quit, but not endTrial, so the trial
index is off by one; 2) responses were getting added twice when both
processResponse and endTrial were called.

(3-Aug-1999, done 4-Aug-1999) Really weird... I turned on LOCAL_TRACE
inside bitmap.cc, and somehow now I am getting the exit-trace messages
from several other files, such as PtrList, HpAudioSound, TclCmd,
ToglConfig... This looks very oddly like somehow these are the
"missing" exit traces that are missed when certain functions are
exited via an exception throw... but wait a minute, why is there even
code present for these guys... there shouldn't even be trace code
compiled in! Have to look at this more carefully. OK... now I'm
thinking that maybe what happens is this: the Trace destructor is
defined inline, so the normal destructor call at the end of the
lexical block is inserted inline; however destructor calls that occur
due to exceptions must be made via an out-of-line function... this
means that *lots* of copies of ~Trace are lying around, and
furthermore some of them probably have LOCAL_TRACE defined, while
others don't... somehow the linker or dynamic loader must pick one of
these as the canonical version, leading to the undesirable effect that
the code that gets called for the destructor of a particular Trace
object may depend on whether that destructor is called inline or
out-of-line. This would explain why I had noticed in the past that in
some cases it appeared that Trace objects weren't being properly
destructed on exception throws... in fact they were being destructed,
but just with the wrong destructor. There are two solutions, I think:
1) put Trace inside an unnamed namespace, so each translation unit can
have and use its own special copy of ~Trace, or 2) define ~Trace
inside trace.cc, and make LOCAL_DEBUG part of the state of the Trace
object. I guess I'll go for solution (1) in the name of efficiency,
since the Trace objects are fairly ubiquitous-- I'd like to avoid out
of line calls when possible. [4-Aug] OK, I tried using an unnamed
namespace, but this didn't seem to work... anyway I think a better
solution is to have a member of Trace be a boolean that controls
whether trace messages are printed; this way all Trace objects are the
same-- the conditional compilation only controls whether they are
constructed with a boolean member as true or as false.

(7-Sep-1999, done 8-Sep-1999) Wow! X11 bitmap routines are a good 10x
faster than glDrawPixels() at putting the face/house bitmaps
onscreen. To this end, I created an XBitmap class that is similar to
Bitmap but uses X11 to render the images rather than OpenGL. But,
duh--these should be related through inheritance somehow... probably
both XBitmap and GLBitmap should derive from an abstract base
class. Or... could use an enumerated field such as itsRenderMode that
controls a submember that actually does the rendering... this would
allow switching between OpenGL and X11 on the fly. The submember class
would be something like BitmapRenderer. OK, now I've made XBitmap and
GLBitmap subclasses of the abstract base class Bitmap. In general,
Bitmap's public functions are non-virtual, but call protected virtual
functions that do the real work. Where necessary, member data from
Bitmap is passed to these hook functions.

(17-Sep-1999, done 21-Sep-1999) GrObj could have a framework for
unrendering/undrawing that is analogous to the one currently in place
for rendering/drawing. This would entail storing another OpenGL
display list. OK, there is now a virtual function grUnRender(), that
will be used for undrawing if the unrender mode of the object is set
to GROBJ_DIRECT_RENDER.

(17-Sep-1999, done 21-Sep-1999) Grobj::update() should be
non-virtual... any changes that subclasses need to make can be handled
in grRecompile(). Likewise, GrObj::draw() and GrObj::undraw() should
probably also be non-virtual. Done.

(16-Sep-1999, done 21-Sep-1999) GrObj: would be nice to have virtual
functions to get a bounding box, so that other functions can arrange
things so that different GrObj's don't collide. Also, would be nice to
set an internal scale, so that the bounding box size+aspect ratio can
be set to specific values. Done.

(21-Sep-1999, done 22-Sep-1999) Could use a Bezier class that would
store a set of control points, and would be able to evaluate the curve
at given values of u, would be able to return derivatives for given u,
would be able to find the maxima for each dimension in the range
u=[0,1]. OK, I now have a Bezier class that can evaluate the curve and
its derivative, but I don't have a way to get the extrema... Which way
to go: analytical or numerical? Numerical for now. Just do a rough
search for zero-crossings of the derivative.

(8-Sep-1999, done 21-Sep-1999) XBitmap's should be able to handle
raster data types other than 1-bit-per-pixel bitmaps. This will just
involve a few switch statements in the XBitmap member functions. OK,
done.

(23-Sep-1999, done 29-Sep-1999) GrObj::getCategory() should definitely
*not* be pure virtual. Most subclasses don't use it. There should at
least be a no-op default implementation. Also, charCount() should be
non-pure virtual, since serialize() and deserialize() are
likewise. Done.

(9-Sep-1999, done 29-Sep-1999) MorphyFace with 22 parameters to
control the face is now mostly implemented. With such an abundance of
parameters, it would be nice to have a helper class to represent the
parameters... something that contains 1) the parameter's name, 2+3)
pointer-to-members for get+set functions, 4+5) the parameter's min+max
values, 6) the quantum for the parameter. Also, a class static
function should be able to retrieve a reference to a list of all the
parameters. Also, a class static should be able to return a particular
parameter given the parameter's name. Most of this framework could be
arranged in a base class. ...This is metaclasses revisited all over
again--it would be a way of moving some of the TclPkg stuff back into
the actual classes. The nice thing about having a parameter class is
that it makes it convenient to set up different manipulators that work
on the parameter. In fact, the TclCmd's that are generated by
declareCAttrib() are just command-line manipulators. [17-Sep-1999] The
parameter information such as its name, pointer-to-members, etc. does
not need to be stored separately for each instance of a class... this
info should be static somehow. It could be provided through template
parameters to the Parameter or Property class.

(1-Jul-1999, done) With new GrObj organization, it would be simple to
add in checks for GL errors in consistent places, such as after every
call to draw(), undraw(), grRender().

(3-Oct-1999, done 4-Oct-1999) Need to provide non-file way of
constructing Fish.

(2-Oct-1999, done 4-Oct-1999) The Tcl initialization of a class should
provide a function or variable so that the Tcl side can get access to
a list of properties and value ranges. Done in PropertyListItemPkg<>.

(4-Oct-1999, done 5-Oct-1999) Need to fix error reporting from
TclValue's, so that we get only one message, not two.

(3-Oct-1999, done 5-Oct-1999) Need to check file validity in Fish
read_file functions. Done by way of porting the read_file functions
from C I/O library to the C++ I/O library.

(3-Oct-1999, 5-Oct-1999) loadFacesCmd() should be moved to a more
generic command in ObjListTcl. Hey--actually, this should be a more
generic command in PtrList; something like loadObjects(). The function
should be able to either use a virtual constructor, or be told that
all the objects are of a specific type. OK, this is mostly done--I
added a LoadObjectsCmd to ObjlistTcl. This can be easily genericized
to work with all PtrList's at some point, but it's not necessary or
worth the hassle right now.

(3-Oct-1999, done 5-Oct-1999) Need to provide a way for Response
events to trigger in a Timing Handler without necessarily canceling
all of the start events. Maybe this could be the default behavior if
the size of the itsResponseEvents vector is 0.

(13-Oct-1999, done 13-Oct-1999) ThTcl-ThList::stringify fails on SGI
with "unable to create object of type TimingHandler". Fixed... this
was one of many problems related to typename mangling under g++, so I
set up a demangle() function that is implemented per platform to
demangle (if necessary) the result of typeinfo::name() back into
something that looks like how the type was declared in the source
code.

(12-Oct-1999, done 13-Oct-1999) Need to implement some new GL commands
in TclGL, especially those relating to RGBA, antialiasing, etc. OK--
implemented glClearColor, glBlendFunc, glEnable (which gives GL_BLEND,
GL_LINE_SMOOTH, and GL_POLYGON_SMOOTH).

(13-Oct-1999, done 14-Oct-1999) swapForeBack() should become a static
GrObj function.

(13-Oct-1999, done 14-Oct-1999) IO should provide a static
eatWhitespace() utility function.

(13-Sep-1999, done 14-Oct-1999) Should add a char const to IO like SEP
that contains a default separator, so that all of the serialize()
functions don't have to always declare "char sep = ' '".

(13-Oct-1999, done 14-Oct-1999) setForeground and setBackground should
take RGBA rather than just RGB.

(12-Oct-1999, done 14-Oct-199) SGI needs a Sound implementation, even
if it's only a stub.

(12-Oct-1999, done 14-Oct-199) Need to allow RGBA mode to work
throught the project--somehow need to encapsulate the modality of
color index vs. RGBA. Locations of use of glIndex:
<morphyface.cc>::draw_hair(), Tlist::undraw(),
ToglConfig::writeEpsFile().

(15-Oct-1999, done 15-Oct-1999) Did a full implementation of
IrixAudioSound using SGI's Audio Library and Audio File Library.

(19-Oct-1999, done 19-Oct-1999) attributeCount() is no longer needed
in IO.

(note 19-Oct-1999) For better or for worse, I think I'm going to allow
null pointers to be serialized. This involves introducing the
convention of using 0 as the IO::id() for a null object.

(22-Oct-1999) Can now write generic IO tests, which take a class name
and a list of properties, and then try reading/writing an object to
make sure the values of those properties are correctly retrieved.

(21-Oct-1999, done 2-Nov-1999) Fixpt needs to change its Tcl class
name to FixPt. Done, but injected all the FixPt:: commands back into
the Fixpt:: namespace for the time being to preserve backward
compatibility.

(2-Nov-1999) Major flaw in serialize/deserialize semantics: when doing
virtual construction with newIO, we first read the typename, and then
deserialize using ~IO::TYPENAME in the flags. However, this turns off
typename reading in base classes as well, which is disastrous. For
now, I guess we can explicitly force typenames to be used when calling
serialize or deserialize on a base class, but this is pretty ugly.

(3-Nov-1999, done 3-Nov-1999) Need a way to script experiments, so
that we can run several experiments in a row, and a new experiment can
depend on the subject's performance in a previous experiment. OK, I
added a callback from ExptDriver to Tcl that occurs when an experiment
is completed. This is mediated by the Tcl proc
Expt::doUponCompletion. This allows for varying logic at the end of an
experiment, for example, whether to run another experiment can be
decided based upon the results of the previous experiment.

(3-Nov-1999, done 3-Nov-1999) ExptDriver needs some major
refactoring... probably best to go the same route as with GrObj: put
all data in a private implementation class, then eventually put all
behavior in the implementation class. OK, I've set the ball rolling
here by moving data+behavior into ExptImpl... eventually this behavior
will become better factored.

(8-Nov-1999, done 8-Nov-1999) Problem with
AsciiStreamReader::readRoot()-- if a root object is passed in, it is
not assigned to the correct slot in the itsCreatedObjects map, since
its current IO::id() is used, which may not be the same as the id that
it had when it was serialized. We'll need to use the first id that is
read from the stream to determine the correct value for the root
id. OK, this is done, although it looks a bit ugly. Maybe I'll find a
way to refactor...

(8-Nov-1999, done 9-Nov-1999) In KbdResponseHdlr, need to determine
which functions can allow exceptions to propagate out, and which
functions must catch exceptions and convert them into a
Tcl_BackgroundError. I suppose a good first guess is that the private
functions in Impl can let the exceptions go, and the public functions
should catch them. OK, the error handling has been fairly well cleaned
up. In particular, there is a try block in privateHandleCmd that wraps
the call to handleResponse().

(21-Jun-1999, fixed 9-Nov-1999) Bug! my TclObjPtr is woefully
broken. The copy constructor was broken--it was trying to
Tcl_DecrRefCount() on itsObj before itsObj had been set to a
meaningful value.

(3-Nov-1999, done 11-Nov-1999) Need to implement
ExptDriver::readFrom() and writeTo() so we can switch over to using
Serializer everywhere. To do this, we need to allow mulitple roots to
be read and written via Reader/Writer. ... OK, I've handled this
instead by allowing owned objects to be read and written-- this way
ExptDriver acts as though it owns all of the singleton PtrList's, and
reads/writes them as its own.

(9-Nov-1999, done 16-Nov-1999) Need to implement readFrom/writeTo for
Trial. Done. The main innovation to make this easy was to introduce
stream insertion and extraction methods into the class Value. This
allows subclasses of Value to be written or read in place by a Reader
or Writer. This technique was used to handle Trial::Response and
Trial::IdPairs as value types.

(8-Nov-1999, nixed 16-Nov-1999) Value should have getStringRep() and
setStringRep() virtual functions so that we can avoid switch
statements on getNativeType() inside AsciiStreamReader/Writer. The
need for this has effectively been averted by the introduction of
virtual functions printTo() and scanFrom() to handle stream insertion
and extraction for Value's.

(4-Nov-1999, nixed 16-Nov-1999) Reader/Writer needs to have facilities
for in-place objects (i.e. owned objects), that are referenced only
once in a hierarchy and therefore can be handled in place rather than
by writing an IO id number and deferring the read/write. This will
help to make for more readable files. Function should be called
read/writeOwnedObject. Hmmm... this is trickier than I thought--
reading objects in-place would require a significantly more complex
main read loop, since we essentially need stack frames for each level
of nesting-- there will be multiple sets of attributes active at any
one time. Perhaps it's best to defer this functionality until later,
since it is mainly a convenience to make files more readable. Wait a
moment... there's a distinction here between writing owned objects,
and writing objects in place... handling owned objects *is* definitely
important in order to be able to implement reading/writing Singletons,
for example. [Later] ... OK, I've avoided this issue by provided class
Value with methods printTo() and scanFrom(), which are intended to do
simple stream insertion and extraction. Clients can subclass Value for
types that should be treated as value types, and therefore be read and
written in place. This helps keep a clear distinction between value
types and object types.

(nixed 17-Nov-1999) [this has all been nixed by the introduction of
Reader/Writer, which allows for generic serialization and
deserialization] "generic" file descriptor format??? still need to
have ways to change internal format, and thus serialization format, of
objects while still being able to read old formats.

Wow... I just realized what the Holy Grail of this IO stuff would
be... each class would not even have to write its own serialize and
deserialize functions. Instead, it would have functions to provide a
list/vector of serializable's that it contains and would like to have
considered for reading and writing. Then, this function would be
called by a generic serialize or deserialize function in the base
class (IO) when an object needs to be read or written. This would be a
Good Thing. But how would this work with different revisions of
classes??? (Later...) Almost as good would be able to ignore order
when serializing/deserializing, and read/write members by name.

There is the thorny issue of memory management here... what to do with
all these little IoWrapper objects that will be floating around? Are
the part of an objects state (in which case they are wasted most of
the time) or are they created dynamically when a read or write is
impending? In the latter case, how can we treat handle both
dynamically allocated IoWrapper's and more hefty IO classes without
mucking up the memory management?

Think about more general way to do serialization. Concern is that file
format is not neatly stated in one place, but rather must be
maintained across serialize, deserialize, and a charcount
procedure. Charcount could be improved by using a special ostream that
doesn't really write anything but instead counts characters. Then the
charcount could be obtained by running serialize onto this special
ostream, then calling the ostream's count() function.

Make serializable wrappers for built-in types, like ioInt, ioDouble,
etc. that implement the IO interface. Then these could be used for the
members of classes derived from IO. !!! Actually, the member variables
don't need to *be* these wrappers. Instead, each class could hold a
collection of references/pointers (?) to serializable objects. The
ioInt wrapper would just hold a reference to the actual int member
variable. The list of serializables would be established in the
constructor, the appropriate references made, etc.... then
serialize/deserailize is just a matter of a simple for each!!! This
would avoid any possibility of inconsistencies between
serialize+deserialize. How would this interact with maintaining
compatibility with older versions of objects?

(1-Jul-1999, nixed 17-Nov-1999) Idea: could handle serialization of
vectors by defining a new vector iterator that is a subclass of IO?

(19-Jul-1999, done ???) Idea for how to do feedback through response
handlers: response handlers take a list of pairs where each pair
consists of a Tcl expression and a Tcl script. When a response is
given, the Tcl expressions are evaluated in order until one evaluates
to true; in that case the associated Tcl script is executed (probably
plays a sound or something), and the feedback procedure
returns. Oops... how do we pass information about the response value
to the expressions? Set up a Tcl variable that contains the response
value before we evaluate the expression, then unset it afterwards.

(13-Oct-1999, nixed 17-Nov-1999) Need a better way to robustly
serialize string's, avoiding problems related to leading whitespace,
etc... [Later] This is all taken care of by Reader/Writer

(21-Jun-1999, done ???) There should be an easy way to automatize the
code for creating items in Tcl packages... it just needs to be a
command class parameterized by the type of object to create, and the
list to add it to. Done, with TclItemCmd.

(note 11-Nov-1999) Should GrObj's draw function take a Window
argument, where the Window function provides the graphics primitives
such as draw line, etc...? Yes! Actually, I'd call it a Canvas
argument, and it could include the functionality of the widget part of
ToglConfig.

(note 10-Nov-1999) I think conceptually there are two different
abstractions in ToglConfig-- one represents the widget, with its
screen width + height, and the other represents the "camera", or the
view into the OpenGL world, with its viewport,
perspective/orthographic projection, etc.

(28-Jun-1999, done 18-Nov-1999) Need Stopwatch class to handle all
this timing stuff that needs to go on.

(20-Nov-1999, done 20-Nov-1999) Could make Factory a little faster to
compile by avoiding the #include <map>. 1) Make a non-template
CreatorMapBase class that has an Impl class that hides a map<string,
void*>, with implementation in the .cc file. CreatorMapBase has an
abstract destroy(void*) function that is implemented to take care of
deleting the elements. 2) Make a typesafe templated wrapper around
CreatorMapBase. 3) Factory<Base> uses CreatorMap<Base>. Done.

(20-Jul-1999, done 21-Nov-1999) It would be highly prudent to split
off the implementation of PtrList<T> into a non-template base class
IoPtrList. The implementation of PtrList::serialize and
PtrList::deserialize requires that T be derived from IO anyway, so
this doesn't really restrict things. Then PtrList<T> could derive from
IoPtrList and achieve type-safety with casts to and from IO*;
furthermore PtrList<T> could now be defined in a header file alone
using simple inlines, avoiding explicit instantiations. This would
eliminate nearly all of the code bloat caused by the current six
instantiations of PtrList<T>, and would also significantly reduce the
recompilation time associated with changes to the implementation of
PtrList (now IoPtrList). Oops... PtrList::deserialize requires a
dynamic cast to ensure that the created object is of the correct
type... maybe we can fix this by adding a pure protected virtual to
IoPtrList called typeCheck(IO* p), which will be implemented in the
derived PtrList<T> to test dynamic_cast<T*>(p) for success. This can
be easily inlined. Arrgh. I implemented IoPtrList, but then when I got
to implementing PtrList<T> as a private derivative of IoPtrList, I
realized that the getPtr() functions in PtrList<T> must do a
*dynamic_cast*, not a static_cast, in order to convert the result of
IoPtrList::getPtr (which is an IO*) into a T*. This incurs a
significant runtime cost, whereas a static_cast would have none. Is
there no way to avoid this mess, i.e. to allow one underlying
implementation of an IO* list, yet allow type-safety through
templatized wrappers? I think somehow it should be possible, with the
idea that a dynamic_cast may be necessary when storing
pointers. [Later] ... OK, this is finally done. I split off the
implementation of PtrList into two base classes--VoidPtrList and
IoPtrList. VoidPtrList provides the basic storage management in a
vector<void*>, and delegates the destruction of pointed-to objects to
the abstract function deletePtr(). IoPtrList provides the IO
operations, and delegates the cast to/from IO* to abstract functions
fromVoidToIO() and fromIOToVoid(). PtrList<> then provides a typesafe
wrapper for all of this functionality. It stores the pointers by
static_cast'ing between void* and T*; IO*'s are retrieved by
static_cast void* to T*, then dynamic_cast T* to IO*.

(21-Nov-1999, under way) Would like to split project into loosely
coupled subprojects that can be used separately in other
projects. Each subproject should generate its own library. OK, I think
the way to manage this large task is to split the steps into 1)
logically partitioning things into namespaces, 2) physically
partioning things into different libraries, 3) physically partitioning
the source + libraries into different directories, and 4) generating
separate makefiles for each directory. I've started this process with
doing 1+2) for the Tcl namespace, and the tclworks library.

(30-Nov-1999, done 30-Nov-1999) How to avoid 'unused variable'
warnings with FactoryRegistrar's? ... moved the registration from the
constructor into a static operation.

(24-Nov-1999, done 1-Dec-1999) Should refactor Bitmap with an Impl
structure so we can add private functions like an invariant.

(1-Dec-1999, done 1-Dec-1999) Can avoid the need for a global
Experiment by passing an Experiment* argument to all participants in
Experiment (such as TimingHandler, ResponseHandler, etc.).

(2-Dec-1999, done 2-Dec-1999) BmapRenderer should be able to defer
calls to bytesChangeHook() until just before doRender() is
called... this way, bytesChangeHook() can have available the
Canvas/Window argument it needs to extract X11 info. Who is
responsible for this? BmapRenderer itself, or its owner? Aha!
Actually, bytesChangeHook() doesn't need to pass in arguments... it is
just a way of notifying subclasses that the bytes of changed... if
they care, they can maintain a bit that keeps track of this... then,
when doRender comes along, they can update if necessary before doing
the drawing! This should be more efficient as well, since it avoids
unnecessary bit-twiddling if multiple byte changes occur between calls
to doRender().

(1-Dec-1999, done 2-Dec-1999) Should work to uncover cyclic
dependencies uncovered by ldep. Main ones are GrObj<->Bitmap, and
ExptDriver<->TrialEvent, TimingHdlr. Done... this was a good lesson in
the benefits of abstract protocol classes...

(3-Dec-1999, done 3-Dec-1999) writeResponsesProc should move out of
TlistTcl and into a separate TlistUtils component. Done.

(14-Oct-1999) I'm just realizing there are two main ways objects get
drawn on the screen... through TlistTcl::showCmd, and through
TlistToglConfig::display(). These two should do exactly the same
thing, and probably share an implementation. Last remaining problem is
how to store information about the current trial... specifically, when
Block calls drawTrial()--if the window triggers a redraw callback, it
won't have any way to know about the current trial. We could add a
setCurrentTrial() method to the Experiment abstraction... but this
seems a bit out of place, perhaps? Still, it might be the best way to
avoid dependencies. OK, all of the drawing stuff has now been moved
into TlistWidget, which maintains the current trial and visibility.

(8-Jul-1999, nixed 5-Dec-1999) Idea for how to unify ItemPkg's that
require an id and those that don't, and also allow Pkg::with
statements... use the idea that an id of -1 means "use the default
item". In pkg's where an id is not required, the default is to "always
use the default", but where an id is required, there could be a
'Pkg::with id' command to specify which item should be the default if
an id is not given or is -1. ...However, would this really help
things? Would the length of the argument list have to change when we
are inside a 'with' scope?

(8-Jul-1999, done 5-Dec-1999) Tlist still has this kooky augmented
interface... some of the functionality could be moved out to the new
Toglet structure, and some of it is just plain not needed (like
addToTrial... this can be done with a getPtr followed by
Trial::add). redraw(), undraw(), clearscreen(), etc. sound
oh-so-suspiciously like they belong with the Togl stuff.
loadFromObjidsOnly could go in some TlistBuilder class (along with
makeSingles, makePairs, makeTriads, and makeSummaryTrial, I might
add). ... This is now all done.

(6-Dec-1999, done 6-Dec-1999) More things to add to Canvas:
flushOutput() function. StateSaver class to manage
push/popState. clearColorBuffer().

(6-Dec-1999, done 6-Dec-1999) Remove ExptDriver's dependence on
GLCanvas::theCanvas() by adding a getCanvas() function to Widget(),
and implementing this in ToglWidget to return GLCanvas::theCanvas().

(5-Dec-1999, done 6-Dec-1999) GfxAttribs stuff should move into
Canvas... isRgba(), isColorIndex(), isDoubleBuffered(),
hasPrivateCmap(), screenPpi()?

(1-Dec-1999, done 6-Dec-1999) OK, now we desperately need a Canvas
argument to the grRender() functions. This would avoid all this muck
about trying to initialize X11 info correctly in XBmapRenderer--
instead, we could just pass a Canvas argument that contains (or can
fetch) the necessary X11 info. How would this Canvas get passed
around? Needs to end up at GrObj::draw(), from Trial::trDraw(), from
Block::drawTrial() or TlistWidget::safeDrawTrial.

(done 6-Dec-1999) Eliminated GfxAttribs from the project.

(7-Dec-1999, done 7-Dec-1999) Should move the declarations of
TVecSetterCmd, etc. out of tclitempkg.cc and into the header file so
that they can be reused via inheritance. Done.

(7-Dec-1999, done 7-Dec-1999) Can add Tcl_Interp* argument to
ExptDriver c'tor now.

(7-Dec-1999, done 7-Dec-1999) Potential unsigned problem in TclItemPkg
with 'max_valn = vals.size() - 1'. Fixed with check vals.size() >= 1.

(6-Dec-1999, done 7-Dec-1999) The TclPkg's need to be able to get a
hold of a Canvas in order to properly call some functions now, like
GrObj::update(), and potentially GrObj::getBoundingBox(). Probably we
need to provide global access to an Experiment*, from which we can
retrieve a Canvas*. OK, this is done with the Application abstraction,
which can fetch an Experiment*.

(11-Dec-1999) Ugh. Lost about eight days of work in the crash of
snowball2. So, goal #1 is to come up with my own backup plan for this
project so that I don't lose any more 2,000 lines of source code. Need
to have a 'make' target that will do everything needed to tar the
source files and ftp them somewhere safe. ... Very thankfully, Anne
was able to restore the contents of my home directory from snowball2
after some "hardcore scraping". Hopefully I've learned a lesson
here... backup backup backup!

(7-Dec-1999, done 16-Dec-1999) I guess I need to split tclitempkg into
two componenets, one with TclItemPkg, Getter, Setter, Attrib, and
Action, and another with CTclItemPkg, CTclIoItemPkg, etc. OK, this is
done by creating "tclitempkgbase.h" to contain Getter, Setter, Attrib,
Attrib, Action, and TclItemPkgBase.
